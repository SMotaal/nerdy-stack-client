{"version":3,"sources":["webpack:///app.js","webpack:///webpack/bootstrap 5f1752b4c883c488cc1b","webpack:///./bower_components/polymer/src/utils/boot.html","webpack:///./bower_components/polymer/src/utils/utils.html","webpack:///./bower_components/polymer/src/utils/case-map.html","webpack:///./components/nerdy-components/bindings/nerdy-binding.ts","webpack:///./components/nerdy-components/bindings/polymer-binding.ts","webpack:///./components/nerdy-components/decorators.ts","webpack:///./components/nerdy-components/dom.ts","webpack:///./components/nerdy-components/dom/nerdy-dom.ts","webpack:///./components/nerdy-components/elements/nerdy-element.ts","webpack:///./components/nerdy-components/templates/nerdy-template.ts","webpack:///./bower_components/polymer/src/events/event-listeners.html","webpack:///./bower_components/polymer/src/template/resolve-url.html","webpack:///./bower_components/polymer/src/template/template-stamp.html","webpack:///./components/hello-world.html","webpack:///./components/hello-world.tsx","webpack:///./components/nerdy-components/bindings.ts","webpack:///./components/nerdy-components/decorators/custom-element.ts","webpack:///./components/nerdy-components/decorators/enumerable.ts","webpack:///./components/nerdy-components/elements.ts","webpack:///./components/nerdy-components/elements/nerdy-elements-helpers.ts","webpack:///./components/nerdy-components/elements/polymer-element.ts","webpack:///./components/nerdy-components/index.ts","webpack:///./components/nerdy-components/templates.ts","webpack:///./bower_components/polymer/polymer-element.html","webpack:///./bower_components/polymer/src/attributes/attributes.html","webpack:///./bower_components/polymer/src/elements/element.html","webpack:///./bower_components/polymer/src/legacy/dom-module.html","webpack:///./bower_components/polymer/src/properties/property-accessors.html","webpack:///./bower_components/polymer/src/properties/property-effects.html","webpack:///./bower_components/polymer/src/styling/style-gather.html","webpack:///./bower_components/polymer/src/styling/style-util.html","webpack:///./bower_components/polymer/src/template/annotations.html","webpack:///./bower_components/polymer/src/utils/path.html","webpack:///./index.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","document","_htmlStr","head","el","div","createElement","innerHTML","children","length","appendChild","write","body","window","Polymer","version","reflect","[object Object]","whenImportsReady","cb","HTMLImports","whenReady","Element","matchesSelector","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","dedupeId","Utils","target","source","api","n$","getOwnPropertyNames","this","copyOwnProperty","pd","getOwnPropertyDescriptor","node","getRootNode","parentNode","selector","mixin","base","__mixinApplications","WeakMap","map","application","set","cachingMixin","__id","__dedupeId","baseSet","__mixinSet","extended","create","href","onload","onerror","optAsync","link","querySelector","rel","setAttribute","cleanup","removeEventListener","loadListener","errorListener","event","__dynamicImportLoaded","removeChild","addEventListener","dispatchEvent","Event","CaseMap","_caseMap","_rx","dashToCamel","camelToDash","dashToCamelCase","dash","indexOf","replace","toUpperCase","camelToDashCase","camel","toLowerCase","createTemplateBindingFunction","context","literals","NerdyTemplateBindingFunction","flattenResults","results","Array","isArray","dashCaseString","more","arguments","argument","convertFromDashToCamel","convertFromCamelToDash","String","PolymerTemplateBindingFunction","__export","nerdy_dom_1","createElementFromTagName","default","createElementFromClass","createErrorElement","createWrappedElement","convertToElement","applyAttributes","insertChild","insertChildren","NerdyDOM","activeDOM","targetDocument","activeDocument","method","bind","console","log","tag","exception","message","is","contents","trim","element","reduce","item","createComment","undefined","createTextNode","HTMLElement","wrapper","Error","shift","child","attributes","error","parent","HTMLTemplateElement","content","TypeError","forEach","keys","__decorate","decorators","key","desc","r","Reflect","decorate","__metadata","k","v","metadata","decorators_1","nerdy_elements_helpers_1","NerdyElement","super","created","propertyLookup","constructor","constructorName","displayName","isConstructor","tagName","tagNameAvailable","elements","customElementNameAvailable","customElements","alreadyDefined","define","whenDefined","then","observedAttributes","template","nerdyTemplate","ready","setProperties","getAttributesObject","connectedCallback","attached","disconnectedCallback","detatched","adoptedCallback","adopted","attribute","oldValue","newValue","attributeChangedCallback","attributeChanged","values","assign","properties","findPropertyName","simpleName","test","find","index","off","Function","DOM","bindings_1","NerdyTemplate","component","PolymerBindingFunction","BindingFunction","createNodeEventHandler","eventName","methodName","_methodHost","handler","e","detail","warn","EventListeners","dedupingMixin","superClass","_addEventListenerToNode","resolveCss","cssText","ownerDocument","CSS_URL_RX","pre","url","post","resolve","resolveAttrs","URL_ATTRS","a","at","a$","localName","search","BINDING_RX","ABS_URL","resolver","getUrlResolver","resolveUrl","baseUri","tempDoc","implementation","createHTMLDocument","tempDocBase","__urlResolver","*","form","ResolveUrl","applyIdToMap","inst","dom","note","id","_findTemplateAnnotatedNode","applyEventListener","host","events","j","e$","_addMethodEventListenerToNode","applyTemplateContent","templateContent","_content","TemplateStamp","Annotations","$","notes","_parseTemplateAnnotations","importNode","__noInsertionPoint","_hasInsertionPoint","nerdy_components_1","HelloWorld","HelloWorld_1","counter","class","onclick","className","container","style","declared","getElementsByTagName","transpiled","constructed","info","[class.constructor]","[class.prototype]","[element.prototype]","[elements]","customElement","NerdyBinding","PolymerBinding","registerElement","getTagName","descriptor","on","nerdy_element_1","NamedNodeMap","from","goog","objectProperty","nerdy_template_1","caseMap","Attributes","__serializing","hasAttribute","_valueToNodeAttribute","type","_deserializeAttribute","str","_serializeAttribute","removeAttribute","Date","toString","JSON","stringify","x","outValue","Number","Boolean","parse","flattenProperties","flattenedProps","props","ElementMixin","PropertyEffects","PolymerElement","_ownConfig","__ownConfig","config","_flattenedProperties","__flattenedProperties","superCtor","getPrototypeOf","_flattenedPropertyDefaults","__flattenedPropertyDefaults","_observedAttributes","_addPropertiesToAttributes","list","prop","push","finalized","_finalized","proto","superProto","finalize","telemetry","register","_finalizeConfig","_finalizeTemplate","cloneNode","_createPropertyFromConfig","observers","_createMethodObserver","DomModule","import","_template","_getTemplate","StyleGather","cssFromElement","textContent","insertBefore","firstChild","ShadyCSS","prepareTemplate","extends","_bindTemplate","instanceCount","hostStack","registerHost","_initializeProperties","p$","_isPropertyPending","_hasReadOnlyEffect","_setProperty","computed","readOnly","_createComputedProperty","_createReadOnlyProperty","reflectToAttribute","_hasReflectEffect","_createReflectedProperty","notify","_hasNotifyEffect","_createNotifyingProperty","observer","_createObservedProperty","updateStyles","isEmpty","_flushProperties","beginHosting","root","_stampTemplate","_attachDom","endHosting","attachShadow","shadowRoot","mode","old","_attributeToProperty","applyStyle","assetpath","baseURI","stack","_enqueueClient","stackLen","pop","registrations","_regLog","dumpRegistrations","lcModules","findModule","__assetpath","getAttribute","useNative","importForElement","imp","_styleOutsideTemplateCheck","saveAccessorValue","model","nativeProperties","__data","_setPendingProperty","__dataProto","PropertyAccessors","__dataCounter","__dataPending","__dataOld","__dataInvalid","_invalidateProperties","_shouldPropertyChange","Promise","oldProps","changedProps","_propertiesChanged","currentProps","ensureOwnEffectMap","effects","slice","runEffects","fromAbove","hasPaths","ran","runEffectsForProperty","rootProperty","Path","fxs","fx","lastRun","pathMatchesTrigger","trigger","fn","path","triggerPath","structured","isAncestor","wildcard","isDescendant","runObserverEffect","runNotifyEffects","__notifyEffects","notified","notifyPath","__dataHost","dispatchNotifyEvent","queueProperty","CustomEvent","runNotifyEffect","addNotifyListener","handleNotification","negate","targetPath","translate","setPropertyFromNotification","__readOnly","_setPendingPropertyOrPath","runReflectEffect","sanitizeDOMValue","attrName","_propertyToAttribute","runComputedEffects","computeEffects","__computeEffects","computedProps","inputProps","runComputedEffect","result","runMethodEffect","computedProp","methodInfo","__propertyEffects","computeLinkedPaths","links","__dataLinkedPaths","cache","__dataTemp","b","addBindingEffect","parts","part","signature","addMethodBindingEffect","literal","kind","_addPropertyEffect","TYPES","PROPAGATE","runBindingEffect","propertyName","isCompound","compoundIndex","customEvent","__dataNodes","isPath","applyBindingValue","computeBindingValue","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","join","createMethodEffect","runMethodBindingEffect","val","processAnnotations","_processed","bindings","parseMethod","_notes","hostProps","_hostProps","discoverTemplateHostProps","concat","b$","args","kk","templateHostProps","Base","shouldAddListener","binding","addAnnotatedListener","_bindListeners","setupBindListeners","setupBindings","nodes","setupCompoundBinding","sig","effectFn","dynamic","dynamicFn","static","arg","marshalArgs","apply","expression","match","split","parseArgs","emptyArray","argList","rawArg","parseArg","fc","isDeep","data","baseChanged","notifySplices","array","splices","splicesPath","indexSplices","notifySplice","addedCount","removed","upper","substring","ANY","COMPUTE","REFLECT","NOTIFY","OBSERVE","READ_ONLY","PROPERTY_EFFECT_TYPES","_asyncEffects","__dataInitialized","__dataPendingClients","__dataFromAbove","__dataHasPaths","effect","_createPropertyAccessor","_hasPropertyEffect","isPathNotification","hasEffect","prevProps","client","clients","__propagateEffects","_flushClients","__reflectEffects","__observeEffects","to","normalize","items","len","ret","hadLength","start","deleteCount","Math","floor","splice","unshift","propPath","protectedSetter","attr","MODULE_STYLES_SELECTOR","INCLUDE_ATTR","moduleIds","warnIfNotFound","cssFromModule","_importModule","_cssText","querySelectorAll","include","cssFromModules","__appliedElement","StyleUtil","isTargetedBuild","buildType","ShadyDOM","inUse","cssBuildTypeForModule","dm","getCssBuildType","parseTemplateAnnotations","stripWhiteSpace","currentTemplate","parseNodeAnnotations","nodeType","Node","TEXT_NODE","parseTextNodeAnnotation","parseElementAnnotations","parseBindings","text","lastIndex","bindingRegex","exec","notifyEvent","colon","literalFromParts","insertionPointTag","parseChildNodesAnnotations","parseNodeAttributeAnnotations","prepElement","t","replaceChild","parseTemplate","next","nextSibling","childAnnotation","createDocumentFragment","annotation","attrs","parseNodeAttributeAnnotation","origName","IDENT","NUMBER","SQUOTE_STRING","DQUOTE_STRING","STRING","ARGUMENT","ARGUMENTS","ARGUMENT_LIST","BINDING","OPEN_BRACKET","CLOSE_BRACKET","NEGATE","EXPRESSION","RegExp","dotIndex","newBase","last"],"mappings":"CAAU,SAASA,SCInB,QAAAC,qBAAAC,UAGA,GAAAC,iBAAAD,UACA,MAAAC,kBAAAD,UAAAE,OAGA,IAAAC,QAAAF,iBAAAD,WACAI,EAAAJ,SACAK,GAAA,EACAH,WAUA,OANAJ,SAAAE,UAAAM,KAAAH,OAAAD,QAAAC,cAAAD,QAAAH,qBAGAI,OAAAE,GAAA,EAGAF,OAAAD,QAvBA,GAAAD,oBA+DA,OAnCAF,qBAAAQ,EAAAT,QAGAC,oBAAAS,EAAAP,iBAGAF,oBAAAK,EAAA,SAAAK,OAA2C,MAAAA,QAG3CV,oBAAAW,EAAA,SAAAR,QAAAS,KAAAC,QACAb,oBAAAc,EAAAX,QAAAS,OACAG,OAAAC,eAAAb,QAAAS,MACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,UAMAb,oBAAAoB,EAAA,SAAAhB,QACA,GAAAS,QAAAT,eAAAiB,WACA,WAA2B,MAAAjB,QAAA,SAC3B,WAAiC,MAAAA,QAEjC,OADAJ,qBAAAW,EAAAE,OAAA,IAAAA,QACAA,QAIAb,oBAAAc,EAAA,SAAAQ,OAAAC,UAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,OAAAC,WAGtDvB,oBAAA0B,EAAA,GAGA1B,wCAAA2B,EAAA,MDMO,SAASvB,OAAQD,UEnExB,SAAAyB,UACA,GAAAC,UAAA,IACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAKLY,OAAAC,QAAAD,OAAAC,YACAD,OAAAC,QAAAC,QAAA,gBAQAC,SACAC,eAAAjB,EAAAb,GACA,MAAAa,QFkFO,SAASvB,OAAQD,QAASH,sBG9HjC,SAAA4B,UACA,GAAAC,UAAA,QACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAIA,WAEA,YAYA,SAAA6C,kBAAAC,IACAN,OAAAO,YACAA,YAAAC,UAAAF,IAEAA,KAdA,GAAApB,GAAAuB,QAAAzB,UACA0B,gBAAAxB,EAAAyB,SAAAzB,EAAAwB,iBACAxB,EAAA0B,oBAAA1B,EAAA2B,mBACA3B,EAAA4B,kBAAA5B,EAAA6B,sBAGAC,SAAA,CAYAf,SAAAgB,OAcAb,MAAAc,OAAAC,QACA,OAAAtD,KAAAsD,QACAD,OAAArD,GAAAsD,OAAAtD,EAEA,OAAAqD,SAYAd,OAAApB,UAAAoC,KACA,GAAApC,WAAAoC,IAAA,CACA,GAAAC,IAAA9C,OAAA+C,oBAAAF,IACA,QAAAxC,GAAAf,EAAA,EAAwBA,EAAAwD,GAAAzB,SAAAhB,EAAAyC,GAAAxD,IAA4BA,IACpD0D,KAAAC,gBAAA5C,EAAAwC,IAAApC,WAGA,MAAAA,YAAAoC,KAGAhB,gBAAAhC,KAAA+C,OAAAD,QACA,GAAAO,IAAAlD,OAAAmD,yBAAAP,OAAA/C,KACAqD,KACAlD,OAAAC,eAAA0C,OAAA9C,KAAAqD,KAKArB,YAAAuB,MACA,GAAAA,KAAAC,YACA,MAAAD,MAAAC,aAEA,KAAAD,KACA,WAEA,MAAAA,WAAAE,YACAF,UAAAE,UAEA,OAAAF,OAGAvB,gBAAAuB,KAAAG,UACA,MAAApB,iBAAA3C,KAAA4D,KAAAG,WAMA1B,aAAA2B,OACA,gBAAAC,MACAD,MAAAE,sBACAF,MAAAE,oBAAA,GAAAC,SAEA,IAAAC,KAAAJ,MAAAE,oBACAG,YAAAD,IAAAxD,IAAAqD,KAKA,OAJAI,eACAA,YAAAL,MAAAC,MACAG,IAAAE,IAAAL,KAAAI,cAEAA,cAQAhC,cAAA2B,OAMA,MALAA,OAAAR,KAAAe,aAAAP,OAEAA,MAAAQ,OACAR,MAAAS,aAAAxB,UAEA,SAAAgB,MACA,GAAAS,SAAAT,KAAAU,UACA,IAAAD,iBAAAV,MAAAS,YACA,MAAAR,KAEA,IAAAW,UAAAZ,MAAAC,KAOA,OAHAW,UAAAD,WACAnE,OAAAqE,OAAAD,SAAAD,YAAAD,SAAA,MACAE,SAAAD,WAAAX,MAAAS,aAAA,EACAG,WAsBAvC,WAAAyC,KAAAC,OAAAC,QAAAC,UACA,GAAAC,MACA7D,SAAAE,KAAA4D,cAAA,cAAAL,KAAA,kBACAI,QACAA,KAAA7D,SAAAK,cAAA,QACAwD,KAAAE,IAAA,SACAF,KAAAJ,UACAI,KAAAG,aAAA,mBAIAJ,UACAC,KAAAG,aAAA,WAKA,IAAAC,SAAA,WACAJ,KAAAK,oBAAA,OAAAC,cACAN,KAAAK,oBAAA,QAAAE,gBAEAD,aAAA,SAAAE,OACAJ,UAIAJ,KAAAS,uBAAA,EACAZ,QACAzC,sBACAyC,OAAAW,UAIAD,cAAA,SAAAC,OACAJ,UAIAJ,KAAApB,YACAoB,KAAApB,WAAA8B,YAAAV,MAEAF,SACA1C,sBACA0C,QAAAU,SAaA,OATAR,MAAAW,iBAAA,OAAAL,cACAN,KAAAW,iBAAA,QAAAJ,eACA,MAAAP,KAAApB,WACAzC,SAAAE,KAAAO,YAAAoD,MAGOA,KAAAS,uBACPT,KAAAY,cAAA,GAAAC,OAAA,SAEAb,WH8IO,SAASrF,OAAQD,QAASH,sBI9XjC,SAAA4B,UACA,GAAAC,UAAA,MACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAGA,WAEA,KAAAuG,UAEAC,YACAC,KACAC,YAAA,UACAC,YAAA,YAGAC,gBAAA,SAAAC,MACA,MAAA9C,MAAAyC,SAAAK,QACA9C,KAAAyC,SAAAK,WAAAC,QAAA,OAAAD,UAAAE,QAAAhD,KAAA0C,IAAAC,YACA,SAAAlG,GACA,MAAAA,GAAA,GAAAwG,kBAMAC,gBAAA,SAAAC,OACA,MAAAnD,MAAAyC,SAAAU,SACAnD,KAAAyC,SAAAU,aAAAH,QAAAhD,KAAA0C,IAAAE,YAAA,OAAAQ,gBAMA1E,SAAA8D,oBJ0YO,SAASnG,OAAQD,QAASH,qBAEjC,YK3cA,SAAAoH,+BAA8CC,YAC1C,MAAO,CAACzG,QAAS0G,WAAgC,gBAAZ1G,MAAK,IAAmBA,KAAK,GAAGwB,OAASiF,SAAWA,QAAQzG,KAAK,UAAYA,KAAK,OAAS,GAGpI,QAAA2G,8BAA6C3G,MACzC,WAA4B,gBAATA,MAAoBA,KAAOA,KAAK,OAWvD,QAAA4G,gBAAwBC,SACpB,GAAIC,MAAMC,QAAQF,SAAU,OAAQA,QAAQrF,QACxC,IAAK,GAAG,MACR,KAAK,GAAG,MAAOqF,SAAQ,EACvB,SAAS,MAAOA,UAOxB,QAAAf,aAA4BkB,kBAA2BC,MACnD,MAAOL,oBAAoBM,WAAwBnD,IAAIoD,UAAgC,gBAAbA,UAAwBC,uBAAuBD,UAAYL,MAAMC,QAAQI,UAAYrB,YAAYqB,UAAYA,WAG3L,QAAApB,aAA4BiB,kBAA2BC,MACnD,MAAOL,oBAAoBM,WAAwBnD,IAAIoD,UAAgC,gBAAbA,UAAwBE,uBAAuBF,UAAYL,MAAMC,QAAQI,UAAYpB,YAAYoB,UAAYA,WAhC3L5H,QAAAiH,4DAIAjH,QAAAoH,yDAoBA,MAAMS,wBAA0BnB,MAAiBA,KAAKE,QAAQ,UAAWmB,OAAO1G,UAAUwF,aACpFiB,uBAA0BpB,MAAiBA,KAAKE,QAAQ,yBAA0B,SAASA,QAAQ,kBAAmB,SAASI,aAErIhH,SAAAuG,wBAIAvG,QAAAwG,yBLkdO,SAASvG,OAAQD,QAASH,qBAEjC,YMnfaG,SAAAgI,+BAA0D,CAACvH,WAA8B,gBAATA,MAAoBA,KAAOA,KAAK,SN0ftH,SAASR,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IOjgBpE0G,SAAApI,oBAAA,KACAoI,SAAApI,oBAAA,MPwgBO,SAASI,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IQ9gBpE0G,SAAApI,oBAAA,GAEA,MAAAqI,aAAArI,oBAAA,EAEaG,SAAAmI,yBAA2BD,YAAAE,QAASD,yBACpCnI,QAAAqI,uBAAyBH,YAAAE,QAASC,uBAClCrI,QAAAsI,mBAAqBJ,YAAAE,QAASE,mBAC9BtI,QAAAuI,qBAAuBL,YAAAE,QAASG,qBAChCvI,QAAAwI,iBAAmBN,YAAAE,QAASI,iBAC5BxI,QAAA8B,cAAgBoG,YAAAE,QAAStG,cACzB9B,QAAAyI,gBAAkBP,YAAAE,QAASK,gBAC3BzI,QAAA0I,YAAcR,YAAAE,QAASM,YACvB1I,QAAA2I,eAAiBT,YAAAE,QAASO,eR+gBvC/H,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IQ7gBtDP,QAAAoI,QAAeF,YAAAE,SRmhBR,SAASnI,OAAQD,QAASH,qBAEjC,kBSjiBA+I,UAKWT,sCACH,GAAIS,SAASC,UAAW,MAAOD,UAASC,UAAUV,yBAG/CE,oCACH,GAAIO,SAASC,UAAW,MAAOD,UAASC,UAAUR,uBAG/CC,gCACH,GAAIM,SAASC,UAAW,MAAOD,UAASC,UAAUP,mBAG/CC,kCACH,GAAIK,SAASC,UAAW,MAAOD,UAASC,UAAUN,qBAG/CC,8BACH,GAAII,SAASC,UAAW,MAAOD,UAASC,UAAUL,iBAG/C1G,2BACH,GAAI8G,SAASC,UAAW,MAAOD,UAASC,UAAU/G,cAG/C2G,6BACH,GAAIG,SAASC,UAAW,MAAOD,UAASC,UAAUJ,gBAG/CC,yBACH,GAAIE,SAASC,UAAW,MAAOD,UAASC,UAAUH,YAG/CC,4BACH,GAAIC,SAASC,UAAW,MAAOD,UAASC,UAAUF,eAQtDlG,YAAYqG,eAA2BF,SAASG,gBAC5CnF,KAAKnC,SAAWqH,cAChB,KAAK,KAAME,WAAW,2BAA4B,yBAA0B,qBAAsB,uBAAwB,mBAAoB,mBAAoB,mBAAoB,gBAAiB,kBAAmB,cAAe,kBAAmBpF,KAAKoF,QAAUpF,KAAKoF,QAAQC,KAAKrF,KAC7RsF,SAAQC,IAAI,YAAcvF,KAAMA,KAAMkF,8BAAgBnB,sBAG1DlF,yBAAyB2G,KACrB,IACI,MAAOxF,MAAKnC,SAASK,cAAcsH,KACrC,MAAOC,WAEL,MADAA,WAAUC,oDAAqE,gBAARF,KAAmBA,UAAcA,UAAUC,UAAUC,UACrHD,WAIf5G,uBAAuB2G,KACnB,IACI,MAAO,IAAIA,KACb,MAAOC,WAEL,MADAA,WAAUC,kDAAoDF,IAAI3I,MAAS2I,IAAI/H,WAAa+H,IAAI/H,UAAUZ,MAAS2I,IAAIG,IAAMH,SAASC,UAAUC,UACzID,WAIf5G,mBAAmB4G,aAA8BG,UAC7C,KAAMF,UAAgC,gBAAdD,WAAyBA,UAAyC,gBAAtBA,WAAUC,QAAuBD,UAAUC,QAAU,IAAIG,OAIvHC,mBAHmBJ,QAAQrH,OAASqH,QAAU,sBAEvCE,SAASG,OAAO,CAACC,KAAMxH,OAASA,MAAwB,mBAATwH,MAAwB,KAAOA,KAAO,KAAQ,IAAK,IAAIH,OACnG7F,KAAKnC,SAASoI,wBAAwBP,QAAQrH,OAASqH,QAAU,oBAAsBE,YACvG,OAAOE,SAGXjH,iBAAiBlC,OACb,GAAcuJ,SAAVvJ,MAAqB,MAAOqD,MAAKnC,SAASsI,eAAe,YACxD,IAAc,OAAVxJ,MAAgB,MAAOqD,MAAKnC,SAASsI,eAAe,OACxD,IAAqB,gBAAVxJ,QAAsBA,gBAAiByJ,aAAa,MAAOzJ,MACtE,cAAeA,QAChB,IAAK,SAAU,MAAOqD,MAAKnC,SAASsI,mBAAmBxJ,SACvD,KAAK,SAAU,MAAOqD,MAAKnC,SAASsI,kBAAkBxJ,QACtD,KAAK,UAAW,MAAOqD,MAAKnC,SAASsI,eAAexJ,SAAU,EAAO,OAAS,QAC9E,SAAS,MAAOqD,MAAKnC,SAASsI,eAAexJ,QAIrDkC,wBAAwB+G,UACpB,KAAMS,SAAUrG,KAAKnC,SAASK,cAAc,WAC5C,IAAI0H,SAAS,YAAcU,OAAOD,QAAQ/H,YAAY0B,KAAK0E,mBAAmBkB,SAASW,QAASX,eAC3F,KAAK,KAAMY,SAASZ,UAAUS,QAAQ/H,YAAY0B,KAAK4E,iBAAiB4B,QAGjF3H,gBAAgBiH,QAAsBW,eAClC,IACI,GAA0B,gBAAfA,aAA2B,gBAAkBX,SAAS,IAAK,KAAMjJ,QAAQ4J,YAAYX,QAAQjE,aAAahF,KAAM4J,WAAW5J,OACxI,MAAO4I,WACLA,UAAUC,8CAAgDD,UAAUC,UACpEJ,QAAQoB,MAAMjB,YAItB5G,YAAYiH,QAAyCU,OAC5B,gBAAVA,OAAoBV,QAAQxH,YAAY0B,KAAKnC,SAASsI,eAAeK,QACvEA,gBAAiBJ,cAAaN,QAAQxH,YAAYkI,OAG/D3H,eAAeiH,WAAkE1H,UAC7E,KAAMuI,QAA4B,gBAAZb,UAA0BA,kBAAmBM,aAAsBN,kBAAmBc,qBAAsBd,QAAQe,QAAUf,QAAlE,IAClF,KAAKa,OAAQ,KAAM,IAAIG,8GACH,iBAAb1I,UAAwB4B,KAAK8E,YAAY6B,OAAQvI,UAAYA,SAAS2I,QAAQP,OAASxG,KAAK8E,YAAY6B,OAAQH,QAG3H3H,cAAc2G,IAAuCiB,iBAA6CrI,UAE9F,IAGI,KAAM0H,SAAyB,gBAARN,KAAmBxF,KAAKuE,yBAAyBiB,KAAOxF,KAAKyE,uBAAuBe,IAG3G,OAAIM,mBAAmBQ,OAActG,KAAK0E,mBAAmBoB,SAAWN,QAAKiB,sBAAYrI,qBAGrFqI,YAAczJ,OAAOgK,KAAKP,YAAYpI,QAAQ2B,KAAK6E,gBAAgBiB,QAASW,YAG5ErI,SAASC,QAAQ2B,KAAK+E,eAAee,WAAY1H,UAG9C0H,SACT,MAAOL,WACLH,QAAQoB,MAAMjB,aAxI1BrJ,QAAA4I,kBA8IKA,SAASG,iBAAgBH,SAASG,eAAiBtH,UACnDmH,SAASC,YAAWD,SAASC,UAAY,GAAID,WTiiBlDhI,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IS/hBtDP,QAAAoI,QAAeQ,UTqiBR,SAAS3I,OAAQD,QAASH,qBAEjC,YAEA,IAAIgL,YAAcjH,MAAQA,KAAKiH,YAAe,SAAUC,WAAYvH,OAAQwH,IAAKC,MAC7E,GAA2HxK,GAAvHF,EAAIqH,UAAU1F,OAAQgJ,EAAI3K,EAAI,EAAIiD,OAAkB,OAATyH,KAAgBA,KAAOpK,OAAOmD,yBAAyBR,OAAQwH,KAAOC,IACrH,IAAuB,gBAAZE,UAAoD,kBAArBA,SAAQC,SAAyBF,EAAIC,QAAQC,SAASL,WAAYvH,OAAQwH,IAAKC,UACpH,KAAK,GAAI9K,GAAI4K,WAAW7I,OAAS,EAAG/B,GAAK,EAAGA,KAASM,EAAIsK,WAAW5K,MAAI+K,GAAK3K,EAAI,EAAIE,EAAEyK,GAAK3K,EAAI,EAAIE,EAAE+C,OAAQwH,IAAKE,GAAKzK,EAAE+C,OAAQwH,OAASE,EAChJ,OAAO3K,GAAI,GAAK2K,GAAKrK,OAAOC,eAAe0C,OAAQwH,IAAKE,GAAIA,GAE5DG,WAAcxH,MAAQA,KAAKwH,YAAe,SAAUC,EAAGC,GACvD,GAAuB,gBAAZJ,UAAoD,kBAArBA,SAAQK,SAAyB,MAAOL,SAAQK,SAASF,EAAGC,GUnsB1GzL,qBAAA,GAEA,MAAA2L,cAAA3L,oBAAA,GAEA4L,yBAAA5L,oBAAA,SAEA6L,qBAAkCpJ,SAAQQ,QAsFtCL,cACIkJ,SAAmC,kBAAjB/H,MAAKgI,SAA0BhI,KAAKgI,UACtDhI,KAAKiI,kBAnFFpJ,cAAcqJ,aAEjB,KAAMC,iBAAkBD,cAAiBA,YAAoBrL,MAASqL,YAAoBE,oBAAuBF,YAEjH,KAAKJ,aAAaO,cAAcH,aAAc,KAAM,IAAI5B,0FAAyF6B,2BAEjJ,MAAMG,SAAUJ,YAAYvC,GACtB4C,mBAAqBD,UAAWR,cAAaU,UAC7CC,2BAAoEvC,SAAvCzH,OAAOiK,eAAetL,IAAIkL,SACvDK,gBAAkBJ,kBAAoBT,aAAaU,SAASF,WAAaJ,WAG/E,IAAIK,kBAAoBE,2BAA4B,CAChD,GAAI3C,QACJ,KACIA,QAAUjI,SAASK,cAAcoK,SACnC,MAAO7C,WACL,KAAM,IAAIa,6DAA4DgC,4DAA4D7C,UAAUC,gBAE7I,KAAK6C,iBACR,KAAM,IAAIjC,6DAA4DgC,0DACnE,KAAKG,2BACR,KAAM,IAAInC,6DAA4DgC,6EAG1E,IAAIK,eAAJ,CAEA,GAAIL,UAAWR,cAAaU,SAAU,KAAM,IAAIlC,yDAAwDgC,wBAAwBH,6RAEhI,IAAIM,2BACA,IACIhK,OAAOiK,eAAeE,OAAOV,YAAYvC,GAAIuC,aAC/C,MAAOzC,WACL,KAAM,IAAIa,oGAAmGb,UAAUC,WAI/HoC,aAAaU,SAASF,SAAWJ,YAEjCzJ,OAAOiK,eAAeG,YAAYP,SAASQ,UACvC,GAAIrK,OAAOiK,eAAetL,IAAIkL,WAAaR,aAAaU,SAASF,SAC7D,KAAM,IAAIhC,0HAAyHgC,qaAMxIS,8BAA8BtC,YAC7BzG,OAAS8H,cACb9K,OAAOC,eAAe+C,KAAM,sBACxBrD,MAAO8J,aAIRd,cAAc9I,MACbmD,OAAS8H,cACb9K,OAAOC,eAAe+C,KAAM,MACxBrD,MAAOE,OAIR8I,gBACH,GAAI3F,OAAS8H,aACb,MAAO9K,QAAOC,eAAe+C,KAAM,MAAQrD,MAAOqD,KAAKnD,KAAKmG,QAAQ,yBAA0B,SAASA,QAAQ,kBAAmB,SAASI,iBAAoBpD,KAAK2F,GAGjKqD,sBACH,GAAIhJ,OAAS8H,aACb,MAAO9H,MAAKiJ,eAAiBjJ,KAAKiJ,cAAcD,SAkBpDnK,QACIkJ,MAAMmB,QACFlJ,KAAKyG,WAAWpI,QAAQ2B,KAAKmJ,cAActB,yBAAAuB,oBAAoBpJ,OAUhEnB,oBACHkJ,MAAMsB,oBAA8C,kBAAlBrJ,MAAKsJ,UAA2BtJ,KAAKsJ,WAIpEzK,uBACHkJ,MAAMwB,uBAAkD,kBAAnBvJ,MAAKwJ,WAA4BxJ,KAAKwJ,YAIxE3K,kBACHkJ,MAAM0B,kBAA2C,kBAAjBzJ,MAAK0J,SAA0B1J,KAAK0J,UAIjE7K,yBAAyB8K,UAAmBC,SAAeC,UAC9D9B,MAAM+B,yBAAyBH,UAAWC,SAAUC,UAA4C,kBAA1B7J,MAAK+J,kBAAmC/J,KAAK+J,iBAAiBJ,UAAWC,SAAUC,UAI7JhL,UAAUmL,QACN,MAAOhN,QAAOiN,OAAOjK,QAASgK,QAalCnL,cAAcqL,YACV,IAAK,KAAMrN,QAAQG,QAAOgK,KAAKkD,YAAa,CACxC,KAAM1M,UAAWwC,KAAKmK,iBAAiBtN,KACnCW,YAAUwC,KAAKxC,UAAY0M,WAAWrN,QAKlDgC,mBAEI,MAAO7B,QAAO+C,oBAAoBC,MAItCnB,iBAAiBhC,MAEb,GAAoB,gBAATA,OAAqD,KAA/BA,KAAOA,KAAKgJ,QAAQxH,OAArD,CAGA,GAAIxB,OAAQmD,MAAM,MAAOnD,KAGzB,MAAMuN,YAAavN,KAAKmG,QAAQ,UAAW,IAAII,aAG/C,IAAIgH,aAAcpK,MAAKiI,eAAgB,MAAOjI,MAAKiI,eAAemC,WAG/CpN,QAAOgK,KAAKhH,KAG/B,IAAI,SAASqK,KAAKxN,MAAO,CACrB,KAAMW,UAAWR,OAAOgK,KAAKhH,MAAMsK,KAAK,CAACzN,KAAM0N,QAAU1N,KAAKuG,gBAAkBgH,WAChF,IAAI5M,SAAU,MAAQwC,MAAKiI,eAAemC,YAAc5M,SAI5D,MAAQwC,MAAKiI,eAAemC,YAAclE,SA5KhC4B,aAAAU,YAqGdvB,YADCW,aAAAzK,WAAWqN,IVuuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,wBACXA,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,oBAAqB,MUpuB5CwJ,YADCW,aAAAzK,WAAWqN,IVwuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,wBACXA,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,uBAAwB,MUruB/CwJ,YADCW,aAAAzK,WAAWqN,IVyuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,wBACXA,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,kBAAmB,MUtuB1CwJ,YADCW,aAAAzK,WAAWqN,IV0uBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,qBAAsBrD,OAAQnH,OAAQA,SACjDwK,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,2BAA4B,MUvuBnDwJ,YADCW,aAAAzK,WAAWqN,IV2uBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,qBAAsBxK,SACjCwK,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,SAAU,MU/tBjCwJ,YADCW,aAAAzK,WAAWqN,IVmuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,qBAAsBxK,SACjCwK,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,gBAAiB,MU7tBxCwJ,YADCW,aAAAzK,WAAWqN,IViuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,wBACXA,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,mBAAoB,MU7tB3CwJ,YADCW,aAAAzK,WAAWqN,IViuBZhD,WAAW,cAAeiD,UAC1BjD,WAAW,qBAAsBrD,SACjCqD,WAAW,oBAAqB,SACjCM,aAAarK,UAAW,mBAAoB,MU13B/CrB,QAAA0L,0BAmLA,SAAiBA,cACb,QAAAO,eAA8B9K,QAC1B,MAAyB,kBAAXA,SAAyBA,OAAOoI,IAA2B,gBAAdpI,QAAOoI,GADtDmC,aAAAO,cAAaA,eADhBP,aAAA1L,QAAA0L,eAAA1L,QAAA0L,kBV+sBjB9K,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IUzsBtDP,QAAAoI,QAAesD,cV+sBR,SAASzL,OAAQD,QAASH,qBAEjC,YWh5BA,MAAAyO,KAAAzO,oBAAA,GACA0O,WAAA1O,oBAAA,SAEA2O,eAYI/L,YAAYgM,UAAsB7B,UAC9BhJ,KAAKgJ,SAA+B,kBAAbA,UAA0BA,WAAaA,SAZ3DnK,cAAcgM,UAAkH7B,UACnI,MAAO,IAAI4B,eAAcC,UAAW7B,UAGjC9K,2BAA6B,MAAOwM,KAAIxM,cACxC2G,6BAA+B,MAAO6F,KAAI7F,gBAC1CE,4BAA8B,MAAO2F,KAAI3F,gBAPpD3I,QAAAwO,4BAkBA,SAAiBA,eAEAA,cAAAE,uBAAyBH,WAAAvG,8BAEtC,IAAiB2G,kBAAjB,SAAiBA,iBACAA,gBAAArM,QAAUkM,cAAcE,uBACxBC,gBAAA1J,OAASsJ,WAAAtH,+BAFT0H,gBAAAH,cAAAG,kBAAAH,cAAAG,sBAJJH,cAAAxO,QAAAwO,gBAAAxO,QAAAwO,mBXm5BjB5N,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IWz4BtDP,QAAAoI,QAAeoG,eX+4BR,SAASvO,OAAQD,QAASH,sBY36BjC,SAAA4B,UACA,GAAAC,UAAA,QACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAGA,WAEA,YAEA,SAAA+O,wBAAA1H,QAAA2H,UAAAC,YAGA5H,gBAAA6H,aAAA7H,OACA,IAAA8H,SAAA,SAAAC,GACA/H,QAAA4H,YACA5H,QAAA4H,YAAAG,IAAAC,QAEAhG,QAAAiG,KAAA,oBAAAL,WAAA,iBAGA,OAAAE,SAGA1M,QAAA8M,eAAA9M,QAAAgB,MAAA+L,cAAA,SAAAC,YAEA,YAAAF,uBAAAE,YAEA7M,8BAAAuB,KAAA6K,UAAAC,WAAA5H,SACAA,iBAAAlD,IACA,IAAAgL,SAAAJ,uBAAA1H,QAAA2H,UAAAC,WAEA,OADAlL,MAAA2L,wBAAAvL,KAAA6K,UAAAG,SACAA,QAGAvM,wBAAAuB,KAAA6K,UAAAG,SACAhL,KAAAiC,iBAAA4I,UAAAG,SAGAvM,6BAAAuB,KAAA6K,UAAAG,SACAhL,KAAA2B,oBAAAkJ,UAAAG,iBZ67BO,SAAS/O,OAAQD,UangCxB,SAAAyB,UACA,GAAAC,UAAA,IACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAKL,WAIA,QAAA+N,YAAAC,QAAAC,eACA,MAAAD,SAAA7I,QAAA+I,WAAA,SAAAtP,EAAAuP,IAAAC,IAAAC,MACA,MAAAF,KAAA,IACAG,QAAAF,IAAAjJ,QAAA,YAAA8I,eACA,IAAAI,OAMA,QAAAE,cAAAtG,QAAAgG,eACA,OAAAjP,QAAAwP,WAEA,OAAAC,GAAAC,GAAA7E,EADA8E,GAAAH,UAAAxP,MACAP,EAAA,EAAAC,EAAAiQ,GAAAnO,OAA4C/B,EAAAC,IAAA+P,EAAAE,GAAAlQ,IAAoBA,IAChE,MAAAO,MAAAiJ,QAAA2G,YAAA5P,OACA0P,GAAAzG,QAAAW,WAAA6F,GACA5E,EAAA6E,OAAA5P,MACA+K,KAAAgF,OAAAC,YAAA,IACAJ,GAAA5P,MAAA,UAAA2P,EACAV,WAAAlE,EAAAoE,eACAK,QAAAzE,EAAAoE,iBAOA,QAAAK,SAAAF,IAAAH,eAEA,GAAAG,KAAAW,QAAAvC,KAAA4B,KACA,MAAAA,IAEA,IAAAY,UAAAC,eAAAhB,cAEA,OADAe,UAAAvL,KAAA2K,IACAY,SAAAvL,MAAA2K,IAKA,QAAAc,YAAAd,IAAAe,SAOA,MANAC,WACAA,QAAApP,SAAAqP,eAAAC,mBAAA,QACAC,YAAAH,QAAA/O,cAAA,QACA+O,QAAAlP,KAAAO,YAAA8O,cAEAA,YAAA9L,KAAA0L,QACAb,QAAAF,IAAAgB,SAGA,QAAAH,gBAAAhB,eACA,MAAAA,eAAAuB,gBACAvB,cAAAuB,cAAAvB,cAAA5N,cAAA,MAdA,GAAA+O,SACAG,YAgBArB,WAAA,sBACAM,WACAiB,KAAA,4BACAC,MAAA,WAEAX,QAAA,0BACAD,WAAA,WAGAjO,SAAA8O,YACA5B,sBACAQ,0BACAW,2BbkhCO,SAAS1Q,OAAQD,QAASH,sBcznCjC,SAAA4B,UACA,GAAAC,UAAA,YACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAEAA,oBAAA,IAEAA,oBAAA,IAGA,WAEA,YAsGA,SAAAwR,cAAAC,KAAA9M,IAAA+M,IAAAC,MACAA,KAAAC,KACAjN,IAAAgN,KAAAC,IAAAH,KAAAI,2BAAAH,IAAAC,OAKA,QAAAG,oBAAAL,KAAAC,IAAAC,KAAAI,MACA,GAAAJ,KAAAK,QAAAL,KAAAK,OAAA5P,OAEA,OAAAgN,GADAjL,KAAAsN,KAAAI,2BAAAH,IAAAC,MACAM,EAAA,EAAAC,GAAAP,KAAAK,OAAsCC,EAAAC,GAAA9P,SAAAgN,EAAA8C,GAAAD,IAA4BA,IAClER,KAAAU,8BAAAhO,KAAAiL,EAAAxO,KAAAwO,EAAA1O,MAAAqR,MAMA,QAAAK,sBAAAX,KAAAC,IAAAC,MACA,GAAAA,KAAAU,gBAAA,CACA,GAAAlO,MAAAsN,KAAAI,2BAAAH,IAAAC,KACAxN,MAAAmO,SAAAX,KAAAU,iBAIA5P,QAAA8P,cAAA9P,QAAAgB,MAAA+L,cAAA,SAAAC,YAEA,KAAAlL,OAAA9B,QAAA+P,YAAA/P,QAAA8M,eAAAE,YACA,aAAA8C,sBAAAhO,OAEA3B,cACAkJ,QACA/H,KAAA0O,EAAA,KAGA7P,eAAAmK,UAEAA,oBAAAnC,SACApI,OAAAmI,yCAAAW,UACAX,oBAAAW,SAAAyB,SAEA,IAAA2F,OAAA3O,KAAA4O,0BAAA5F,UACA2E,IAAA9P,SAAAgR,WAAA7F,SAAAuF,UAAAvF,SAAAnC,SAAA,EAEA8G,KAAAmB,oBAAAH,MAAAI,mBACA/O,KAAA0O,IACA,QAAAd,MAAAtR,EAAA,EAAAC,EAAAoS,MAAAtQ,OAA2C/B,EAAAC,IAAAqR,KAAAe,MAAArS,IAA0BA,IACrEmR,aAAAzN,UAAA0O,EAAAf,IAAAC,MACAS,qBAAArO,KAAA2N,IAAAC,MACAG,mBAAA/N,KAAA2N,IAAAC,KAAA5N,KAEA,OAAA2N,ad2oCO,SAAStR,OAAQD,QAASH,sBe70CjC,SAAA4B,UACA,GAAAC,UAAA,IACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL5B,oBAAA,Kfy1CO,SAASI,OAAQD,QAASH,qBAEjC,YAEA,IAAIgL,YAAcjH,MAAQA,KAAKiH,YAAe,SAAUC,WAAYvH,OAAQwH,IAAKC,MAC7E,GAA2HxK,GAAvHF,EAAIqH,UAAU1F,OAAQgJ,EAAI3K,EAAI,EAAIiD,OAAkB,OAATyH,KAAgBA,KAAOpK,OAAOmD,yBAAyBR,OAAQwH,KAAOC,IACrH,IAAuB,gBAAZE,UAAoD,kBAArBA,SAAQC,SAAyBF,EAAIC,QAAQC,SAASL,WAAYvH,OAAQwH,IAAKC,UACpH,KAAK,GAAI9K,GAAI4K,WAAW7I,OAAS,EAAG/B,GAAK,EAAGA,KAASM,EAAIsK,WAAW5K,MAAI+K,GAAK3K,EAAI,EAAIE,EAAEyK,GAAK3K,EAAI,EAAIE,EAAE+C,OAAQwH,IAAKE,GAAKzK,EAAE+C,OAAQwH,OAASE,EAChJ,OAAO3K,GAAI,GAAK2K,GAAKrK,OAAOC,eAAe0C,OAAQwH,IAAKE,GAAIA,EgBp4ChE,MAAA2H,oBAAA/S,oBAAA,GAGA,IAAqBgT,YAAUC,kBAA/BD,mBAAwCD,oBAAAlH,aADxCjJ,chBu4CQkJ,SAAShE,WgBl2CN/D,KAAAmP,QAAoBnP,KAAKkI,YAAoBiH,SAAYnP,KAAKkI,YAAoBiH,SAAW,GAAK,EAhClGlG,2BACH,MAAO+F,oBAAApE,cAAchC,OAAOsG,aAAY,CAACR,EAAqBM,mBAAAjE,gBAAgBrM,UAC1EsQ,mBAAA9Q,cAAA,YAAUkR,MAAM,QAAQvB,GAAG,wCACvBmB,mBAAA9Q,cAAA,MAAI2P,GAAIa,MAAOW,QAASX,iBAAmB1O,KAAanD,KhBs4CxD,IgBt4C+D6R,YAC/DM,mBAAA9Q,cAAA,WAAK8Q,mBAAA9Q,cAAA,eAAUwQ,cAKpB7P,cACH,KAAMyQ,WAAYtP,KAAKnD,KAAMyL,QAAUtI,KAAK2F,GAAI4J,UAAY1R,SAASK,cAAc,MACnFqR,WAAUjR,YAAY0Q,mBAAA9Q,cAAA,OAAKsR,MAAM,sFAAoF,gEACrHD,UAAUpR,UAAYoR,UAAUpR,cAAgBmK,2DAA2DA,iBAAiBA,gCAAgCA,UAC5J,MAAME,WACFiH,SAAUF,UAAUG,qBAAqBpH,SAAS,GAClDqH,WAAYX,mBAAA9Q,cAAC8B,MAAK0F,uDAAwD4J,mBAAmBA,eAC7FtH,QAAShL,OAAOiN,OAAOpM,SAASK,cAAcoK,UAAY5C,uEAAwE4C,cAClIsH,aAAc,GAAI5P,OAAQiK,QAASvE,mDAAoD4J,gBAG3FhK,SAAQuK,QAAQP,qBACZQ,sBAAuB9P,KAAM+P,oBAAqB/P,KAAKvC,UACvDuS,sBAAuBvR,OAAOiK,eAAetL,IAAIkL,SACjD2H,aAAczH,UAGlB,KAAK,KAAMrB,OAAOnK,QAAOgK,KAAKwB,UAAeA,SAASrB,cAAgBf,cAAamJ,UAAUjR,YAAYkK,SAASrB,KAElHtJ,UAASW,KAAKF,YAAYiR,WAMvB1Q,WACHyG,QAAQC,OAAOvF,KAAKkI,YAAYrL,mBAAoBmD,MAGjDnB,eACHyG,QAAQC,OAAOvF,KAAKkI,YAAYrL,qBAAuBkH,oBAAW/D,KAAMA,MAAQA,OAzCtEiP,YAAAE,QAAU,EAFPF,WAAUC,aAAAjI,YAD9B+H,mBAAAkB,eACoBjB,YhBk7CrBjS,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IACtDP,QAAQoI,QgBn7CayK,WAgDrBA,WAAW5E,MhBq4CX,IAAI6E,eAKG,SAAS7S,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IiBl8CpE0G,SAAApI,oBAAA,IAEAoI,SAAApI,oBAAA,GAEA,MAAAkU,cAAAlU,oBAAA,EAESG,SAAA+T,yBADT,MAAAC,gBAAAnU,oBAAA,EACuBG,SAAAgU,8BjBo8CvBpT,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IiBl8CtDP,QAAAoI,QAAe2L,cjBw8CR,SAAS9T,OAAQD,QAASH,qBAEjC,YkB/8CA,SAAAiU,eAA8BlM,UAC1B,GAAIsE,SAA8B,gBAAbtE,UAAwBA,SAAWkC,MACxD,OAAwB,kBAAblC,UACEkE,aAA0BgI,cAAcG,gBAAgB/H,QAASJ,iBAD1CgI,eAAcG,gBAAgB/H,QAAU4H,cAAcI,WAAWtM,UAAWA,UAFpH5H,QAAA8T,4BAMA,SAAiBA,eACb,QAAAI,YAA2BpI,aAEvB,GADiC,gBAAtBA,aAAgB,IAAkBA,YAAgB,GAAErC,OAAOxH,QAAQ6J,YAAgB,GAAErC,OAChE,gBAArBqC,aAAYrL,MAAqBqL,YAAYrL,KAAKgJ,OAAOxH,OAAQ,MAAO6J,aAAYrL,KAAKgJ,OAAO7C,QAAQ,yBAA0B,SAASA,QAAQ,kBAAmB,SAASI,aAC1L,MAAM,IAAIkD,sCAAqC4B,YAAYrL,sEAE/D,QAAAwT,iBAAgC/H,QAASJ,aACrC,GAAIzJ,OAAOiK,eAAetL,IAAIkL,SAAU,KAAM,IAAIhC,8DAA6DgC,6BAC/G7J,QAAOiK,eAAeE,OAAON,QAASJ,aACtC5C,QAAQuK,KAAK,mCAAqCvH,gBAASJ,0BAR/CgI,cAAAI,WAAUA,WAKVJ,cAAAG,gBAAeA,iBANlBH,cAAA9T,QAAA8T,gBAAA9T,QAAA8T,mBlBo+CjBlT,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IkBr9CtDP,QAAAoI,QAAe0L,elB29CR,SAAS7T,OAAQD,QAASH,qBAEjC,YmBj/CA,SAAAkB,YAA2BR,OACvB,MAAO,CAACgD,OAAanC,YACjB,KAAM+S,YAAavT,OAAOmD,yBAAyBR,OAAQnC,aAEvD+S,YAAWpT,YAAcR,OAAOK,OAAOC,eAAe0C,OAAQnC,SAAQR,OAAAiN,UAAOsG,YAAYpT,WAAaR,QAAUA,UAJ5HP,QAAAe,sBASA,SAAiBA,YACAA,WAAAqN,IAAMrN,YAAW,GACjBA,WAAAqT,GAAKrT,YAAW,IAFhBA,WAAAf,QAAAe,aAAAf,QAAAe,gBnB4/CjBH,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,ImBv/CtDP,QAAAoI,QAAerH,YnB6/CR,SAASd,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IoBphDpE0G,SAAApI,oBAAA,GAGA,MAAAwU,iBAAAxU,oBAAA;AAEeG,QAAAiM,cAAAoI,gBAAAjM,QAAA6D,cpBohDfrL,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IoBlhDtDP,QAAAoI,QAAeiM,gBAAAjM,SpBwhDR,SAASnI,OAAQD,QAASH,qBAEjC,YqBjiDA,SAAAmN,qBAAoCxJ,QAChC,KAAM6G,YAAa7G,SAAYA,iBAAkB8Q,eAAgB9Q,QAAYA,iBAAkBwG,cAAexG,OAAO6G,WACrH,OAAOA,YAAa9C,MAAMgN,KAAKlK,YAAYV,OAAO,CAACxI,OAAQoM,aAAepM,OAAOoM,UAAU9M,MAAQ8M,UAAUhN,MAAOY,YAAe2I,OAFvI9J,QAAAgN,yCrB4iDO,SAAS/M,OAAQD,QAASH,qBsB1iDjC,GAAIwC,OAAQ,CACR,GAAImS,MAAQnS,OAAemS,KAAQnS,OAAemS,SAC9ChS,QAAUgS,KAAKhS,QAAUgS,KAAKhS,WAClCA,SAAQiS,eAAiB,EAACjT,EAAGb,IAAMa,GAInC3B,oBAAQ,MtBmjDL,SAASI,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IuBjkDpE0G,SAAApI,oBAAA,IACAoI,SAAApI,oBAAA,IACAoI,SAAApI,oBAAA,KACAoI,SAAApI,oBAAA,MvBwkDO,SAASI,OAAQD,QAASH,qBAEjC,YAEA,SAASoI,UAAS5H,GACd,IAAK,GAAIkB,KAAKlB,GAAQL,QAAQsB,eAAeC,KAAIvB,QAAQuB,GAAKlB,EAAEkB,IwBhlDpE0G,SAAApI,oBAAA,GAEA,MAAA6U,kBAAA7U,oBAAA,EAGaG,SAAA2O,gBAAkB+F,iBAAAtM,QAAcuG,gBAE9B3O,QAAA0O,uBAAAgG,iBAAAtM,QAAAsG,uBxB+kDf9N,OAAOC,eAAeb,QAAS,cAAgBO,OAAO,IwB7kDtDP,QAAAoI,QAAesM,iBAAAtM,SxBmlDR,SAASnI,OAAQD,QAASH,sByBzlDjC,SAAA4B,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,KzBmmDO,SAASI,OAAQD,QAASH,sB0BloDjC,SAAA4B,UACA,GAAAC,UAAA,UACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAEAA,oBAAA,GAGA,WAEA,YAEA,IAAA8U,SAAArS,QAAA8D,OAEA9D,SAAAsS,WAAAtS,QAAAgB,MAAA+L,cAAA,SAAAC,iBAKAsF,mBAAAtF,YAEA7M,cACAkJ,QACA/H,KAAAiR,eAAA,EAYApS,iBAAA8K,UAAAhN,OACAqD,KAAAkR,aAAAvH,YACA3J,KAAAmR,sBAAAnR,KAAArD,MAAAgN,WAeA9K,qBAAA8K,UAAAhN,MAAAyU,MAEA,IAAApR,KAAAiR,cAAA,CACA,GAAAzT,UAAAuT,QAAAlO,gBAAA8G,UACA3J,MAAAxC,UAAAwC,KAAAqR,sBAAA1U,MAAAyU,OAYAvS,qBAAArB,SAAAmM,UAAAhN,OACAqD,KAAAiR,eAAA,EACAtU,MAAAoH,UAAA1F,OAAA,EAAA2B,KAAAxC,UAAAb,MACAqD,KAAAmR,sBAAAnR,KAAArD,MACAgN,WAAAoH,QAAA7N,gBAAA1F,WACAwC,KAAAiR,eAAA,EAgBApS,sBAAAuB,KAAAzD,MAAAgN,WACA,GAAA2H,KAAAtR,KAAAuR,oBAAA5U,MACAuJ,UAAAoL,IACAlR,KAAAoR,gBAAA7H,WAEAvJ,KAAAyB,aAAA8H,UAAA2H,KAeAzS,oBAAAlC,OAEA,aAAAA,QACA,cACA,MAAAA,OAAA,GAAAuJ,MAEA,cACA,GAAAvJ,gBAAA8U,MACA,MAAA9U,OAAA+U,UACa,IAAA/U,MACb,IACA,MAAAgV,MAAAC,UAAAjV,OACe,MAAAkV,GACf,SAIA,QACA,aAAAlV,YAAA+U,WAAAxL,QAsBArH,sBAAAlC,MAAAyU,MAIA,GAAAU,SACA,QAAAV,MACA,IAAAW,QACAD,SAAAC,OAAApV,MACA,MAEA,KAAAqV,SACAF,SAAA,OAAAnV,KACA,MAEA,KAAAK,QACA,IACA8U,SAAAH,KAAAM,MAAAtV,OACa,MAAAkV,IAGb,KAEA,KAAAlO,OACA,IACAmO,SAAAH,KAAAM,MAAAtV,OACa,MAAAkV,GACbC,SAAA,KACAxM,QAAAiG,KAAA,sDAEA,KAEA,KAAAkG,MACAK,SAAA,GAAAL,MAAA9U,MACA,MAEA,KAAAwH,QACA,QACA2N,SAAAnV,MAIA,MAAAmV,WAKA,MAAAd,kB1BipDO,SAAS3U,OAAQD,QAASH,sB2Bl3DjC,SAAA4B,UACA,GAAAC,UAAA,sBACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,IAEAA,oBAAA,GAEAA,oBAAA,IAEAA,oBAAA,IAEAA,oBAAA,IAEAA,oBAAA,IAEAA,oBAAA,IAGA,WAEA,YAMA,SAAAiW,mBAAAC,eAAAC,OACA,OAAAzU,KAAAyU,OAAA,CACA,GAAArV,GAAAqV,MAAAzU,EACA,mBAAAZ,KACAA,GAAaqU,KAAArU,IAEboV,eAAAxU,GAAAZ,EAEA,MAAAoV,gBAZA,GAAApB,SAAArS,QAAA8D,OAeA9D,SAAA2T,aAAA3T,QAAAgB,MAAA+L,cAAA,SAAAhL,MAEA,KAAAD,OAAA9B,QAAA4T,gBAAA7R,WAKA8R,uBAAA/R,OAOAgS,wBAIA,MAHAxS,MAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,cAAA7Q,SACAA,KAAAyS,YAAAzS,KAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,SAAA7Q,YAAA0S,WAEA1S,KAAAyS,YAQAE,kCACA,IAAA3S,KAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,wBAAA7Q,OAAA,CAGAA,KAAA4S,sBAAAV,qBAA2DlS,KAAAwS,WAAAtI,WAC3D,IAAA2I,WAAA7V,OAAA8V,eAAA9S,KAAAvC,WAAAyK,WACA2K,WAAApV,oBAAA8U,kBACAvS,KAAA4S,sBAAAV,kBACAlV,OAAAqE,OAAAwR,UAAAF,sBACA3S,KAAA4S,wBAGA,MAAA5S,MAAA4S,sBAGAG,wCACA,IAAA/S,KAAAtC,eAAA,gCACAsC,KAAAgT,4BAAA,IACA,QAAArV,KAAAqC,MAAA2S,qBAAA,CACA,GAAA9C,MAAA7P,KAAA2S,qBAAAhV,EACA,UAAAkS,QACA7P,KAAAgT,4BACAhT,KAAAgT,gCACAhT,KAAAgT,4BAAArV,GAAAkS,OAIA,MAAA7P,MAAAgT,4BAKAjK,gCAMA,MALA/I,MAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,sBAAA7Q,SAEAA,KAAAiT,oBAAAjT,KAAAkT,2BACAlT,KAAA2S,0BAEA3S,KAAAiT,oBAGApU,kCAAAqL,WAAAiJ,MACA,OAAAC,QAAAlJ,YACAiJ,KAAAE,KAAA3U,QAAA8D,QAAAU,gBAAAkQ,MAEA,OAAAD,MAGAG,uBACA,MAAAtT,MAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,aAAA7Q,OAGAsT,qBAAA3W,OACAqD,KAAAuT,WAAA5W,MASAkC,kBACA,GAAA2U,OAAAxT,KAAAvC,SACA,KAAAuC,KAAAsT,UAAA,CAEA,GAAAG,YAAAzW,OAAA8V,eAAAU,OACAX,UAAAY,uBAAAvL,WACA2K,WAAApV,oBAAA8U,iBACAM,UAAAa,WAEA1T,KAAAsT,WAAA,EACAtT,KAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,KAAA7Q,aAAA2F,IACAjH,QAAAiV,UAAAC,SAAAJ,MAEA,IAAAd,QAAA1S,KAAAwS,UACAE,SACA1S,KAAA6T,gBAAAnB,QAEA1S,KAAAgJ,UACAhJ,KAAA8T,kBAAA9T,KAAAgJ,SAAA+K,WAAA,KAKAlV,uBAAA6T,QACA,GAAAA,OAAAxI,WAEA,OAAAvM,KAAA+U,QAAAxI,WACAlK,KAAAvC,UAAAuW,0BAAArW,EAAA+U,OAAAxI,WAAAvM,GAGA,IAAA+U,OAAAuB,UACA,OAAA3X,GAAA,EAAuBA,EAAAoW,OAAAuB,UAAA5V,OAA6B/B,IACpD0D,KAAAvC,UAAAyW,sBAAAxB,OAAAuB,UAAA3X,IAKAuC,sBACA,MAAAH,SAAAyV,UAAAC,OAAApU,KAAA2F,GAAA,YAGAqD,sBAQA,MAPAhJ,MAAAtC,eAAAkT,KAAAhS,QAAAiS,eAAA,YAAA7Q,SACAA,KAAAqU,UAAArU,KAAAsU,gBAIAtX,OAAA8V,eAAA9S,KAAAvC,WAAAyK,YAAAc,UAEAhJ,KAAAqU,UAGAxV,yBAAAmK,UAEA,GAAA6C,SAAAnN,QAAA6V,YAAAC,eAAAxL,SACA,IAAA6C,QAAA,CACA,GAAA2D,OAAA3R,SAAAK,cAAA,QACAsR,OAAAiF,YAAA5I,QACA7C,SAAAnC,QAAA6N,aAAAlF,MAAAxG,SAAAnC,QAAA8N,YAEAlW,OAAAmW,UACAnW,OAAAmW,SAAAC,gBAAA7L,SAAAhJ,KAAA2F,GAAA3F,KAAA8U,QAEA,IAAAtB,OAAAxT,KAAAvC,SACAuC,MAAAvC,UAAAsX,cAAA/L,UACAwK,MAAAa,UAAArL,SAGAnK,cACAkJ,QAGArJ,QAAAiV,UAAAqB,gBAEAC,UAAAC,aAAAlV,MAGAnB,wBACAmB,KAAAkI,YAAAoL,WACAtT,KAAAkI,YAAAwL,WAEA3L,MAAAoN,uBAEA,IAAAC,IAAApV,KAAAkI,YAAA6K,0BACA,IAAAqC,GAGA,OAAAzX,KAAAyX,IAAA,CACA,GAAAvF,MAAAuF,GAAAzX,EACA,KAAAqC,KAAAqV,mBAAA1X,GAAA,CACA,GAAAhB,OAAA,kBAAAkT,MAAAlT,MACAkT,KAAAlT,MAAAH,KAAAwD,MACA6P,KAAAlT,KACAqD,MAAAsV,mBAAA3X,GACAqC,KAAAuV,aAAA5X,EAAAhB,OAEAqD,KAAArC,GAAAhB,QAgEAkC,0BAAAhC,KAAAgT,MAEAA,KAAA2F,WACA3F,KAAA4F,UAAA,GAOA5F,KAAA2F,WAAAxV,KAAAsV,mBAAAzY,OACAmD,KAAA0V,wBAAA7Y,KAAAgT,KAAA2F,UAEA3F,KAAA4F,WAAAzV,KAAAsV,mBAAAzY,OACAmD,KAAA2V,wBAAA9Y,MAAAgT,KAAA2F,UAEA3F,KAAA+F,qBAAA5V,KAAA6V,kBAAAhZ,OACAmD,KAAA8V,yBAAAjZ,MAEAgT,KAAAkG,SAAA/V,KAAAgW,iBAAAnZ,OACAmD,KAAAiW,yBAAApZ,MAGAgT,KAAAqG,UACAlW,KAAAmW,wBAAAtZ,KAAAgT,KAAAqG,UAKArX,oBACAmB,KAAAoW,eACAnB,UAAAoB,WAIArW,KAAAsW,mBAIAzX,wBAEAA,QACAkJ,MAAAmB,QACAlJ,KAAAqU,WACAY,UAAAsB,aAAAvW,MACAA,KAAAwW,KAAAxW,KAAAyW,eAAAzW,KAAAqU,WACArU,KAAAsW,mBACAtW,KAAAwW,KAAAxW,KAAA0W,WAAA1W,KAAAwW,MACAvB,UAAA0B,WAAA3W,QAEAA,KAAAwW,KAAAxW,KACAA,KAAAsW,oBAgBAzX,WAAA8O,KACA,IAAA3N,KAAA4W,aASA,SAAAtQ,OAAA,2KARA,IAAAqH,IAKA,MAJA3N,MAAA6W,YACA7W,KAAA4W,cAAiCE,KAAA,SAEjC9W,KAAA6W,WAAAvY,YAAAqP,KACA3N,KAAA6W,WAYAhY,yBAAAhC,KAAAka,IAAApa,OACA,GAAAoa,MAAApa,MAAA,CACA,GAAAa,UAAAuT,QAAAlO,gBAAAhG,MACAuU,KAAApR,KAAAkI,YAAAyK,qBAAAnV,UAAA4T,IACApR,MAAAsV,mBAAA9X,WACAwC,KAAAgX,qBAAAna,KAAAF,MAAAyU,OAaAvS,aAAAqL,YACAzL,OAAAmW,UACAA,SAAAqC,WAAAjX,KAAAkK,YAaArL,WAAAoN,KACA,GAAA5P,QAAAqC,QAAAyV,UAAAC,OAAApU,KAAAkI,YAAAvC,IACA6Q,KAAA,EAKA,OAJAna,UACAma,KAAA9X,QAAA8O,WAAAT,WACA1Q,OAAA6a,UAAA7a,OAAAyP,cAAAqL,UAEAzY,QAAA8O,WAAAT,WAAAd,IAAAuK,OAKA,MAAAjE,iBAGA,IAAA0C,YAEAmC,SAEAvY,UACA,OAAAmB,KAAAoX,MAAA/Y,QAGAQ,aAAA6O,MACA,GAAA1N,KAAAoX,MAAA/Y,OAAA,CACA,GAAA2P,MAAAhO,KAAAoX,MAAApX,KAAAoX,MAAA/Y,OAAA,EACA2P,MAAAqJ,eAAA3J,QAIA7O,aAAA6O,MACA1N,KAAAoX,MAAA/D,KAAA3F,OAGA7O,WAAA6O,MACA,GAAA4J,UAAAtX,KAAAoX,MAAA/Y,MACAiZ,WAAAtX,KAAAoX,MAAAE,SAAA,IAAA5J,MACA1N,KAAAoX,MAAAG,OAOA7Y,SAAAiV,WACAqB,cAAA,EACAwC,iBACAC,QAAA,SAAAha,WACA6H,QAAAC,IAAA,IAAA9H,UAAAkI,GAAA,kBAEAiO,SAAA,SAAAnW,WACAuC,KAAAwX,cAAAnE,KAAA5V,WACAiB,QAAA6G,KAAAvF,KAAAyX,QAAAha,YAEAia,kBAAA,WACA1X,KAAAwX,cAAAzQ,QAAA/G,KAAAyX,WAIA/Y,QAAAQ,QAAAR,QAAA2T,aAAAjM,aAEA1H,QAAA0X,aAAA,SAAAhE,OACA3T,OAAAmW,UACAA,SAAAwB,aAAAhE,Y3Bk4DO,SAAS/V,OAAQD,QAASH,sB4Bn3EjC,SAAA4B,UACA,GAAAC,UAAA,MACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAIA,WAEA,GAAAD,YACA2b,aACAC,WAAA,SAAA/J,IACA,MAAA7R,SAAA6R,KAAA8J,UAAA9J,GAAAzK,qBAkBA+Q,kBAAA/N,aAEA2C,gCAAqC,aAErClK,yBAAAhC,KAAAka,IAAApa,OACAoa,MAAApa,OACAqD,KAAA4T,WAIA/U,6BACAmB,KAAA2B,cAAA,UACA2D,QAAAiG,KAAA,2CAAAvL,KAAA6N,IAIAqJ,gBACA,GAAAA,WAAAlX,KAAA6X,aAAA7X,KAAA8X,aAAA,YAEA,IAAAZ,eAEA,IAAAzY,OAAAO,0BAAA+Y,WACA/Y,YAAAgZ,iBAAA,CACA,KAAAC,KAAAjZ,YAAAgZ,iBAAAhY,KACAkX,WAAAe,QAAA3W,KAAA,OAGAtB,MAAA8L,gBAAAjO,UAAAmC,KAAAmX,UACAD,UAAAlX,KAAAmX,QAIA,OADAnX,MAAA6X,YAAAX,UACAA,UAUArY,SAAAgP,IACAA,OAAA7N,KAAA6N,GACAA,KACA7N,KAAA6N,MAIA7R,QAAA6R,IAAA7N,KACA2X,UAAA9J,GAAAzK,eAAApD,KACAA,KAAAkY,8BAaArZ,OAAAgP,GAAAtN,UACA,GAAAsN,GAAA,CACA,GAAApR,GAAAmb,WAAA/J,GACA,OAAApR,IAAA8D,SACA9D,EAAAkF,cAAApB,UAEA9D,EAEA,aAKA0X,UAAA1W,UAAA,QAAAzB,QAEA0M,eAAAE,OAAA,aAAAuL,WAGAzV,QAAAyV,UAAA,GAAAA,e5Bi4EO,SAAS9X,OAAQD,QAASH,sB6B7gFjC,SAAA4B,UACA,GAAAC,UAAA,UACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAGA,WAEA,YA4BA,SAAAkc,mBAAAC,MAAA5a,UAEA,IAAA6a,iBAAA7a,UAAA,CACA,GAAAb,OAAAyb,MAAA5a,SACA0I,UAAAvJ,QACAyb,MAAAE,OAGAF,MAAAG,oBAAA/a,SAAAb,QAGAyb,MAAAI,YAEWJ,MAAA1a,eAAAkT,KAAAhS,QAAAiS,eAAA,cAAAuH,UACXA,MAAAI,YAAAxb,OAAAqE,OAAA+W,MAAAI,cAFAJ,MAAAI,eAIAJ,MAAAI,YAAAhb,UAAAb,SAvCA,KAAA0b,oBACA,IAAA7E,OAAApN,YAAA3I,SACA,MAAA+V,OAAA,CACA,GAAApB,OAAApV,OAAA+C,oBAAAyT,MACA,QAAAlX,GAAA,EAAiBA,EAAA8V,MAAA/T,OAAgB/B,IACjC+b,iBAAAjG,MAAA9V,KAAA,CAEAkX,OAAAxW,OAAA8V,eAAAU,OAsCA9U,QAAA+Z,kBAAA/Z,QAAAgB,MAAA+L,cAAA,SAAAC,YAEA,YAAA+M,0BAAA/M,YAEA7M,cACAkJ,QACA/H,KAAAmV,wBAWAtW,wBACAmB,KAAAsY,UACAtY,KAAA0Y,cAAA,EACA1Y,KAAA2Y,cAAA,KACA3Y,KAAA4Y,UAAA,KACA5Y,KAAA6Y,eAAA,EAwBAha,wBAAArB,SAAAiY,UACA0C,kBAAAnY,KAAAxC,UACAR,OAAAC,eAAA+C,KAAAxC,UACAJ,IAAA,WACA,MAAA4C,MAAAsY,QAAAtY,KAAAsY,OAAA9a,WAEAsD,IAAA2U,SAAA,aAAwC,SAAA9Y,OACxCqD,KAAAuV,aAAA/X,SAAAb,UAaAkC,aAAArB,SAAAb,OACAqD,KAAAuY,oBAAA/a,SAAAb,QACAqD,KAAA8Y,wBAcAja,oBAAArB,SAAAb,OACA,GAAAoa,KAAA/W,KAAAsY,OAAA9a,SACA,IAAAwC,KAAA+Y,sBAAAvb,SAAAb,MAAAoa,KAWA,MAVA/W,MAAA2Y,gBACA3Y,KAAA2Y,iBACA3Y,KAAA4Y,cAGApb,WAAAwC,MAAA4Y,YACA5Y,KAAA4Y,UAAApb,UAAAuZ,KAEA/W,KAAAsY,OAAA9a,UAAAb,MACAqD,KAAA2Y,cAAAnb,UAAAb,OACA,EAWAkC,mBAAAuU,MACA,MAAApT,MAAA2Y,eAAAvF,OAAApT,MAAA2Y,cASA9Z,wBACAmB,KAAA6Y,gBACA7Y,KAAA6Y,eAAA,EACAG,QAAA7M,UAAArD,UACA9I,KAAA6Y,gBACA7Y,KAAA6Y,eAAA,EACA7Y,KAAAsW,uBAaAzX,mBACA,GAAAoa,UAAAjZ,KAAA4Y,UACAM,aAAAlZ,KAAA2Y,aACA3Y,MAAA2Y,cAAA,KACA3Y,KAAA0Y,gBACA1Y,KAAAmZ,mBAAAnZ,KAAAsY,OAAAY,aAAAD,UACAjZ,KAAA0Y,gBAcA7Z,mBAAAua,aAAAF,aAAAD,WAsBApa,sBAAArB,SAAAb,MAAAoa,KACA,MAEAA,OAAApa,QAEAoa,WAAApa,uB7BgiFO,SAASN,OAAQD,QAASH,sB8B9yFjC,SAAA4B,UACA,GAAAC,UAAA,0BACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAEAA,oBAAA,IAEAA,oBAAA,IAEAA,oBAAA,IAEAA,oBAAA,GAEAA,oBAAA,IAGA,WAEA,YA0CA,SAAAod,oBAAAjB,MAAAhH,MACA,GAAAkI,SAAAlB,MAAAhH,KACA,IAAAkI,SAEK,IAAAlB,MAAA1a,eAAA0T,MAAA,CACLkI,QAAAlB,MAAAhH,MAAApU,OAAAqE,OAAA+W,MAAAhH,MACA,QAAAzT,KAAA2b,SAEAA,QAAA3b,GAAA2b,QAAA3b,GAAA4b,aALAD,SAAAlB,MAAAhH,QAQA,OAAAkI,SAeA,QAAAE,YAAA9L,KAAA4L,QAAAlH,MAAA6G,SAAAQ,UAAAC,UACA,GAAAJ,QAAA,CACA,GAAAK,KACA9L,GAAApO,UACA,QAAA2T,QAAAhB,OACAwH,sBAAAlM,KAAA4L,QAAAzL,GAAAuF,KAAAhB,MAAA6G,SAAAQ,UAAAC,YACAC,KAAA,EAGA,OAAAA,MAeA,QAAAC,uBAAAlM,KAAA4L,QAAA7Z,SAAA2T,KAAAhB,MAAA6G,SAAAQ,UAAAC,UACA,GAAAC,KAGAE,aAAAH,SAAAhb,QAAAob,KAAAtD,KAAApD,WACA2G,IAAAT,QAAAO,aACA,IAAAE,IACA,OAAAC,IAAA1d,EAAA,EAAAC,EAAAwd,IAAA1b,OAAqC/B,EAAAC,IAAAyd,GAAAD,IAAAzd,IAAsBA,IAC3D0d,GAAAnK,MAAAmK,GAAAnK,KAAAoK,UAAAxa,UACAia,WAAAQ,mBAAA9G,KAAA4G,GAAAG,WACAH,GAAAI,GAAA1M,KAAA0F,KAAAhB,MAAA6G,SAAAe,GAAAnK,KAAA4J,UAAAC,UACAM,GAAAnK,OACAmK,GAAAnK,KAAAoK,QAAAxa,UAEAka,KAAA,EAIA,OAAAA,KAqBA,QAAAO,oBAAAG,KAAAF,SACA,GAAAA,QAAA,CACA,GAAAG,aAAAH,QAAAtd,IACA,OAAAyd,cAAAD,MACAF,QAAAI,YAAA7b,QAAAob,KAAAU,WAAAF,YAAAD,OACAF,QAAAM,UAAA/b,QAAAob,KAAAY,aAAAJ,YAAAD,MAEA,SAiBA,QAAAM,mBAAAjN,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MACA,GAAAuK,IAAA1M,KAAAmC,KAAA3E,WACAkP,IACAA,GAAA5d,KAAAkR,UAAA4K,OAAA9a,UAAAyb,SAAAzb,WAEA8H,QAAAiG,KAAA,oBAAAsE,KAAA3E,WAAA,iBAmBA,QAAA0P,kBAAAlN,KAAA0E,MAAA6G,SAAAQ,UAAAC,UAEA,GAAAK,KAAArM,KAAAmN,eACA,IAAAd,KAAAL,SAAA,CACA,GAAAoB,UACAjN,GAAApO,UAEA,QAAA2T,QAAAhB,OACA2H,KAAAH,sBAAAlM,KAAAqM,IAAAlM,GAAAuF,KAAAhB,MAAA6G,SAAAQ,UAAAC,UACAoB,UAAA,EACSpB,UAAAqB,WAAArN,KAAA0F,KAAAhB,SACT0I,UAAA,EAIA,IAAA9M,KACA8M,YAAA9M,KAAAN,KAAAsN,aAAAhN,KAAAsI,kBACAtI,KAAAsI,oBAcA,QAAAyE,YAAArN,KAAA2M,KAAAjI,OACA,GAAAyH,cAAAnb,QAAAob,KAAAtD,KAAA6D,KACA,IAAAR,eAAAQ,KAAA,CACA,GAAApP,WAAAvM,QAAA8D,QAAAU,gBAAA2W,cAAA,UAEA,OADAoB,qBAAAvN,KAAAzC,UAAAmH,MAAAiI,aACA,GAeA,QAAAY,qBAAAvN,KAAAzC,UAAAtO,MAAA0d,MACA,GAAA/O,SACA3O,YACAue,eAAA,EAEAb,QACA/O,OAAA+O,WAEA3M,KAAApL,cAAA,GAAA6Y,aAAAlQ,WAAmDK,iBAgBnD,QAAA8P,iBAAA1N,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,KAAA4J,UAAAC,UACA,GAAAG,cAAAH,SAAAhb,QAAAob,KAAAtD,KAAAhZ,mBACA6c,KAAAR,cAAArc,kBAAA,KACAb,MAAA0d,KAAA3b,QAAAob,KAAA1c,IAAAsQ,KAAA2M,MAAA3M,KAAA4K,OAAA9a,SACA6c,OAAAnU,SAAAvJ,QACAA,MAAAyV,MAAA5U,WAEAyd,oBAAAvN,KAAAmC,KAAA5E,UAAAtO,MAAA0d,MAWA,QAAAgB,mBAAAjb,KAAAsN,KAAAmC,MACAzP,KAAAiC,iBAAAwN,KAAA3N,MAAA,SAAAmJ,GACAiQ,mBAAAjQ,EAAAqC,KAAAmC,KAAArS,SAAAqS,KAAAwK,KAAAxK,KAAA0L,UAoBA,QAAAD,oBAAAjQ,EAAAqC,KAAAlQ,SAAA6c,KAAAkB,QACA,GAAA5e,OACA6e,WAAAnQ,EAAAC,QAAAD,EAAAC,OAAA+O,IACAmB,aACAnB,KAAA3b,QAAAob,KAAA2B,UAAAje,SAAA6c,KAAAmB,YACA7e,MAAA0O,EAAAC,QAAAD,EAAAC,OAAA3O,OAEAA,MAAA0O,EAAA1L,OAAAnC,UAEAb,MAAA4e,QAAA5e,YACA+e,4BAAAhO,KAAA2M,KAAA1d,MAAA0O,GAWA,QAAAqQ,6BAAAhO,KAAA2M,KAAA1d,MAAAuF,OACA,GAAAoJ,QAAApJ,MAAAoJ,MACAA,gBAAA4P,cACAxN,KAAAiO,YAAAjO,KAAAiO,WAAAtB,OACA3M,KAAAkO,0BAAAvB,KAAA1d,MAAAqV,QAAA1G,OAAA+O,OAGA3M,KAAA5M,IAAAuZ,KAAA1d,OAgBA,QAAAkf,kBAAAnO,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MACA,GAAAlT,OAAA+Q,KAAA4K,OAAA9a,SACAkB,SAAAod,mBACAnf,MAAA+B,QAAAod,iBAAAnf,MAAAkT,KAAAkM,SAAA,YAAArO,OAEAA,KAAAsO,qBAAAxe,SAAAqS,KAAAkM,SAAApf,OAkBA,QAAAsf,oBAAAvO,KAAAwL,aAAAD,SAAAQ,UAAAC,UACA,GAAAwC,gBAAAxO,KAAAyO,gBACA,IAAAD,eAAA,CACA,GACAE,eADAC,WAAAnD,YAEA,MAAAM,WAAA9L,KAAAwO,eAAAG,WAAA5C,UAAAC,WACAlZ,MAAAyY,SAAAvL,KAAAkL,WACApY,MAAA0Y,aAAAxL,KAAAiL,eACAyD,cAAA5b,MAAA4b,kBAAiD1O,KAAAiL,eACjD0D,WAAA3O,KAAAiL,cACAjL,KAAAiL,cAAA,IAEA,OAAAyD,gBAkBA,QAAAE,mBAAA5O,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MACA,GAAA0M,QAAAC,gBAAA9O,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MACA4M,aAAA5M,KAAA6M,UACAhP,MAAAiP,mBAAAjP,KAAAiP,kBAAAF,cACA/O,KAAA6K,oBAAAkE,aAAAF,QAEA7O,KAAA+O,cAAAF,OAkBA,QAAAK,oBAAAlP,KAAAwL,aAAAkD,cAAA1C,UACA,GAAAmD,MACA,IAAAnD,WAAAmD,MAAAnP,KAAAoP,mBAAA,CACA,KAAAC,OAAArP,KAAAsP,UACAZ,gCACA,IAAA1a,KACA,QAAA4K,KAAAuQ,OAAA,CACA,GAAAI,GAAAJ,MAAAvQ,EACA,QAAA+N,QAAAnB,cACAxa,QAAAob,KAAAY,aAAApO,EAAA+N,OACA3Y,KAAAhD,QAAAob,KAAA2B,UAAAnP,EAAA2Q,EAAA5C,MACA0C,MAAArb,MAAAwX,aAAAxX,MAAA0a,cAAA1a,MAAAwX,aAAAmB,OACW3b,QAAAob,KAAAY,aAAAuC,EAAA5C,QACX3Y,KAAAhD,QAAAob,KAAA2B,UAAAwB,EAAA3Q,EAAA+N,MACA0C,MAAArb,MAAAwX,aAAAxX,MAAA0a,cAAA1a,MAAAwX,aAAAmB,QAKA,MAAA+B,eAkBA,QAAAc,kBAAA9E,MAAAxK,KAAArD,OACA,OAAAjO,GAAA,EAAiBA,EAAAsR,KAAAuP,MAAA9e,OAAqB/B,IAAA,CACtC,GAAA8gB,MAAAxP,KAAAuP,MAAA7gB,EACA8gB,MAAAC,UACAC,uBAAAlF,MAAAxK,KAAAwP,KAAA7S,OACO6S,KAAAG,UACP,cAAA3P,KAAA4P,MAAA,MAAA5P,KAAA/Q,KAAA,GACAyI,QAAAiG,KAAA,wBAAAqC,KAAA/Q,KACA,4DAEAub,MAAAqF,mBAAA/e,QAAAob,KAAAtD,KAAA4G,KAAAzgB,OAAA+gB,MAAAC,WACAvD,GAAAwD,iBACA/N,MACA2N,KAAA5P,KAAA4P,KACAjT,YACA1N,KAAA+Q,KAAA/Q,KACAghB,aAAAjQ,KAAAiQ,aACAlhB,MAAAygB,KAAAzgB,MACAmhB,WAAAlQ,KAAAkQ,WACAC,cAAAX,KAAAW,cACA7b,MAAAkb,KAAAlb,MACA8b,YAAAZ,KAAAY,YACAzC,OAAA6B,KAAA7B,YAkBA,QAAAqC,kBAAAlQ,KAAA2M,KAAAjI,MAAA6G,SAAApJ,KAAA4J,UAAAC,UACA,GAAA/c,OACAyD,KAAAsN,KAAAuQ,YAAApO,KAAAtF,MAGA,IAAAmP,UAAAW,KAAAhc,OAAAwR,KAAAlT,MAAA0B,QACA,YAAAwR,KAAA2N,OAAA3N,KAAAiO,YACA1d,KAAAuc,mBAAAvc,KAAAuc,kBAAA9M,KAAAhT,MAAA,CACA,GAAAF,OAAAyV,MAAAiI,KACAA,MAAA3b,QAAAob,KAAA2B,UAAA5L,KAAAlT,MAAAkT,KAAAhT,KAAAwd,MACAja,KAAAwb,0BAAAvB,KAAA1d,OAAA,IACA+Q,KAAA2J,eAAAjX,UAOAzD,OADA0d,MAAAxK,KAAAlT,MACA+B,QAAAob,KAAA1c,IAAAsQ,KAAAmC,KAAAlT,OAEA+c,UAAAhb,QAAAob,KAAAoE,OAAA7D,MACA3b,QAAAob,KAAA1c,IAAAsQ,KAAA2M,MAEA3M,KAAA4K,OAAA+B,MAIA8D,kBAAAzQ,KAAAmC,KAAAlT,OAaA,QAAAwhB,mBAAAzQ,KAAAmC,KAAAlT,OACA,GAAAyD,MAAAsN,KAAAuQ,YAAApO,KAAAtF,MAKA,IAJA5N,MAAAyhB,oBAAAhe,KAAAzD,MAAAkT,MACAnR,QAAAod,mBACAnf,MAAA+B,QAAAod,iBAAAnf,MAAAkT,KAAAhT,KAAAgT,KAAA2N,KAAApd,OAEA,aAAAyP,KAAA2N,KAEA9P,KAAAyD,sBAAA/Q,KAAAzD,MAAAkT,KAAAhT,UACK,CAEL,GAAAuW,MAAAvD,KAAAhT,IACAuD,MAAAuc,mBAAAvc,KAAAuc,kBAAAvJ,MACAhT,KAAAub,YAAAvb,KAAAub,WAAAvI,OACAhT,KAAAmY,oBAAAnF,KAAAzW,QACA+Q,KAAA2J,eAAAjX,MAIAsN,KAAA2Q,4BAAAje,KAAAgT,KAAAzW,QAeA,QAAAyhB,qBAAAhe,KAAAzD,MAAAkT,MAIA,GAHAA,KAAA0L,SACA5e,cAEAkT,KAAAiO,WAAA,CACA,GAAAQ,SAAAle,KAAAme,sBAAA1O,KAAAhT,KACAyhB,SAAAzO,KAAAkO,eAAAphB,MACAA,MAAA2hB,QAAAE,KAAA,IASA,MAPA,cAAA3O,KAAA2N,OAEA,gBAAA3N,KAAAhT,MACA,SAAAuD,KAAAqM,WAAA,SAAAoD,KAAAhT,QACAF,MAAAuJ,QAAAvJ,MAAA,GAAAA,OAGAA,MAcA,QAAA2gB,wBAAAlF,MAAAxK,KAAAwP,KAAA7S,OACAkU,mBAAArG,MAAAgF,KAAAC,UAAAK,MAAAC,UACAe,wBACAnU,YACAuT,WAAAlQ,KAAAkQ,WACAC,cAAAX,KAAAW,cACAP,KAAA5P,KAAA4P,KACA3gB,KAAA+Q,KAAA/Q,KACA0e,OAAA6B,KAAA7B,OACA6B,YACO,GAiBP,QAAAsB,wBAAAhR,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MACA,GAAA8O,KAAAnC,gBAAA9O,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,KACAsO,mBAAAzQ,KAAAmC,KAAA6M,WAAAiC,KAoBA,QAAAC,oBAAAjQ,OACA,IAAAA,MAAAkQ,WAAA,CACA,OAAAviB,GAAA,EAAmBA,EAAAqS,MAAAtQ,OAAgB/B,IAAA,CACnC,GAAAsR,MAAAe,MAAArS,EAEA,QAAA4R,GAAA,EAAqBA,EAAAN,KAAAkR,SAAAzgB,OAAwB6P,IAAA,CAC7C,GAAA+O,GAAArP,KAAAkR,SAAA5Q,EACA,QAAAzG,GAAA,EAAuBA,EAAAwV,EAAAE,MAAA9e,OAAkBoJ,IAAA,CACzC,GAAA9J,GAAAsf,EAAAE,MAAA1V,EACA9J,GAAA4f,UACA5f,EAAA0f,UAAA0B,YAAAphB,EAAAhB,OACAgB,EAAA0f,YACA1f,EAAAkc,aAAAnb,QAAAob,KAAAtD,KAAA7Y,EAAAhB,UAMA,GAAAiR,KAAAU,gBAAA,CACAsQ,mBAAAhR,KAAAU,gBAAA0Q,OACA,IAAAC,WAAArR,KAAAU,gBAAA4Q,WACAC,0BAAAvR,KAAAU,gBAAA0Q,QACAF,WACA,QAAA1L,QAAA6L,WACAH,SAAAzL,MACA9I,MAAAqD,KAAArD,MACAiT,KAAA,WACA3gB,KAAA,SAAAuW,KACA+J,QACArG,KAAA,IACAna,MAAAyW,QAIAxF,MAAAkR,SAAAlR,KAAAkR,SAAAM,OAAAN,WAGAnQ,MAAAkQ,YAAA,GAeA,QAAAM,2BAAAxQ,OACA,GAAAsQ,aACA,QAAA5hB,GAAAf,EAAA,EAAoBA,EAAAqS,MAAAtQ,SAAAhB,EAAAsR,MAAArS,IAAkCA,IAAA,CAEtD,OAAA2gB,GAAA/O,EAAA,EAAAmR,GAAAhiB,EAAAyhB,SAAqC5Q,EAAAmR,GAAAhhB,SAAA4e,EAAAoC,GAAAnR,IAA4BA,IACjE,OAAAvQ,GAAA8J,EAAA,EAAA2N,GAAA6H,EAAAE,MAAoC1V,EAAA2N,GAAA/W,SAAAV,EAAAyX,GAAA3N,IAA4BA,IAChE,GAAA9J,EAAA0f,UAAA,CACA,GAAAiC,MAAA3hB,EAAA0f,UAAAiC,IACA,QAAAC,IAAA,EAA0BA,GAAAD,KAAAjhB,OAAgBkhB,KAAA,CAC1C,GAAA1F,cAAAyF,KAAAC,IAAA1F,YACAA,gBACAoF,UAAApF,eAAA,GAGAoF,UAAAthB,EAAA0f,UAAAnS,aAAA,MAEAvN,GAAAkc,eACAoF,UAAAthB,EAAAkc,eAAA,EAMA,IAAAxc,EAAAiR,gBAAA,CACA,GAAAkR,mBAAAniB,EAAAiR,gBAAA4Q,UACAxgB,SAAA+gB,KAAAjf,MAAAye,UAAAO,oBAGA,MAAAP,WAgBA,QAAAS,mBAAAC,SACA,MAAAA,SAAA9iB,MACA,aAAA8iB,QAAAnC,MACA,QAAAmC,QAAAnC,OACAmC,QAAA7B,YACA,MAAA6B,QAAAxC,MAAA,GAAArG,KAkBA,QAAA8I,sBAAAxH,MAAA7N,MAAA/M,SAAA6c,KAAAnY,MAAAqZ,QACAnD,MAAAyH,iBACAzH,MAAAyH,kBAEA,IAAA5U,WAAA/I,OACAM,QAAAU,gBAAA1F,UAAA,UACA4a,OAAAyH,eAAAxM,MACA9I,YACA/M,kBACA6c,UACAnY,MAAA+I,UACAsQ,gBAWA,QAAAuE,oBAAApS,MACA,GAAA2R,IAAA3R,KAAAmS,cACA,QAAAhQ,MAAAvT,EAAA,EAAAC,EAAA8iB,GAAAhhB,OAAoC/B,EAAAC,IAAAsT,KAAAwP,GAAA/iB,IAAuBA,IAAA,CAC3D,GAAA8D,MAAAsN,KAAAuQ,YAAApO,KAAAtF,MACA8Q,mBAAAjb,KAAAsN,KAAAmC,OAoBA,QAAAkQ,eAAArS,KAAAC,IAAAgB,OACA,GAAAA,MAAAtQ,OAAA,CACA,GAAA2hB,OAAA,GAAArc,OAAAgL,MAAAtQ,OACA,QAAA/B,GAAA,EAAmBA,EAAAqS,MAAAtQ,OAAkB/B,IAAA,CACrC,GAAAsR,MAAAe,MAAArS,GACA8D,KAAA4f,MAAA1jB,GAAAoR,KAAAI,2BAAAH,IAAAC,KACAxN,MAAA4a,WAAAtN,KACAE,KAAAkR,UACAmB,qBAAArS,KAAAxN,MAGAsN,KAAAuQ,YAAA+B,MAEAtS,KAAAmS,gBACAC,mBAAApS,MAoBA,QAAA+Q,oBAAArG,MAAA8H,IAAA9O,KAAA+O,SAAAzD,WAAA0D,SACA,GAAAvQ,OACA3E,WAAAgV,IAAAhV,WACAoU,KAAAY,IAAAZ,KACA5C,sBACA2D,UAAAD,QAGA,IAAAF,IAAAI,OACAlI,MAAAqF,mBAAA,aAAArM,MACAgJ,GAAA+F,SAAAtQ,gBAGA,QAAA0Q,KAAAjkB,EAAA,EAAwBA,EAAA4jB,IAAAZ,KAAAjhB,SAAAkiB,IAAAL,IAAAZ,KAAAhjB,IAA0CA,IAClEikB,IAAAhD,SACAnF,MAAAqF,mBAAA8C,IAAA1G,aAAAzI,MACAgJ,GAAA+F,SAAAtQ,UAAAsK,QAAAoG,KAKAH,UACAhI,MAAAqF,mBAAAyC,IAAAhV,WAAAkG,MACAgJ,GAAA+F,SAAAtQ,YAoBA,QAAA2M,iBAAA9O,KAAAlQ,SAAA4U,MAAA6G,SAAApJ,MAGA,GAAAvM,SAAAoK,KAAAvC,aAAAuC,KACA0M,GAAA9W,QAAAuM,KAAA3E,WACA,IAAAkP,GAAA,CACA,GAAAkF,MAAAkB,YAAA9S,KAAA4K,OAAAzI,KAAAyP,KAAA9hB,SAAA4U,MACA,OAAAgI,IAAAqG,MAAAnd,QAAAgc,MACKzP,KAAAwQ,WACL/a,QAAAiG,KAAA,WAAAsE,KAAA3E,WAAA,iBAgBA,QAAA6T,aAAA2B,YAEA,GAAAjkB,GAAAikB,WAAAC,MAAA,yBACA,IAAAlkB,EAAA,CACA,GAAAyjB,MAAiBhV,WAAAzO,EAAA,GAAA6jB,QAAA,EACjB,IAAA7jB,EAAA,GAAAoJ,OAAA,CAEA,GAAAyZ,MAAA7iB,EAAA,GAAAuG,QAAA,kBAAgD4d,MAAA,IAChD,OAAAC,WAAAvB,KAAAY,KAGA,MADAA,KAAAZ,KAAAwB,WACAZ,IAGA,YAaA,QAAAW,WAAAE,QAAAb,KAQA,MAPAA,KAAAZ,KAAAyB,QAAAngB,IAAA,SAAAogB,QACA,GAAAT,KAAAU,SAAAD,OAIA,OAHAT,KAAAhD,UACA2C,IAAAI,QAAA,GAEAC,KACKvgB,MACLkgB,IAmBA,QAAAe,UAAAD,QAEA,GAAAT,KAAAS,OAAAnb,OAEA7C,QAAA,WAAuB,KAIvBA,QAAA,eAGAsJ,GACAzP,KAAA0jB,KAGAW,GAAAX,IAAA,EAOA,QANA,MAAAW,KACAA,GAAAX,IAAA,IAEAW,IAAA,KAAAA,IAAA,MACAA,GAAA,KAEAA,IACA,QACA,QACA5U,EAAA3P,MAAA4jB,IAAAhH,MAAA,MACAjN,EAAAiR,SAAA,CACA,MACA,SACAjR,EAAA3P,MAAAoV,OAAAwO,KACAjU,EAAAiR,SAAA,EAeA,MAXAjR,GAAAiR,UACAjR,EAAAuN,aAAAnb,QAAAob,KAAAtD,KAAA+J,KAEAjU,EAAAiO,WAAA7b,QAAAob,KAAAqH,OAAAZ,KACAjU,EAAAiO,aACAjO,EAAAmO,SAAA,MAAA8F,IAAAhH,OAAA,GACAjN,EAAAmO,WACAnO,EAAAzP,KAAA0jB,IAAAhH,MAAA,SAIAjN,EAeA,QAAAkU,aAAAY,KAAA9B,KAAAjF,KAAAjI,OACA,GAAApI,UACA,QAAA1N,GAAA,EAAAC,EAAA+iB,KAAAjhB,OAAgC/B,EAAAC,EAAKD,IAAA,CACrC,GAEAoL,GAFA6Y,IAAAjB,KAAAhjB,GACAO,KAAA0jB,IAAA1jB,IAeA,IAbA0jB,IAAAhD,QACA7V,EAAA6Y,IAAA5jB,MAEA4jB,IAAAhG,YACA7S,EAAAhJ,QAAAob,KAAA1c,IAAAgkB,KAAAvkB,MAEAqJ,SAAAwB,IACAA,EAAA0K,MAAAvV,QAGA6K,EAAA0Z,KAAAvkB,MAGA0jB,IAAA9F,SAAA,CAGA,GAAA4G,aAAA,IAAAxkB,KAAAkG,QAAAsX,KAAA,KACAjb,QAAA,IAAAib,KAAAtX,QAAAlG,QAAAwkB,WACArX,QAAA1N,IACA+d,KAAAjb,QAAAib,KAAAxd,KACAF,MAAAyC,QAAAgT,MAAAiI,MAAA3S,EACAjH,KAAAiH,OAGAsC,QAAA1N,GAAAoL,EAGA,MAAAsC,QAgBA,QAAAiW,sBAAArS,KAAAxN,MACA,GAAA0e,UAAAlR,KAAAkR,QACA,QAAAxiB,GAAA,EAAiBA,EAAAwiB,SAAAzgB,OAAmB/B,IAAA,CACpC,GAAAqjB,SAAAb,SAAAxiB,EACA,IAAAqjB,QAAA7B,WAAA,CAEA,GAAAQ,SAAAle,KAAAme,wBACAne,KAAAme,0BACApB,MAAAwC,QAAAxC,MAEA5Z,SAAA,GAAAI,OAAAwZ,MAAA9e,OACA,QAAA6P,GAAA,EAAqBA,EAAAiP,MAAA9e,OAAgB6P,IACrC3K,SAAA2K,GAAAiP,MAAAjP,GAAAqP,OAEA,IAAA1gB,MAAA8iB,QAAA9iB,IACAyhB,SAAAzhB,MAAA0G,SAEAoc,QAAApC,SAAA,YAAAoC,QAAAnC,OAKApd,KAAAvD,MAAA8iB,QAAApC,WAoBA,QAAA+D,eAAA5T,KAAA6T,MAAAlH,KAAAmH,SACA,GAAAC,aAAApH,KAAA,UACA3M,MAAAqN,WAAA0G,aAAkCC,aAAAF,UAClC9T,KAAAqN,WAAAV,KAAA,UAAAkH,MAAAljB,QAEAqP,KAAA4K,OAAAmJ,cAAgCC,aAAA,MAiBhC,QAAAC,cAAAjU,KAAA6T,MAAAlH,KAAA9P,MAAAqX,WAAAC,SACAP,cAAA5T,KAAA6T,MAAAlH,OACA9P,YACAqX,sBACAC,gBACAtkB,OAAAgkB,MACAnQ,KAAA,YAWA,QAAA0Q,OAAAjlB,MACA,MAAAA,MAAA,GAAAoG,cAAApG,KAAAklB,UAAA,GAnoCA,KAAAvf,SAAA9D,QAAA8D,QACAhC,MAAA9B,QAAAgB,MAAAc,KAIA,IAAAf,UAAA,CAGA,MAAAie,QACAsE,IAAA,oBACAC,QAAA,mBACAC,QAAA,mBACAC,OAAA,kBACAxE,UAAA,qBACAyE,QAAA,mBACAC,UAAA,cAm3BAvB,aAoQApiB,SAAA4T,gBAAA5T,QAAAgB,MAAA+L,cAAA,SAAAC,YAEA,KAAAlL,OAAA9B,QAAA8P,cACA9P,QAAAsS,WAAAtS,QAAA+Z,kBAAA/M,mBAKA4G,wBAAA9R,OAEA8hB,4BACA,MAAA5E,OAGA7e,cACAkJ,QACA/H,KAAAuiB,eAAA,EACAviB,KAAAwiB,mBAAA,EACAxiB,KAAAyiB,qBAAA,KACAziB,KAAA0iB,iBAAA,EACA1iB,KAAA8c,kBAAA,KACA9c,KAAAie,YAAA,KACAje,KAAA2iB,gBAAA,EAEA3iB,KAAAue,sBAAAve,KAAAue,uBAAA,KACAve,KAAAgb,WAAAhb,KAAAgb,YAAA,KAaAnc,wBACAkJ,MAAAoN,wBACAnV,KAAAgd,cAEAhd,KAAAwY,aACAxY,KAAAsY,OAAAtb,OAAAqE,OAAArB,KAAAwY,aACAxY,KAAA2Y,cAAA3b,OAAAqE,OAAArB,KAAAwY,aACAxY,KAAA4Y,cAEA5Y,KAAA2Y,cAAA,IAGA,QAAAhb,KAAAqC,MAAA2c,kBACA,GAAA3c,KAAAtC,eAAAC,GAAA,CACA,GAAAhB,OAAAqD,KAAArC,SACAqC,MAAArC,GACAqC,KAAArC,GAAAhB,OAoCAkC,mBAAArB,SAAA4T,KAAAwR,QACA,GAAAtJ,SAAAD,mBAAArZ,KAAA0d,MAAAsE,KAAAxkB,SACA8b,WACAA,QAAAtZ,KAAA2c,kBAAAnf,aACAwC,KAAA6iB,wBAAArlB,SACA4T,MAAAsM,MAAA2E,YAGAO,QACAtJ,QAAAjG,KAAAuP,QAEAtJ,QAAAD,mBAAArZ,KAAAoR,MAAA5T,UACA8b,UACAA,QAAAtZ,KAAAoR,MAAA5T,cAEA8b,QAAAjG,KAAAuP,QAYA/jB,mBAAArB,SAAA4T,MACA,GAAAkI,SAAAtZ,KAAAoR,MAAAsM,MAAAsE,IACA,OAAAhQ,SAAAsH,iBAAA9b,WAWAqB,mBAAArB,UACA,MAAAwC,MAAA8iB,mBAAAtlB,SAAAkgB,MAAA2E,WAWAxjB,iBAAArB,UACA,MAAAwC,MAAA8iB,mBAAAtlB,SAAAkgB,MAAAyE,QAWAtjB,kBAAArB,UACA,MAAAwC,MAAA8iB,mBAAAtlB,SAAAkgB,MAAAwE,SAWArjB,mBAAArB,UACA,MAAAwC,MAAA8iB,mBAAAtlB,SAAAkgB,MAAAuE,SA+BApjB,0BAAAwb,KAAA1d,MAAAomB,oBACA,GAAAlJ,cAAAnb,QAAAob,KAAAtD,KAAA7S,MAAAC,QAAAyW,WAAA,GAAAA,MACA2I,UAAAhjB,KAAA2c,mBAAA3c,KAAA2c,kBAAA9C,cACAqE,OAAArE,eAAAQ,IACA,IAAA2I,UAAA,CACA,GAAA9E,OAAA,CACA,IAAA6E,mBAAA,CASA,GAAAhM,KAAArY,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAGA,IAFAA,KAAuC3b,QAAAob,KAAAhZ,IAAAd,KAAAqa,KAAA1d,QAEvC0d,OAAAtS,MAAAgR,sBAAAsB,KAAA1d,MAAAoa,KACA,SAGA/W,KAAA2iB,gBAAA,EAEA,MAAA3iB,MAAAuY,oBAAA8B,KAAA1d,OAQA,MANAuhB,QACAxf,QAAAob,KAAAhZ,IAAAd,KAAAqa,KAAA1d,OAEAqD,KAAAqa,MAAA1d,OAGA,EAsBAkC,4BAAAuB,KAAAgT,KAAAzW,OAKAA,QAAAyD,KAAAgT,OAAA,gBAAAzW,SACAyD,KAAAgT,MAAAzW,OAkCAkC,oBAAArB,SAAAb,OACA,GAAAuhB,QAAAle,KAAA2iB,gBAAAjkB,QAAAob,KAAAoE,OAAA1gB,UACAylB,UAAA/E,OAAAle,KAAAgd,WAAAhd,KAAAsY,MACA,IAAAtY,KAAA+Y,sBAAAvb,SAAAb,MAAAsmB,UAAAzlB,WAqBA,MApBAwC,MAAA2Y,gBACA3Y,KAAA2Y,iBACA3Y,KAAA4Y,cAGApb,WAAAwC,MAAA4Y,YACA5Y,KAAA4Y,UAAApb,UAAAwC,KAAAsY,OAAA9a,YAIA0gB,QAAA,gBAAAvhB,UACAqD,KAAAgd,WAAAxf,UAAAb,OAIAuhB,SACAle,KAAAsY,OAAA9a,UAAAb,OAGAqD,KAAA2Y,cAAAnb,UAAAb;CACA,EAuBAkC,sBAAArB,SAAAb,MAAAoa,KAIA,MAHA,gBAAApa,SACAoa,IAAA/W,KAAAgd,WAAAxf,WAEAuK,MAAAgR,sBAAAvb,SAAAb,MAAAoa,KAWAlY,wBACAmB,KAAAwiB,mBAEAxiB,KAAAsW,mBAYAzX,eAAAqkB,QACAljB,KAAAyiB,qBAAAziB,KAAAyiB,yBACAS,SAAAljB,MACAA,KAAAyiB,qBAAApP,KAAA6P,QAUArkB,gBAEA,GAAAskB,SAAAnjB,KAAAyiB,oBACA,IAAAU,QAAA,CACAnjB,KAAAyiB,qBAAA,IACA,QAAAnmB,GAAA,EAAuBA,EAAA6mB,QAAA9kB,OAAoB/B,IAAA,CAC3C,GAAA4mB,QAAAC,QAAA7mB,EAEA4mB,QAAAV,oBAAAU,OAAAvK,eACAuK,OAAA5M,kBAAA,KAaAzX,cAAAuT,OACA,OAAAiI,QAAAjI,OACApS,KAAA2b,YAAA3b,KAAA2b,WAAAtB,OAKAra,KAAA4b,0BAAAvB,KAAAjI,MAAAiI,MAGAra,MAAA8Y,wBAuBAja,iBAAA4a,WACAzZ,KAAAwiB,mBACAxiB,KAAAkJ,SAEAlJ,KAAA2Y,eAAA3Y,KAAAyiB,wBACAziB,KAAA0iB,gBAAAjJ,UACA1R,MAAAuO,mBACAtW,KAAA0Y,gBAEA1Y,KAAAgd,gBAoBAne,QACAmB,KAAAwiB,mBAAA,EAqBA3jB,eAAAmK,UACA,GAAA2E,KAAA5F,MAAA0O,eAAAzN,UACA2F,OAAA3F,SAAAuF,UAAAvF,SAAAnC,SAAAmY,MAEA,OADAe,eAAA/f,KAAA2N,IAAAgB,OACAhB,IAWA9O,mBAAAua,aAAAF,aAAAD,UACA,GAAAS,UAAA1Z,KAAA2iB,eACAlJ,UAAAzZ,KAAA0iB,eACA1iB,MAAA2iB,eAAA3iB,KAAA0iB,iBAAA,CAOA,IAAAtG,eAAAH,mBAAAjc,KAAAkZ,aAAAD,SAAAQ,UAAAC,SAEA0C,eAAAQ,mBAAA5c,KAAAkZ,aAAAkD,cAAA1C,UAEAF,WAAAxZ,UAAAojB,mBAAAlK,aAAAD,SAAAQ,UAAAC,UAEA1Z,KAAAqjB,gBAEA7J,WAAAxZ,UAAAsjB,iBAAApK,aAAAD,SAAAQ,UAAAC,UAEAF,WAAAxZ,UAAAujB,iBAAArK,aAAAD,SAAAQ,UAAAC,UAEAkB,iBAAA5a,KAAAyZ,UAAA2C,cAAAlD,aAAAD,SAAAQ,UAAAC,UAeA7a,UAAA2kB,GAAA7S,MACA6S,GAAA9kB,QAAAob,KAAA2J,UAAAD,IACA7S,KAAAjS,QAAAob,KAAA2J,UAAA9S,MACA3Q,KAAA8c,kBAAA9c,KAAA8c,sBACA9c,KAAA8c,kBAAA0G,IAAA7S,KAaA9R,YAAAwb,MACAA,KAAA3b,QAAAob,KAAA2J,UAAApJ,MACAra,KAAA8c,yBACA9c,MAAA8c,kBAAAzC,MAiCAxb,cAAAwb,KAAAmH,SACA,GAAA3R,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,KACrCyR,eAAAthB,KAAAuhB,MAAA1R,KAAAwK,KAAAmH,SAuBA3iB,IAAAwb,KAAA7D,MACA,MAAA9X,SAAAob,KAAA1c,IAAAoZ,MAAAxW,KAAAqa,MAwBAxb,IAAAwb,KAAA1d,MAAA6Z,MACAA,KACA9X,QAAAob,KAAAhZ,IAAA0V,KAAA6D,KAAA1d,OAEAqD,KAAA2b,YAAA3b,KAAA2b,WAAqEtB,OACrEra,KAAA4b,0BAAAvB,KAAA1d,QACAqD,KAAA8Y,wBAqBAja,KAAAwb,QAAAqJ,OACA,GAAA7T,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,MACrC8T,IAAApC,MAAAljB,OACAulB,IAAArC,MAAAlO,QAAAqQ,MAIA,OAHAA,OAAArlB,QACAsjB,aAAA3hB,KAAAuhB,MAAA1R,KAAAwK,KAAAsJ,IAAAD,MAAArlB,WAEAulB,IAiBA/kB,IAAAwb,MACA,GAAAxK,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,MACrCgU,UAAA7R,QAAAuP,MAAAljB,QACAulB,IAAArC,MAAAhK,KAIA,OAHAsM,YACAlC,aAAA3hB,KAAAuhB,MAAA1R,KAAAwK,KAAAkH,MAAAljB,OAAA,GAAAulB,MAEAA,IAqBA/kB,OAAAwb,KAAAyJ,MAAAC,eAAAL,OACA,GAAA7T,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,KAGrCiU,OADAA,MAAA,EACAvC,MAAAljB,OAAA2lB,KAAAC,OAAAH,OAEAE,KAAAC,MAAAH,OAEAA,QACAA,MAAA,EAEA,IAAAF,KAAArC,MAAA2C,OAAAJ,MAAAC,eAAAL,MAIA,QAHAA,MAAArlB,QAAAulB,IAAAvlB,SACAsjB,aAAA3hB,KAAAuhB,MAAA1R,KAAAwK,KAAAyJ,MAAAJ,MAAArlB,OAAAulB,KAEAA,IAiBA/kB,MAAAwb,MACA,GAAAxK,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,MACrCgU,UAAA7R,QAAAuP,MAAAljB,QACAulB,IAAArC,MAAAhb,OAIA,OAHAsd,YACAlC,aAAA3hB,KAAAuhB,MAAA1R,KAAAwK,KAAA,KAAAuJ,MAEAA,IAkBA/kB,QAAAwb,QAAAqJ,OACA,GAAA7T,SACA0R,MAAqC7iB,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,MACrC+T,IAAArC,MAAA4C,WAAAT,MAIA,OAHAA,OAAArlB,QACAsjB,aAAA3hB,KAAAuhB,MAAA1R,KAAAwK,KAAA,EAAAqJ,MAAArlB,WAEAulB,IAeA/kB,WAAAwb,KAAA1d,OAEA,GAAAynB,SACA,OAAArgB,UAAA1F,OAAA,CAEA,GAAAwR,QACAlT,OAAA+B,QAAAob,KAAA1c,IAAA4C,KAAAqa,KAAAxK,MACAuU,SAAAvU,KAAAwK,SAGA+J,UAFSzgB,MAAAC,QAAAyW,MAET3b,QAAAob,KAAA2J,UAAApJ,MAEsCA,IAEtCra,MAAA4b,0BAAAwI,SAAAznB,OAAA,IACAqD,KAAA8Y,wBAmBAja,wBAAArB,SAAA6mB,iBACArkB,KAAAyd,mBAAAjgB,SAAAkgB,MAAA2E,WACAgC,kBACArkB,KAAA,OAAA8hB,MAAAtkB,WAAA,SAAAb,OACAqD,KAAAuV,aAAA/X,SAAAb,SAYAkC,wBAAArB,SAAA0N,YACAlL,KAAAyd,mBAAAjgB,SAAAkgB,MAAA0E,SACAhI,GAAAO,kBACA9K,MACA3E,uBAEAiP,SAAoBtd,KAAAW,YAcpBqB,sBAAA6hB,YACA,GAAAR,KAAAnB,YAAA2B,WACA,KAAAR,IACA,SAAA5Z,OAAA,kCAAAoa,WAAA,IAEAjC,oBAAAze,KAAAkgB,IAAAxC,MAAA0E,QAAA5F,iBAUA3d,yBAAArB,UACAwC,KAAAyd,mBAAAjgB,SAAAkgB,MAAAyE,QACA/H,GAAAgB,gBACAvL,MACA5E,UAAAzI,QAAAU,gBAAA1F,UAAA,WACAA,qBAYAqB,yBAAArB,UACA,GAAA8mB,MAAA9hB,QAAAU,gBAAA1F,SACA,OAAA8mB,KAAA,GACAhf,QAAAiG,KAAA,YAAA/N,SAAA,qCACA8mB,KAAA,+GAEAtkB,KAAAyd,mBAAAjgB,SAAAkgB,MAAAwE,SACA9H,GAAAyB,iBACAhM,MACAkM,SAAAuI,QAiBAzlB,wBAAArB,SAAAkjB,YACA,GAAAR,KAAAnB,YAAA2B,WACA,KAAAR,IACA,SAAA5Z,OAAA,kCAAAoa,WAAA,IAEAjC,oBAAAze,KAAAkgB,IAAAxC,MAAAuE,QAAA3F,kBAAA9e,UAcAqB,cAAAmK,UAEAhJ,KAAAojB,qBACA,IAAAzU,OAAA3O,KAAA4O,0BAAA5F,SACA4V,oBAAAjQ,MACA,QAAAf,MAAAtR,EAAA,EAA2BA,EAAAqS,MAAAtQ,SAAAuP,KAAAe,MAAArS,IAAqCA,IAAA,CAEhE,GAAA+iB,IAAAzR,KAAAkR,QACA,QAAAa,SAAAzR,EAAA,EAAgCA,EAAAmR,GAAAhhB,SAAAshB,QAAAN,GAAAnR,IAAkCA,IAClEwR,kBAAAC,UACAC,qBAAA5f,KAAA1D,EAAAqjB,QAAA9iB,KACA8iB,QAAAxC,MAAA,GAAAxgB,MACAgjB,QAAAxC,MAAA,GAAAjb,MACAyd,QAAAxC,MAAA,GAAA5B,QAEA2B,iBAAAld,KAAA2f,QAAArjB,KAOA,MAAAgW,uB9B4zFO,SAASjW,OAAQD,QAASH,sB+Bn8JjC,SAAA4B,UACA,GAAAC,UAAA,MACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,IAGA,WACA,YAEA,IAAAsY,cACAgQ,uBAAA,+CACAC,aAAA,UACA3lB,cAAA3C,UACA,MAAAwC,SAAAyV,UAGAzV,QAAAyV,UAAAC,OAAAlY,UAFA,MASA2C,eAAA4lB,UAAAC,gBAGA,OAFA1oB,SAAAyoB,UAAA5e,OAAA+a,MAAA,KACA/U,QAAA,GACAvP,EAAA,EAAmBA,EAAAN,QAAAqC,OAAoB/B,IACvCuP,SAAA7L,KAAA2kB,cAAA3oB,QAAAM,GAAAooB,eAEA,OAAA7Y,UAKAhN,cAAA3C,SAAAwoB,gBACA,GAAAjoB,GAAAuD,KAAA4kB,cAAA1oB,SAOA,OANAO,OAAAooB,WACApoB,EAAAooB,SAAA7kB,KAAAwU,eAAA/X,KAEAA,GAAAioB,gBACApf,QAAAiG,KAAA,4CAAArP,UAEAO,KAAAooB,UAAA,IAIAhmB,eAAAiH,SAKA,OAAAuF,GAJAQ,QAAA,GAEAhF,QAAAf,QAAAe,SAAAf,QACAqI,GAAAtH,QAAAie,iBAAA9kB,KAAAukB,wBACAjoB,EAAA,EAAsBA,EAAA6R,GAAA9P,OAAe/B,IAGrC,GAFA+O,EAAA8C,GAAA7R,GAEA,aAAA+O,EAAAoB,UACAZ,SAAA7L,KAAAwU,eAAAnJ,OAIA,cAAAA,EAAAoB,UAAA,CACA,GAAAsY,SAAA1Z,EAAAyM,aAAA9X,KAAAwkB,aAEAO,WACAlZ,SAAA7L,KAAAglB,eAAAD,SAAA,IAGA1Z,IAAA4Z,kBAAA5Z,EACAA,EAAA/K,WAAA8B,YAAAiJ,GACAQ,SAAAnN,QAAA8O,WAAA5B,WAAAP,EAAAoJ,YAAA3O,QAAAgG,mBAIWT,GAAA+I,QAAA/I,EAAA+I,OAAA5V,OACXqN,SAAAnN,QAAA8O,WAAA5B,WAAAP,EAAA+I,OAAA5V,KAAAiW,YAAApJ,EAAA+I,QAIA,OAAAvI,UAIAnN,SAAA6V,4B/B+8JO,SAASlY,OAAQD,UgC5jKxB,SAAAyB,UACA,GAAAC,UAAA,IACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,WACA,YAEA,IAAAqnB,YAEAC,gBAAA,SAAAC,WACA,MAAA3mB,QAAA4mB,mBAAAC,MACA,UAAAF,UAAA,WAAAA,WAGAG,sBAAA,SAAAlpB,QACA,GAAAmpB,IAAA9mB,QAAAyV,UAAAC,OAAA/X,OACA,IAAAmpB,GACA,MAAAxlB,MAAAylB,gBAAAD,KAIAC,gBAAA,SAAA3f,SACA,MAAAA,SAAAgS,aAAA,cAKApZ,SAAAwmB,wBhCykKO,SAAS7oB,OAAQD,QAASH,sBiChoKjC,SAAA4B,UACA,GAAAC,UAAA,cACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAEAA,oBAAA,GAEAA,oBAAA,GAEAA,oBAAA,IAsDA,WAEA,YAgCA,SAAAypB,0BAAA1c,SAAA2c,iBAIA,GAAA9e,SAAAmC,SAAAuF,SAAAvF,SAAAuF,UAAAvF,SAAAnC,OAWA,OATAA,SAAAmY,SACAnY,QAAAmY,UAIA4G,iCAAA5c,SACA6c,qBAAAhf,gBAAAmY,OACA2G,iBAAA3c,SAAAkI,aAAA,sBAEArK,QAAAmY,OAIA,QAAA6G,sBAAAzlB,KAAA+S,KAAAwS,iBACA,MAAAvlB,MAAA0lB,WAAAC,KAAAC,UACAC,wBAAA7lB,KAAA+S,MACA+S,wBAAA9lB,KAAA+S,KAAAwS,iBAOA,QAAAQ,eAAAC,MACA,GAEA3pB,GAFA0gB,SACAkJ,UAAA,CAQA,cAAA5pB,EAAA6pB,aAAAC,KAAAH,QAAA,CAEA3pB,EAAA8N,MAAA8b,WACAlJ,MAAA9J,MAAoBkK,QAAA6I,KAAA7M,MAAA8M,UAAA5pB,EAAA8N,QAIpB,IAGAyT,aAAAwI,YAAAC,MAHA3P,KAAAra,EAAA,MACA8e,OAAAvJ,QAAAvV,EAAA,IACAE,MAAAF,EAAA,GAAAoJ,MAEA,MAAAiR,OAAoB2P,MAAA9pB,MAAAoG,QAAA,WACpByjB,YAAA7pB,MAAAolB,UAAA0E,MAAA,GACA9pB,YAAAolB,UAAA,EAAA0E,OACAzI,aAAA,GAEAb,MAAA9J,MACA0K,cAAAZ,MAAA9e,OACA1B,YACAma,UACAyE,cACArZ,MAAAskB,YACAxI,0BAEAqI,UAAAC,aAAAD,UAGA,GAAAA,qBAAAD,KAAA/nB,OAAA,CACA,GAAAkf,SAAA6I,KAAArE,UAAAsE,UACA9I,UACAJ,MAAA9J,MACAkK,kBAIA,GAAAJ,MAAA9e,OACA,MAAA8e,OAIA,QAAAuJ,kBAAAvJ,OACA,GAAAvf,GAAA,EACA,QAAAtB,GAAA,EAAiBA,EAAA6gB,MAAA9e,OAAgB/B,IAAA,CACjC,GAAAihB,SAAAJ,MAAA7gB,GAAAihB,OACA3f,IAAA2f,SAAA,GAEA,MAAA3f,GAIA,QAAAqoB,yBAAA7lB,KAAA+S,MACA,GAAAgK,OAAAgJ,cAAA/lB,KAAAqU,YACA,IAAA0I,MAAA,CAIA/c,KAAAqU,YAAAiS,iBAAAvJ,QAAA,GACA,IAAAvP,OACAkR,WACAtB,KAAA,OACA3gB,KAAA,cACAsgB,YACAW,WAAA,IAAAX,MAAA9e,SAIA,OADA8U,MAAAE,KAAAzF,MACAA,MAKA,QAAAsY,yBAAApgB,QAAAqN,KAAAwS,iBACA,GAAA/X,OACAkR,YACA7Q,UAaA,OAXAnI,SAAA2G,YAAAka,oBACAxT,KAAApE,oBAAA,GAEA6X,2BAAA9gB,QAAA8H,KAAAuF,KAAAwS,iBACA7f,QAAAW,aACAogB,8BAAA/gB,QAAA8H,MACAkZ,YAAAhhB,WAEA8H,KAAAkR,SAAAzgB,QAAAuP,KAAAK,OAAA5P,QAAAuP,KAAAC,KACAsF,KAAAE,KAAAzF,MAEAA,KAKA,QAAAgZ,4BAAApQ,KAAA5I,KAAAuF,KAAAwS,iBACA,GAAAnP,KAAA7B,WAAA,CACA,GAAAvU,MAAAoW,KAAA7B,WACArY,EAAA,CACA,MAAA8D,MAAA,CAEA,gBAAAA,KAAAqM,UAAA,CACA,GAAAsa,GAAA3mB,KACAuF,GAAAohB,EAAAjP,aAAA,KAEA,IAAAnS,IAAA,IAAAA,GAAA5C,QAAA,QAKA,IAJAgkB,EAAAvV,gBAAA,MACApR,KAAA2mB,EAAAjb,cAAA5N,cAAAyH,IACA6Q,KAAAwQ,aAAA5mB,KAAA2mB,GACA3mB,KAAA9B,YAAAyoB,GACAA,EAAAtgB,WAAApI,QACA+B,KAAAyB,aAAAklB,EAAAtgB,WAAA,GAAA5J,KAAAkqB,EAAAtgB,WAAA,GAAA9J,OACAoqB,EAAAvV,gBAAAuV,EAAAtgB,WAAA,GAAA5J,MAIA,aAAAuD,KAAAqM,WACArM,KAAA8Q,aAAA,qBACA+V,cAAA7mB,KAAA9D,EAAA6W,KAAAvF,KAAA+X,gBAMA,IAAAuB,MAAA9mB,KAAA+mB,WACA,IAAA/mB,KAAA0lB,WAAAC,KAAAC,UAAA,CACA,GAAA3oB,GAAA6pB,IACA,MAAA7pB,KAAAyoB,WAAAC,KAAAC,WACA5lB,KAAAqU,aAAApX,EAAAoX,YACAyS,KAAA7pB,EAAA8pB,YACA3Q,KAAApU,YAAA/E,GACAA,EAAA6pB,IAGAvB,mBAAAvlB,KAAAqU,YAAA5O,SACA2Q,KAAApU,YAAAhC,MAEA9D,KAIA,GAAA8D,KAAAE,WAAA,CACA,GAAA8mB,iBAAAvB,qBAAAzlB,KAAA+S,KACAwS,gBACAyB,mBACAA,gBAAAzgB,OAAAiH,KACAwZ,gBAAA7c,MAAAjO,GAGA8D,KAAA8mB,KACA5qB,MAYA,QAAA2qB,eAAA7mB,KAAAmK,MAAA4I,KAAAxM,OAAAgf,iBACA,GAAA9e,SAAAzG,KAAAyG,QAAAiF,cAAAub,wBACAxgB,SAAAmY,OAAA0G,yBAAAtlB,KAAAulB,iBACA9e,QAAAvI,YAAA8B,KAAAyG,SACAsM,KAAAE,MACAyL,SAAAgC,WACA7S,OAAA6S,WACAxS,gBAAAzH,QACAF,cACA4D,cAOA,QAAAsc,+BAAAzmB,KAAAknB,YAGA,GAAAC,OAAA5jB,MAAAlG,UAAA8b,MAAA/c,KAAA4D,KAAAqG,WACA,QAAA6F,GAAAhQ,EAAAirB,MAAAlpB,OAAA,EAAiCiO,EAAAib,MAAAjrB,GAAcA,IAAA,CAC/C,GAEA2gB,GAFA5f,EAAAiP,EAAAzP,KACA6K,EAAA4E,EAAA3P,KAGA,SAAAU,EAAAkc,MAAA,MACAnZ,KAAAoR,gBAAAnU,GACAiqB,WAAArZ,OAAAoF,MACAxW,KAAAQ,EAAAkc,MAAA,GACA5c,MAAA+K,MAIAuV,EAAAuK,6BAAApnB,KAAA/C,EAAAqK,IACA4f,WAAAxI,SAAAzL,KAAA4J,GAGA,OAAA5f,IACAiqB,WAAAzZ,GAAAnG,IAMA,QAAA8f,8BAAApnB,KAAAvD,KAAAF,OACA,GAAAwgB,OAAAgJ,cAAAxpB,MACA,IAAAwgB,MAAA,CAEA,GAAAsK,UAAA5qB,KACA2gB,KAAA,UACA,MAAA3gB,UAAAwB,OAAA,KACAxB,UAAA0c,MAAA,MACAiE,KAAA,YAGA,IAAAD,SAAAmJ,iBAAAvJ,MACAI,UAAA,aAAAC,MACApd,KAAAyB,aAAAhF,KAAA0gB,SAMA,UAAAnd,KAAAqM,WAAA,UAAAgb,UACArnB,KAAAyB,aAAA4lB,SAAA,IAGArnB,KAAAoR,gBAAAiW,SAKA,IAAA5J,cAAAnf,QAAA8D,QAAAK,gBAAAhG,KAIA,OAHA,aAAA2gB,OACA3gB,KAAAghB,eAGAL,UACA3gB,UACAghB,0BACAV,YACAI,gBACAO,WAAA,IAAAX,MAAA9e,SAMA,QAAAyoB,aAAAhhB,SACApH,QAAA8O,WAAApB,aAAAtG,QAAA8f,gBAAA9Z,eA5TA,KAAAgV,cAEA,IAoBA8E,iBApBAU,aAAA,WACA,GAAAoB,OAAA,8BACAC,OAAA,gDACAC,cAAA,4BACAC,cAAA,4BACAC,OAAA,MAAAF,cAAA,IAAAC,cAAA,IACAE,SAAA,MAAAL,MAAA,IAAAC,OAAA,IAAAG,OAAA,QACAE,UAAA,MAAAD,SAAA,WAAAA,SAAA,MACAE,cAAA,gBACAD,UAAA,aAEAE,QAAA,IAAAR,MAAA,OAAAO,cAAA,KACAE,aAAA,kBACAC,cAAA,YACAC,OAAA,eACAC,WAAAH,aAAAE,OAAAH,QAAAE,aACA,WAAAG,QAAAD,WAAA,QAGA3B,kBAAA,MA0SAjoB,SAAA+P,YAAA/P,QAAAgB,MAAA+L,cAAA,SAAAC,YAEA,YAAA+C,oBAAA/C,YASA7M,0BAAAmK,UACA,MAAA0c,0BAAA1c,UAOAnK,2BAAA2X,KAAA5I,MAEA,GAAAjH,QAAAiH,KAAAjH,QAAA3G,KAAA8N,2BAAA0I,KACA5I,KAAAjH,OAEA,KAAAA,OASA,MAAA6P,KANA,QAAAnZ,GAAAsJ,OAAAgO,WAAArY,EAAA,EAA4Ce,EAAGA,IAAA8pB,YAC/C,GAAAvZ,KAAArD,QAAAjO,IACA,MAAAe,WjCupKO,SAAShB,OAAQD,QAASH,sBkCnlLjC,SAAA4B,UACA,GAAAC,UAAA,QACA,IAAAD,SAAAE,KAAA,CACA,GAAAC,IAAAH,SAAAE,KACAE,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAIL,SAAAA,UACA,GAAAC,UAAA,EACA,IAAAD,SAAAW,KAAA,CACA,GAAAR,IAAAH,SAAAW,KACAP,IAAAJ,SAAAK,cAAA,MAEA,KADAD,IAAAE,UAAAL,SACAG,IAAAG,SAAAC,OAAA,GACAL,GAAAM,YAAAL,IAAAG,SAAA,QAGAP,UAAAU,MAAAT,WAEKD,UAGL5B,oBAAA,GAGA,WAEA,KAAA6d,OAEAoE,OAAA,SAAA7D,MACA,MAAAA,MAAAtX,QAAA,SAGAyT,KAAA,SAAA6D,MACA,GAAAmO,UAAAnO,KAAAtX,QAAA,IACA,OAAAylB,aAAA,EACAnO,KAEAA,KAAAd,MAAA,EAAAiP,WAIAhO,WAAA,SAAA/Z,KAAA4Z,MAEA,WAAA5Z,KAAAsC,QAAAsX,KAAA,MAIAK,aAAA,SAAAja,KAAA4Z,MAEA,WAAAA,KAAAtX,QAAAtC,KAAA,MAIAgb,UAAA,SAAAhb,KAAAgoB,QAAApO,MAEA,MAAAoO,SAAApO,KAAAd,MAAA9Y,KAAApC,SAGAe,QAAA,SAAAqB,KAAA4Z,MACA,MAAA5Z,QAAA4Z,MACAra,KAAAwa,WAAA/Z,KAAA4Z,OACAra,KAAA0a,aAAAja,KAAA4Z,OAQAoJ,UAAA,SAAApJ,MACA,GAAA1W,MAAAC,QAAAyW,MAAA,CAEA,OADA8C,UACA7gB,EAAA,EAAqBA,EAAA+d,KAAAhc,OAAe/B,IAEpC,OADAgjB,MAAAjF,KAAA/d,GAAAoV,WAAAkP,MAAA,KACA1S,EAAA,EAAuBA,EAAAoR,KAAAjhB,OAAe6P,IACtCiP,MAAA9J,KAAAiM,KAAApR,GAGA,OAAAiP,OAAAqB,KAAA,KAEA,MAAAnE,OASAuG,MAAA,SAAAvG,MACA,MAAA1W,OAAAC,QAAAyW,MACAra,KAAAyjB,UAAApJ,MAAAuG,MAAA,KAEAvG,KAAA3I,WAAAkP,MAAA,MASAxjB,IAAA,SAAAoZ,KAAA6D,KAAAxK,MAIA,OAHAuD,MAAAoD,KACA2G,MAAAnd,KAAA4gB,MAAAvG,MAEA/d,EAAA,EAAmBA,EAAA6gB,MAAA9e,OAAgB/B,IAAA,CACnC,IAAA8W,KACA,MAEA,IAAAgK,MAAAD,MAAA7gB,EACA8W,WAAAgK,MAKA,MAHAvN,QACAA,KAAAwK,KAAA8C,MAAAqB,KAAA,MAEApL,MASAtS,IAAA,SAAA0V,KAAA6D,KAAA1d,OACA,GAAAyW,MAAAoD,KACA2G,MAAAnd,KAAA4gB,MAAAvG,MACAqO,KAAAvL,YAAA9e,OAAA,EACA,IAAA8e,MAAA9e,OAAA,GAEA,OAAA/B,GAAA,EAAqBA,EAAA6gB,MAAA9e,OAAA,EAAkB/B,IAAA,CACvC,GAAA8gB,MAAAD,MAAA7gB,EAEA,IADA8W,UAAAgK,OACAhK,KACA,OAIAA,KAAAsV,MAAA/rB,UAGAyW,MAAAiH,MAAA1d,KAEA,OAAAwgB,OAAAqB,KAAA,MAMA1E,MAAAqH,OAAArH,KAAAoE,OAEAxf,QAAAob,clCgmLO,SAASzd,OAAQD,QAASH,qBAEjC,YmCvwLAA,qBAAA","file":"app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 33);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n\n  window.Polymer = window.Polymer || {};\n  window.Polymer.version = '2.0-preview';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, goog.reflect.objectProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  var goog = {\n    reflect: {\n      objectProperty(s, o) {\n        return s;\n      }\n    }\n  }\n  /* eslint-enable */\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n\n\n(function() {\n\n  'use strict';\n\n  let p = Element.prototype;\n  let matchesSelector = p.matches || p.matchesSelector ||\n    p.mozMatchesSelector || p.msMatchesSelector ||\n    p.oMatchesSelector || p.webkitMatchesSelector;\n\n  // unique global id for deduping mixins.\n  let dedupeId = 0;\n\n  // run a callback when HTMLImports are ready or immediately if\n  // this api is not available.\n  function whenImportsReady(cb) {\n    if (window.HTMLImports) {\n      HTMLImports.whenReady(cb);\n    } else {\n      cb();\n    }\n  }\n\n  Polymer.Utils = {\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @method mixin\n     * @param {Object} target Target object to copy properties to.\n     * @param {Object} source Source object to copy properties from.\n     * @return {Object} Target object that was passed as first argument.\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    },\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @method extend\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     */\n    extend(prototype, api) {\n      if (prototype && api) {\n        let n$ = Object.getOwnPropertyNames(api);\n        for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n          this.copyOwnProperty(n, api, prototype);\n        }\n      }\n      return prototype || api;\n    },\n\n    copyOwnProperty(name, source, target) {\n      let pd = Object.getOwnPropertyDescriptor(source, name);\n      if (pd) {\n        Object.defineProperty(target, name, pd);\n      }\n    },\n\n    // only needed for v0 native ShadowDOM support\n    getRootNode(node) {\n      if (node.getRootNode) {\n        return node.getRootNode();\n      }\n      if (!node) {\n        return null;\n      }\n      while(node && node.parentNode) {\n        node = node.parentNode;\n      }\n      return node;\n    },\n\n    matchesSelector(node, selector) {\n      return matchesSelector.call(node, selector);\n    },\n\n    /**\n     * Given a mixin producing function, memoize applications of mixin to base\n     */\n    cachingMixin(mixin) {\n      return function(base) {\n        if (!mixin.__mixinApplications) {\n          mixin.__mixinApplications = new WeakMap();\n        }\n        let map = mixin.__mixinApplications;\n        let application = map.get(base);\n        if (!application) {\n          application = mixin(base);\n          map.set(base, application);\n        }\n        return application;\n      };\n    },\n\n    /**\n     * Given a mixin producing function, only apply mixin if has not already been applied to base\n     * Also memoize mixin applications\n     */\n    dedupingMixin(mixin) {\n      mixin = this.cachingMixin(mixin);\n      // maintain a unique id for each mixin\n      if (!mixin.__id) {\n        mixin.__dedupeId = ++dedupeId;\n      }\n      return function(base) {\n        let baseSet = base.__mixinSet;\n        if (baseSet && baseSet[mixin.__dedupeId]) {\n          return base;\n        }\n        let extended = mixin(base);\n        // copy inherited mixin set from the extended class, or the base class\n        // NOTE: we avoid use of Set here because some browser (IE11)\n        // cannot extend a base Set via the constructor.\n        extended.__mixinSet =\n          Object.create(extended.__mixinSet || baseSet || null);\n        extended.__mixinSet[mixin.__dedupeId] = true;\n        return extended;\n      }\n    },\n\n    /**\n     * Convenience method for importing an HTML document imperatively.\n     *\n     * This method creates a new `<link rel=\"import\">` element with\n     * the provided URL and appends it to the document to start loading.\n     * In the `onload` callback, the `import` property of the `link`\n     * element will contain the imported document contents.\n     *\n     * @method importHref\n     * @param {string} href URL to document to load.\n     * @param {Function=} onload Callback to notify when an import successfully\n     *   loaded.\n     * @param {Function=} onerror Callback to notify when an import\n     *   unsuccessfully loaded.\n     * @param {boolean=} optAsync True if the import should be loaded `async`.\n     *   Defaults to `false`.\n     * @return {HTMLLinkElement} The link element for the URL to be loaded.\n     */\n    importHref(href, onload, onerror, optAsync) {\n      let link =\n        document.head.querySelector('link[href=\"' + href + '\"][import-href]');\n      if (!link) {\n        link = document.createElement('link');\n        link.rel = 'import';\n        link.href = href;\n        link.setAttribute('import-href', '');\n      }\n      // always ensure link has `async` attribute if user specified one,\n      // even if it was previously not async. This is considered less confusing.\n      if (optAsync) {\n        link.setAttribute('async', '');\n      }\n      // NOTE: the link may now be in 3 states: (1) pending insertion,\n      // (2) inflight, (3) already laoded. In each case, we need to add\n      // event listeners to process callbacks.\n      let cleanup = function() {\n        link.removeEventListener('load', loadListener);\n        link.removeEventListener('error', errorListener);\n      }\n      let loadListener = function(event) {\n        cleanup();\n        // In case of a successful load, cache the load event on the link so\n        // that it can be used to short-circuit this method in the future when\n        // it is called with the same href param.\n        link.__dynamicImportLoaded = true;\n        if (onload) {\n          whenImportsReady(() => {\n            onload(event);\n          });\n        }\n      };\n      let errorListener = function(event) {\n        cleanup();\n        // In case of an error, remove the link from the document so that it\n        // will be automatically created again the next time `importHref` is\n        // called.\n        if (link.parentNode) {\n          link.parentNode.removeChild(link);\n        }\n        if (onerror) {\n          whenImportsReady(() => {\n            onerror(event);\n          });\n        }\n      };\n      link.addEventListener('load', loadListener);\n      link.addEventListener('error', errorListener);\n      if (link.parentNode == null) {\n        document.head.appendChild(link);\n      // if the link already loaded, dispatch a fake load event\n      // so that listeners are called and get a proper event argument.\n      } else if (link.__dynamicImportLoaded) {\n        link.dispatchEvent(new Event('load'));\n      }\n      return link;\n    }\n  };\n\n})();\n\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n\n(function() {\n\n  const CaseMap = {\n\n    _caseMap: {},\n    _rx: {\n      dashToCamel: /-[a-z]/g,\n      camelToDash: /([A-Z])/g\n    },\n\n    dashToCamelCase: function(dash) {\n      return this._caseMap[dash] || (\n        this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel,\n          function(m) {\n            return m[1].toUpperCase();\n          }\n        )\n      );\n    },\n\n    camelToDashCase: function(camel) {\n      return this._caseMap[camel] || (\n        this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase()\n      );\n    }\n\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction createTemplateBindingFunction(context = {}) {\n    return (name, ...literals) => typeof name[0] === 'string' && name[0].length ? context && context[name[0]] || `{{${name[0]}}}` : '';\n}\nexports.createTemplateBindingFunction = createTemplateBindingFunction;\nfunction NerdyTemplateBindingFunction(name) {\n    return `{{${typeof name === 'string' ? name : name[0]}}}`;\n}\nexports.NerdyTemplateBindingFunction = NerdyTemplateBindingFunction;\nfunction isString(argument) {\n    return typeof argument === 'string';\n}\nfunction firstItemIsString(argument) {\n    return argument && argument.length === 1 && isString(argument[0]);\n}\nfunction flattenResults(results) {\n    if (Array.isArray(results))\n        switch (results.length) {\n            case 0: return undefined;\n            case 1: return results[1];\n            default: return results;\n        }\n}\nconst convertFromDashToCamel = (dash) => dash.replace(/-[a-z]/g, String.prototype.toUpperCase);\nconst convertFromCamelToDash = (dash) => dash.replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\nfunction dashToCamel(dashCaseString, ...more) {\n    return flattenResults([...arguments].map(argument => typeof argument === 'string' ? convertFromDashToCamel(argument) : Array.isArray(argument) ? dashToCamel(argument) : argument));\n}\nexports.dashToCamel = dashToCamel;\nfunction camelToDash(dashCaseString, ...more) {\n    return flattenResults([...arguments].map(argument => typeof argument === 'string' ? convertFromCamelToDash(argument) : Array.isArray(argument) ? camelToDash(argument) : argument));\n}\nexports.camelToDash = camelToDash;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nexports.PolymerTemplateBindingFunction = (name) => `{{${typeof name === 'string' ? name : name[0]}}}`;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(17));\n__export(__webpack_require__(16));\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(7));\nconst nerdy_dom_1 = __webpack_require__(7);\nexports.createElementFromTagName = nerdy_dom_1.default.createElementFromTagName;\nexports.createElementFromClass = nerdy_dom_1.default.createElementFromClass;\nexports.createErrorElement = nerdy_dom_1.default.createErrorElement;\nexports.createWrappedElement = nerdy_dom_1.default.createWrappedElement;\nexports.convertToElement = nerdy_dom_1.default.convertToElement;\nexports.createElement = nerdy_dom_1.default.createElement;\nexports.applyAttributes = nerdy_dom_1.default.applyAttributes;\nexports.insertChild = nerdy_dom_1.default.insertChild;\nexports.insertChildren = nerdy_dom_1.default.insertChildren;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = nerdy_dom_1.default;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nclass NerdyDOM {\n    static get createElementFromTagName() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.createElementFromTagName;\n    }\n    static get createElementFromClass() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.createElementFromClass;\n    }\n    static get createErrorElement() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.createErrorElement;\n    }\n    static get createWrappedElement() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.createWrappedElement;\n    }\n    static get convertToElement() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.convertToElement;\n    }\n    static get createElement() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.createElement;\n    }\n    static get applyAttributes() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.applyAttributes;\n    }\n    static get insertChild() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.insertChild;\n    }\n    static get insertChildren() {\n        if (NerdyDOM.activeDOM)\n            return NerdyDOM.activeDOM.insertChildren;\n    }\n    constructor(targetDocument = NerdyDOM.activeDocument) {\n        this.document = targetDocument;\n        for (const method of ['createElementFromTagName', 'createElementFromClass', 'createErrorElement', 'createWrappedElement', 'convertToElement', 'convertToElement', 'convertToElement', 'createElement', 'applyAttributes', 'insertChild', 'insertChildren'])\n            this[method] = this[method].bind(this);\n        console.log('NerdyDOM', { this: this, targetDocument, arguments });\n    }\n    createElementFromTagName(tag) {\n        try {\n            return this.document.createElement(tag);\n        }\n        catch (exception) {\n            exception.message = `Error executing createElementFromTagName(${typeof tag === 'string' ? tag : typeof (tag)}): ${exception.message}`;\n            return exception; // this.stackTrack.push(exception);\n        }\n    }\n    createElementFromClass(tag) {\n        try {\n            return new tag();\n        }\n        catch (exception) {\n            exception.message = `Error executing createElementFromClass(${tag.name || (tag.prototype && tag.prototype.name) || tag.is || tag}): ${exception.message}`;\n            return exception; // this.stackTrack.push(exception);\n        }\n    }\n    createErrorElement(exception, ...contents) {\n        const message = (typeof exception === 'string' ? exception : typeof exception.message === 'string' ? exception.message : '').trim();\n        const header = `Error: ${message.length ? message : 'Unknown Exception'}`;\n        // const body = contents.reduce((item, body) => body + (typeof item !== 'undefined' ? ('\\n' + pretty(item) + '\\n') : ''), '').trim();\n        const body = contents.reduce((item, body) => body + (typeof item !== 'undefined' ? ('\\n' + item + '\\n') : ''), '').trim();\n        const element = this.document.createComment(`Error: ${message.length ? message : 'Unknown Exception' + contents}`);\n        return element;\n    }\n    convertToElement(value) {\n        if (value === undefined)\n            return this.document.createTextNode('UNDEFINED');\n        else if (value === null)\n            return this.document.createTextNode('NULL');\n        else if (typeof value === 'object' && value instanceof HTMLElement)\n            return value;\n        else\n            switch (typeof value) {\n                case 'string': return this.document.createTextNode(`\"${value}\"`);\n                case 'number': return this.document.createTextNode(`${value}`);\n                case 'boolean': return this.document.createTextNode(value === true ? 'TRUE' : 'FALSE');\n                default: return this.document.createTextNode(value); //pretty(\n            }\n    }\n    createWrappedElement(...contents) {\n        const wrapper = this.document.createElement('template');\n        if (contents[0] instanceof Error)\n            wrapper.appendChild(this.createErrorElement(contents.shift(), contents));\n        else\n            for (const child of contents)\n                wrapper.appendChild(this.convertToElement(child));\n    }\n    applyAttributes(element, attributes = {}) {\n        try {\n            if (typeof attributes === 'object' && 'setAttribute' in element)\n                for (const name in attributes)\n                    element.setAttribute(name, attributes[name]); // tslint:disable-line\n        }\n        catch (exception) {\n            exception.message = `Error executing applyAttributes(): ${exception.message}`;\n            console.error(exception); // this.stackTrack.push(exception);\n        }\n    }\n    insertChild(element, child) {\n        if (typeof child === 'string')\n            element.appendChild(this.document.createTextNode(child));\n        else if (child instanceof HTMLElement)\n            element.appendChild(child);\n    }\n    insertChildren(element, ...children) {\n        const parent = typeof element !== 'object' || !(element instanceof HTMLElement) ? null : element instanceof HTMLTemplateElement ? element.content : element;\n        if (!parent)\n            throw new TypeError(`Elements can only be inserted into elements that inherit from HTMLElement or HTMLTemplateElement`);\n        typeof children === 'string' ? this.insertChild(parent, children) : children.forEach(child => this.insertChild(parent, child)); // console.log('CHILDREN', children);\n    }\n    createElement(tag, attributes = {}, ...children) {\n        try {\n            // Create new instance of element\n            const element = typeof tag === 'string' ? this.createElementFromTagName(tag) : this.createElementFromClass(tag);\n            // If create fails, create a wrapped element from the error for debugging\n            if (element instanceof Error)\n                return this.createErrorElement(element, { tag, attributes, children }); // , ...this.stackTrack);\n            // Apply attributes to element\n            if (attributes && Object.keys(attributes).length)\n                this.applyAttributes(element, attributes);\n            // Insert children into element\n            if (children.length)\n                this.insertChildren(element, ...children);\n            // Return element // console.log('createElement', { tag, attributes, children, arguments, this: this, element });\n            return element;\n        }\n        catch (exception) {\n            console.error(exception); // this.stackTrack.push(exception);\n        }\n    }\n}\nexports.NerdyDOM = NerdyDOM;\nif (!NerdyDOM.activeDocument)\n    NerdyDOM.activeDocument = document; // window typeof window !== 'undefined' && 'document' in window && window.document;\nif (!NerdyDOM.activeDOM)\n    NerdyDOM.activeDOM = new NerdyDOM();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NerdyDOM;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n__webpack_require__(20);\nconst decorators_1 = __webpack_require__(5);\nconst nerdy_elements_helpers_1 = __webpack_require__(19);\nclass NerdyElement extends Polymer.Element {\n    constructor() {\n        super() && typeof this.created === 'function' && this.created();\n        this.propertyLookup = {};\n    }\n    static define(constructor) {\n        const constructorName = constructor && (constructor.name || constructor.displayName) || typeof constructor;\n        if (!NerdyElement.isConstructor(constructor))\n            throw new Error(`Expected a constructor of a NerdyElement in order to define an element, but got ${constructorName} instead.`);\n        const tagName = constructor.is;\n        const tagNameAvailable = !(tagName in NerdyElement.elements);\n        const customElementNameAvailable = window.customElements.get(tagName) === undefined;\n        const alreadyDefined = !tagNameAvailable && NerdyElement.elements[tagName] === constructor;\n        // Check tagName\n        if (tagNameAvailable && customElementNameAvailable) {\n            let element;\n            try {\n                element = document.createElement(tagName);\n            }\n            catch (exception) {\n                throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is not valid in the current runtime environment. ${exception.message}`);\n            }\n        }\n        else if (!tagNameAvailable) {\n            throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is already used to define another NerdyElement.`);\n        }\n        else if (!customElementNameAvailable) {\n            throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is already used to define another custom element in the document.`);\n        }\n        if (alreadyDefined)\n            return;\n        if (tagName in NerdyElement.elements)\n            throw new Error(`Cannot define NerdyElement since the tag name '${tagName}' returned by ${constructorName}.is has already been used to define another element. In order to resolve this, you might want to rename the class of one of the elements, or if you prefer to not rename the actual classes, simply set the static is property on either class to use a different tag name.`);\n        if (customElementNameAvailable) {\n            try {\n                window.customElements.define(constructor.is, constructor);\n            }\n            catch (exception) {\n                throw new Error(`Cannot register this NerdyElement as a custom element in the current runtime environment. ${exception.message}`);\n            }\n        }\n        NerdyElement.elements[tagName] = constructor;\n        window.customElements.whenDefined(tagName).then(() => {\n            if (window.customElements.get(tagName) !== NerdyElement.elements[tagName]) {\n                throw new Error(`NerdyElement: Unexpected mismatch between the NerdyElement registry and the custom element registry for the tag ${tagName}, which can be caused by another custom element racing to be registered using the same tag name and that might result in serious conflicts, or it could be due to some \"Web Components\" framework or polyfills applying mixins to the original element and that is also can cause unexpected behaviour. Please notify the adiministrators that they should verify that there are no resulting security vulnerabilities.`);\n            }\n        });\n    }\n    static set observedAttributes(attributes) {\n        if (this === NerdyElement)\n            return;\n        Object.defineProperty(this, 'observedAttributes', {\n            value: attributes,\n        });\n    }\n    static set is(name) {\n        if (this === NerdyElement)\n            return;\n        Object.defineProperty(this, 'is', {\n            value: name,\n        });\n    }\n    static get is() {\n        if (this === NerdyElement)\n            return;\n        return Object.defineProperty(this, 'is', { value: this.name.replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() }) && this.is;\n    }\n    static get template() {\n        if (this === NerdyElement)\n            return;\n        return this.nerdyTemplate && this.nerdyTemplate.template;\n    }\n    ready() {\n        super.ready();\n        if (this.attributes.length)\n            this.setProperties(nerdy_elements_helpers_1.getAttributesObject(this));\n    }\n    connectedCallback() {\n        super.connectedCallback(), typeof this.attached === 'function' && this.attached();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback(), typeof this.detatched === 'function' && this.detatched();\n    }\n    adoptedCallback() {\n        super.adoptedCallback(), typeof this.adopted === 'function' && this.adopted();\n    }\n    attributeChangedCallback(attribute, oldValue, newValue) {\n        super.attributeChangedCallback(attribute, oldValue, newValue), typeof this.attributeChanged === 'function' && this.attributeChanged(attribute, oldValue, newValue);\n    }\n    assign(...values) {\n        return Object.assign(this, ...values);\n    }\n    /**\n     * Goes through each key of the properties parameter and\n     * tries to find the best named property match using the\n     * findPropertyName method.\n     *\n     * @param {{ [name: string]: any }} properties\n     *\n     * @memberOf NerdyElement\n     */\n    setProperties(properties) {\n        for (const name of Object.keys(properties)) {\n            const property = this.findPropertyName(name);\n            if (property)\n                this[property] = properties[name];\n        }\n    }\n    getPropertyNames() {\n        // TODO: we need a better strategy to populate property names\n        return Object.getOwnPropertyNames(this); // Object.keys(this);\n    }\n    findPropertyName(name) {\n        // Abort if passed an invalid name\n        if (typeof name !== 'string' || (name = name.trim()).length === 0)\n            return;\n        // Return property if name exactly matches\n        if (name in this)\n            return name;\n        // Convert name to stripped-lowercased format\n        const simpleName = name.replace(/[\\-\\s]/g, '').toLowerCase();\n        // Return previously matched name using the cached lowercase map\n        if (simpleName in this.propertyLookup)\n            return this.propertyLookup[simpleName];\n        // Prepare to do some introspection\n        const properties = Object.keys(this);\n        // If name is dash cased then do a lowercase match against the dedashed name\n        if (/\\w\\-\\w/.test(name)) {\n            const property = Object.keys(this).find((name, index) => name.toLowerCase() === simpleName);\n            if (property)\n                return (this.propertyLookup[simpleName] = property);\n        }\n        // All basis are covered so we must return undefined because we have no more candidates\n        return (this.propertyLookup[simpleName] = undefined);\n    }\n}\nNerdyElement.elements = {};\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"connectedCallback\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"disconnectedCallback\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"adoptedCallback\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String, Object, Object]),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"attributeChangedCallback\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"assign\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"setProperties\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"getPropertyNames\", null);\n__decorate([\n    decorators_1.enumerable.off,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", void 0)\n], NerdyElement.prototype, \"findPropertyName\", null);\nexports.NerdyElement = NerdyElement;\n(function (NerdyElement) {\n    function isConstructor(object) {\n        return typeof object === 'function' && object.is && typeof object.is === 'string';\n    }\n    NerdyElement.isConstructor = isConstructor;\n})(NerdyElement = exports.NerdyElement || (exports.NerdyElement = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NerdyElement;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nconst DOM = __webpack_require__(6);\nconst bindings_1 = __webpack_require__(15);\nclass NerdyTemplate {\n    constructor(component, template) {\n        this.template = typeof template === 'function' ? template() : template;\n    }\n    static define(component, template) {\n        return new NerdyTemplate(component, template);\n    }\n    static get createElement() { return DOM.createElement; }\n    static get applyAttributes() { return DOM.applyAttributes; }\n    static get insertChildren() { return DOM.insertChildren; }\n}\nexports.NerdyTemplate = NerdyTemplate;\n(function (NerdyTemplate) {\n    NerdyTemplate.PolymerBindingFunction = bindings_1.PolymerTemplateBindingFunction;\n    var BindingFunction;\n    (function (BindingFunction) {\n        BindingFunction.Polymer = NerdyTemplate.PolymerBindingFunction;\n        BindingFunction.create = bindings_1.createTemplateBindingFunction;\n    })(BindingFunction = NerdyTemplate.BindingFunction || (NerdyTemplate.BindingFunction = {}));\n})(NerdyTemplate = exports.NerdyTemplate || (exports.NerdyTemplate = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NerdyTemplate;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n\n(function() {\n\n  'use strict';\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    var handler = function(e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  Polymer.EventListeners = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class EventListeners extends superClass {\n\n      _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        var handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n\n  (function() {\n\n    // path fixup for urls in cssText that's expected to\n    // come from a given ownerDocument\n    function resolveCss(cssText, ownerDocument) {\n      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {\n        return pre + '\\'' +\n          resolve(url.replace(/[\"']/g, ''), ownerDocument) +\n          '\\'' + post;\n      });\n    }\n\n    // url fixup for urls in an element's attributes made relative to\n    // ownerDoc's base url\n    function resolveAttrs(element, ownerDocument) {\n      for (var name in URL_ATTRS) {\n        var a$ = URL_ATTRS[name];\n        for (var i=0, l=a$.length, a, at, v; (i<l) && (a=a$[i]); i++) {\n          if (name === '*' || element.localName === name) {\n            at = element.attributes[a];\n            v = at && at.value;\n            if (v && (v.search(BINDING_RX) < 0)) {\n              at.value = (a === 'style') ?\n                resolveCss(v, ownerDocument) :\n                resolve(v, ownerDocument);\n            }\n          }\n        }\n      }\n    }\n\n    function resolve(url, ownerDocument) {\n      // do not resolve '#' links, they are used for routing\n      if (url && ABS_URL.test(url)) {\n        return url;\n      }\n      var resolver = getUrlResolver(ownerDocument);\n      resolver.href = url;\n      return resolver.href || url;\n    }\n\n    var tempDoc;\n    var tempDocBase;\n    function resolveUrl(url, baseUri) {\n      if (!tempDoc) {\n        tempDoc = document.implementation.createHTMLDocument('temp');\n        tempDocBase = tempDoc.createElement('base');\n        tempDoc.head.appendChild(tempDocBase);\n      }\n      tempDocBase.href = baseUri;\n      return resolve(url, tempDoc);\n    }\n\n    function getUrlResolver(ownerDocument) {\n      return ownerDocument.__urlResolver ||\n        (ownerDocument.__urlResolver = ownerDocument.createElement('a'));\n    }\n\n    var CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n    var URL_ATTRS = {\n      '*': ['href', 'src', 'style', 'url'],\n      form: ['action']\n    };\n    var ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n    var BINDING_RX = /\\{\\{|\\[\\[/;\n\n    // exports\n    Polymer.ResolveUrl = {\n      resolveCss: resolveCss,\n      resolveAttrs: resolveAttrs,\n      resolveUrl: resolveUrl\n    };\n\n  })();\n\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(10);\n\n__webpack_require__(31);\n\n\n(function() {\n\n  'use strict';\n\n  /**\n   * Scans a template to produce an annotation object that stores expression\n   * metadata along with information to associate the metadata with nodes in an\n   * instance.\n   *\n   * Elements with `id` in the template are noted and marshaled into an\n   * the `$` hash in an instance.\n   *\n   * Example\n   *\n   *     &lt;template>\n   *       &lt;div id=\"foo\">&lt;/div>\n   *     &lt;/template>\n   *     &lt;script>\n   *      Polymer({\n   *        task: function() {\n   *          this.$.foo.style.color = 'red';\n   *        }\n   *      });\n   *     &lt;/script>\n   *\n   * Other expressions that are noted include:\n   *\n   * Double-mustache annotations in text content. The annotation must be the only\n   * content in the tag, compound expressions are not (currently) supported.\n   *\n   *     <[tag]>{{path.to.host.property}}<[tag]>\n   *\n   * Double-mustache annotations in an attribute.\n   *\n   *     <[tag] someAttribute=\"{{path.to.host.property}}\"><[tag]>\n   *\n   * Only immediate host properties can automatically trigger side-effects.\n   * Setting `host.path` in the example above triggers the binding, setting\n   * `host.path.to.host.property` does not.\n   *\n   * `on-` style event declarations.\n   *\n   *     <[tag] on-<event-name>=\"{{hostMethodName}}\"><[tag]>\n   *\n   * Note: **the `annotations` feature does not actually implement the behaviors\n   * associated with these expressions, it only captures the data**.\n   *\n   * Other optional features contain actual data implementations.\n   *\n   * @class standard feature: annotations\n   */\n\n  /*\n\n  Scans a template to produce an annotation map that stores expression metadata\n  and information that associates the metadata to nodes in a template instance.\n\n  Supported annotations are:\n\n    * id attributes\n    * binding annotations in text nodes\n      * double-mustache expressions: {{expression}}\n      * double-bracket expressions: [[expression]]\n    * binding annotations in attributes\n      * attribute-bind expressions: name=\"{{expression}} || [[expression]]\"\n      * property-bind expressions: name*=\"{{expression}} || [[expression]]\"\n      * property-bind expressions: name:=\"expression\"\n    * event annotations\n      * event delegation directives: on-<eventName>=\"expression\"\n\n  Generated data-structure:\n\n    [\n      {\n        id: '<id>',\n        events: [\n          {\n            mode: ['auto'|''],\n            name: '<name>'\n            value: '<expression>'\n          }, ...\n        ],\n        bindings: [\n          {\n            kind: ['text'|'attribute'|'property'],\n            mode: ['auto'|''],\n            name: '<name>'\n            value: '<expression>'\n          }, ...\n        ],\n        // TODO(sjmiles): confusingly, this is annotation-parent, not node-parent\n        parent: <reference to parent annotation>,\n        index: <integer index in parent's childNodes collection>\n      },\n      ...\n    ]\n\n  TODO(sjmiles): this module should produce either syntactic metadata\n  (e.g. double-mustache, double-bracket, star-attr), or semantic metadata\n  (e.g. manual-bind, auto-bind, property-bind). Right now it's half and half.\n\n  */\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, dom, note) {\n    if (note.id) {\n      map[note.id] = inst._findTemplateAnnotatedNode(dom, note);\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, dom, note, host) {\n    if (note.events && note.events.length) {\n      var node = inst._findTemplateAnnotatedNode(dom, note);\n      for (var j=0, e$=note.events, e; (j<e$.length) && (e=e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, host);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, dom, note) {\n    if (note.templateContent) {\n      var node = inst._findTemplateAnnotatedNode(dom, note);\n      node._content = note.templateContent;\n    }\n  }\n\n  Polymer.TemplateStamp = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    const mixin = Polymer.Annotations(Polymer.EventListeners(superClass));\n    return class TemplateStamp extends mixin {\n\n      constructor() {\n        super();\n        this.$ = null;\n      }\n\n      _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content &&\n            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        var notes = this._parseTemplateAnnotations(template);\n        var dom = document.importNode(template._content || template.content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !notes._hasInsertionPoint;\n        this.$ = {};\n        for (var i=0, l=notes.length, note; (i<l) && (note=notes[i]); i++) {\n          applyIdToMap(this, this.$, dom, note);\n          applyTemplateContent(this, dom, note);\n          applyEventListener(this, dom, note, this);\n        }\n        return dom;\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    __webpack_require__(14);\n\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst nerdy_components_1 = __webpack_require__(21);\nlet HelloWorld = HelloWorld_1 = class HelloWorld extends nerdy_components_1.NerdyElement {\n    constructor() {\n        super(...arguments);\n        this.counter = (this.constructor.counter = (this.constructor.counter || 0) + 1);\n    }\n    static get nerdyTemplate() {\n        return nerdy_components_1.NerdyTemplate.define(HelloWorld_1, ($ = nerdy_components_1.BindingFunction.Polymer) => (nerdy_components_1.createElement(\"template\", { class: \"class\", id: 'hello-world-component-nerdy-template' },\n            nerdy_components_1.createElement(\"h1\", { id: $ `id`, onclick: $ `clickHandler` },\n                this.name,\n                \" \",\n                $ `counter`),\n            nerdy_components_1.createElement(\"pre\", null,\n                nerdy_components_1.createElement(\"b\", null, \"> \"),\n                $ `message`))));\n    }\n    static test() {\n        const className = this.name, tagName = this.is, container = document.createElement('div');\n        container.appendChild(nerdy_components_1.createElement(\"pre\", { style: \"background: rgb(255, 192, 0); display: block; padding: 1em; border-radius: 0.25em;\" }, \"This has only been reliably tested in Chrome (56.0.2924.87)\"));\n        container.innerHTML = container.innerHTML + `<${tagName} message=\"this element was created by appending <${tagName} ...></${tagName}> to a <div></div>\"></${tagName}>`;\n        const elements = {\n            declared: container.getElementsByTagName(tagName)[0],\n            transpiled: nerdy_components_1.createElement(this, { message: `this element was transpiled from tsx using <${className} ...></${className}>` }),\n            created: Object.assign(document.createElement(tagName), { message: `this element was created by calling document.createElement('${tagName}')` }),\n            constructed: (new this()).assign({ message: `this element was created by calling new ${className}()` }),\n        };\n        console.info(`${className}::test()`, {\n            '[class.constructor]': this, '[class.prototype]': this.prototype,\n            '[element.prototype]': window.customElements.get(tagName),\n            '[elements]': elements,\n        });\n        for (const key of Object.keys(elements))\n            if (elements[key] instanceof HTMLElement)\n                container.appendChild(elements[key]); // if (elements[key])\n        document.body.appendChild(container);\n    }\n    attached() {\n        console.log(`${this.constructor.name}#attached()!`, this);\n    }\n    clickHandler() {\n        console.log(`${this.constructor.name}#clickHandler`, { arguments, this: this }, this);\n    }\n};\nHelloWorld.counter = 0;\nHelloWorld = HelloWorld_1 = __decorate([\n    nerdy_components_1.customElement\n], HelloWorld);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = HelloWorld;\nHelloWorld.test();\nvar HelloWorld_1;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(3));\n__export(__webpack_require__(4));\nconst NerdyBinding = __webpack_require__(3);\nexports.NerdyBinding = NerdyBinding;\nconst PolymerBinding = __webpack_require__(4);\nexports.PolymerBinding = PolymerBinding;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NerdyBinding;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction customElement(argument) {\n    let tagName = typeof argument === 'string' ? argument : undefined;\n    if (typeof argument === 'function')\n        customElement.registerElement(tagName = customElement.getTagName(argument), argument);\n    else\n        return (constructor) => customElement.registerElement(tagName, constructor);\n}\nexports.customElement = customElement;\n(function (customElement) {\n    function getTagName(constructor) {\n        if (typeof constructor['is'] === 'string' && constructor['is'].trim().length)\n            constructor['is'].trim();\n        if (typeof constructor.name === 'string' && constructor.name.trim().length)\n            return constructor.name.trim().replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n        throw new Error(`Cannot getTagName from the '${constructor.name}' constructor since it does not have the 'is' property defined`);\n    }\n    customElement.getTagName = getTagName;\n    function registerElement(tagName, constructor) {\n        if (window.customElements.get(tagName))\n            throw new Error(`Cannot auto-register custome element since the name ${tagName} is already defined`);\n        window.customElements.define(tagName, constructor);\n        console.info('@customElement::registerElement', { tagName, constructor });\n    }\n    customElement.registerElement = registerElement;\n})(customElement = exports.customElement || (exports.customElement = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = customElement;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @enumerable decorator that sets the enumerable property of a class field to false.\n * @param value true|false\n */\nfunction enumerable(value) {\n    return (target, property) => {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property) || {};\n        // tslint:disable-next-line:triple-equals\n        if (descriptor.enumerable != value)\n            Object.defineProperty(target, property, Object.assign({}, descriptor, { enumerable: (value = !!value) }));\n        // console.info('@enumerable', { target, property, enumerable: value });\n    };\n}\nexports.enumerable = enumerable;\n(function (enumerable) {\n    enumerable.off = enumerable(false);\n    enumerable.on = enumerable(true);\n})(enumerable = exports.enumerable || (exports.enumerable = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = enumerable;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(8));\nconst nerdy_element_1 = __webpack_require__(8);\nexports.isConstructor = nerdy_element_1.default.isConstructor;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = nerdy_element_1.default;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction getAttributesObject(source) {\n    const attributes = source && ((source instanceof NamedNodeMap && source) || (source instanceof HTMLElement && source.attributes));\n    return attributes ? Array.from(attributes).reduce((object, attribute) => (object[attribute.name] = attribute.value, object), {}) : undefined;\n}\nexports.getAttributesObject = getAttributesObject;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/// <reference path= '../@types/polymer.d.ts' />\nif (window) {\n    let goog = window.goog = window.goog || {};\n    let reflect = goog.reflect = goog.reflect || {};\n    reflect.objectProperty = (s, o) => s;\n    // TODO: Figure out how to link import polymer before loading component\n    // tslint:disable-next-line:no-var-requires\n    __webpack_require__(23);\n}\n;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(5));\n__export(__webpack_require__(6));\n__export(__webpack_require__(22));\n__export(__webpack_require__(18));\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(9));\nconst nerdy_template_1 = __webpack_require__(9);\nexports.BindingFunction = nerdy_template_1.default.BindingFunction;\nexports.PolymerBindingFunction = nerdy_template_1.default.PolymerBindingFunction;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = nerdy_template_1.default;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(25);\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(2);\n\n\n(function() {\n\n  'use strict';\n\n  var caseMap = Polymer.CaseMap;\n\n  Polymer.Attributes = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    /**\n     * @unrestricted\n     */\n    class Attributes extends superClass {\n\n      constructor() {\n        super();\n        this.__serializing = false;\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       *\n       * @method _ensureAttribute\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       */\n      _ensureAttribute(attribute, value) {\n        if (!this.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(this, value, attribute);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeAttribute` method to convert the string to\n       * a typed value.\n       *\n       * @method _attributeToProperty\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {string} value of the attribute.\n       * @param {*} type type to deserialize to.\n       */\n      _attributeToProperty(attribute, value, type) {\n        // Don't deserialize back to property if currently reflecting\n        if (!this.__serializing) {\n          var property = caseMap.dashToCamelCase(attribute);\n          this[property] = this._deserializeAttribute(value, type);\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @method _propertyToAttribute\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to refect.\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = (arguments.length < 3) ? this[property] : value;\n        this._valueToNodeAttribute(this, value,\n          attribute || caseMap.camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeAttribute` method to convert the typed\n       * value to a string.  If the `_serializeAttribute` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @method _valueToNodeAttribute\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        var str = this._serializeAttribute(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed value to a string.\n       *\n       * This method is called by Polymer when setting JS property values to\n       * HTML attributes.  Users may override this method on Polymer element\n       * prototypes to provide serialization for custom types.\n       *\n       * @method _serializeAttribute\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n      _serializeAttribute(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch(x) {\n                return '';\n              }\n            }\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       * Note: The return value of `undefined` is used as a sentinel value to\n       * indicate the attribute should be removed.\n       *\n       * @method _deserializeAttribute\n       * @param {string} value Attribute value to deserialize.\n       * @param {*} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeAttribute(value, type) {\n        /**\n         * @type {*}\n         */\n        let outValue;\n        switch (type) {\n          case Number:\n            outValue = Number(value);\n            break;\n\n          case Boolean:\n            outValue = (value !== null);\n            break;\n\n          case Object:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              // allow non-JSON literals like Strings and Numbers\n            }\n            break;\n\n          case Array:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              outValue = null;\n              console.warn('Polymer::Attributes: couldn`t decode Array as JSON');\n            }\n            break;\n\n          case Date:\n            outValue = new Date(value);\n            break;\n\n          case String:\n          default:\n            outValue = value;\n            break;\n        }\n\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n    }\n\n    return Attributes;\n  });\n\n\n})();\n\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(26);\n\n__webpack_require__(2);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(28);\n\n__webpack_require__(29);\n\n__webpack_require__(30);\n\n\n(function() {\n\n  'use strict';\n\n  let caseMap = Polymer.CaseMap;\n\n  // Same as Polymer.Utils.mixin, but upgrades shorthand type\n  // syntax to { type: Type }\n  function flattenProperties(flattenedProps, props) {\n    for (let p in props) {\n      let o = props[p];\n      if (typeof o == 'function') {\n        o = { type: o };\n      }\n      flattenedProps[p] = o;\n    }\n    return flattenedProps;\n  }\n\n  Polymer.ElementMixin = Polymer.Utils.dedupingMixin(function(base) {\n\n    const mixin = Polymer.PropertyEffects(base);\n\n    /**\n     * @unrestricted\n     */\n    class PolymerElement extends mixin {\n\n      // returns the config object on specifically on `this` class (not super)\n      // config is used for:\n      // (1) super chain mixes togther to make `flattenedProperties` which is\n      // then used to make observedAttributes and set property defaults\n      // (2) properties effects and observers are created from it at `finalize` time.\n      static get _ownConfig() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('__ownConfig', this))) {\n          this.__ownConfig = this.hasOwnProperty(goog.reflect.objectProperty('config', this)) ? this.config : {};\n        }\n        return this.__ownConfig;\n      }\n\n      // a flattened list of properties mixed together from the chain of all\n      // constructor's `config.properties`\n      // This list is used to create\n      // (1) observedAttributes,\n      // (2) element default values\n      static get _flattenedProperties() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('__flattenedProperties', this))) {\n          // TODO(sorvell): consider optimizing; shorthand type support requires\n          // an extra loop to upgrade shorthand property info to longhand\n          this.__flattenedProperties = flattenProperties({}, this._ownConfig.properties);\n          let superCtor = Object.getPrototypeOf(this.prototype).constructor;\n          if (superCtor.prototype instanceof PolymerElement) {\n            this.__flattenedProperties = flattenProperties(\n              Object.create(superCtor._flattenedProperties),\n              this.__flattenedProperties);\n          }\n        }\n        return this.__flattenedProperties;\n      }\n\n      static get _flattenedPropertyDefaults() {\n        if (!this.hasOwnProperty('__flattenedPropertyDefaults')) {\n          this.__flattenedPropertyDefaults = null;\n          for (let p in this._flattenedProperties) {\n            let info = this._flattenedProperties[p];\n            if ('value' in info) {\n              this.__flattenedPropertyDefaults =\n                this.__flattenedPropertyDefaults || {};\n              this.__flattenedPropertyDefaults[p] = info;\n            }\n          }\n        }\n        return this.__flattenedPropertyDefaults;\n      }\n\n\n\n      static get observedAttributes() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('_observedAttributes', this))) {\n          // observedAttributes must be finalized at registration time\n          this._observedAttributes = this._addPropertiesToAttributes(\n            this._flattenedProperties, []);\n        }\n        return this._observedAttributes;\n      }\n\n      static _addPropertiesToAttributes(properties, list) {\n        for (let prop in properties) {\n          list.push(Polymer.CaseMap.camelToDashCase(prop));\n        }\n        return list;\n      }\n\n      static get finalized() {\n        return this.hasOwnProperty(goog.reflect.objectProperty('_finalized', this));\n      }\n\n      static set finalized(value) {\n        this._finalized = value;\n      }\n\n      // TODO(sorvell): need to work on public api surrouding `finalize`.\n      // Due to meta-programming, it's awkward to make a subclass impl of this.\n      // However, a user might want to call `finalize` prior to define to do\n      // this work eagerly. Need to also decide on `finalizeConfig(config)` and\n      // `finalizeTemplate(template)`. Both are public but have simiarly\n      // awkward subclassing characteristics.\n      static finalize() {\n        let proto = this.prototype;\n        if (!this.finalized) {\n\n          let superProto = Object.getPrototypeOf(proto);\n          let superCtor = superProto && superProto.constructor;\n          if (superCtor.prototype instanceof PolymerElement) {\n            superCtor.finalize();\n          }\n          this.finalized = true;\n          if (this.hasOwnProperty(goog.reflect.objectProperty('is', this)) && this.is) {\n            Polymer.telemetry.register(proto);\n          }\n          let config = this._ownConfig;\n          if (config) {\n            this._finalizeConfig(config);\n          }\n          if (this.template) {\n            this._finalizeTemplate(this.template.cloneNode(true));\n          }\n        }\n      }\n\n      static _finalizeConfig(config) {\n        if (config.properties) {\n          // process properties\n          for (let p in config.properties) {\n            this.prototype._createPropertyFromConfig(p, config.properties[p]);\n          }\n        }\n        if (config.observers) {\n          for (let i=0; i < config.observers.length; i++) {\n            this.prototype._createMethodObserver(config.observers[i]);\n          }\n        }\n      }\n\n      static _getTemplate() {\n        return Polymer.DomModule.import(this.is, 'template');\n      }\n\n      static get template() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('_template', this))) {\n          this._template = this._getTemplate() ||\n            // note: implemented so a subclass can retrieve the super\n            // template; call the super impl this way so that `this` points\n            // to the superclass.\n            Object.getPrototypeOf(this.prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      static _finalizeTemplate(template) {\n        // support `include=\"module-name\"`\n        let cssText = Polymer.StyleGather.cssFromElement(template);\n        if (cssText) {\n          let style = document.createElement('style');\n          style.textContent = cssText;\n          template.content.insertBefore(style, template.content.firstChild);\n        }\n        if (window.ShadyCSS) {\n          window.ShadyCSS.prepareTemplate(template, this.is, this.extends);\n        }\n        var proto = this.prototype;\n        this.prototype._bindTemplate(template);\n        proto._template = template;\n      }\n\n      constructor() {\n        super();\n        // note: `this.constructor.prototype` is wrong in Safari so make sure to\n        // use `__proto__`\n        Polymer.telemetry.instanceCount++;\n        // add self to host's pending client list\n        hostStack.registerHost(this);\n      }\n\n      _initializeProperties() {\n        if (!this.constructor.finalized) {\n          this.constructor.finalize();\n        }\n        super._initializeProperties();\n        // apply property defaults...\n        let p$ = this.constructor._flattenedPropertyDefaults;\n        if (!p$) {\n          return;\n        }\n        for (let p in p$) {\n          let info = p$[p];\n          if (!this._isPropertyPending(p)) {\n            var value = typeof info.value == 'function' ?\n              info.value.call(this) :\n              info.value;\n            if (this._hasReadOnlyEffect(p)) {\n              this._setProperty(p, value)\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Creates effects for a property.\n       *\n       * Example:\n       *\n       *     this._createPropertyFromConfig('foo', {\n       *       type: String, value: 'foo', reflectToAttribute: true\n       *     });\n       *\n       * Note, once a property has been set to\n       * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n       * these values may not be changed. For example, a subclass cannot\n       * alter these settings. However, additional `observers` may be added\n       * by subclasses.\n       *\n       * @param {string} name Name of the property.\n       * @param {*=} info Info object from which to create property effects.\n       * Supported keys:\n       *\n       * * type: {function} type to which an attribute matching the property\n       * is deserialized. Note the property is camel-cased from a dash-cased\n       * attribute. For example, 'foo-bar' attribute is dersialized to a\n       * property named 'fooBar'.\n       *\n       * * readOnly: {boolean} creates a readOnly property and\n       * makes a private setter for the private of the form '_setFoo' for a\n       * property 'foo',\n       *\n       * * computed: {string} creates a computed property. A computed property\n       * also automatically is set to `readOnly: true`. The value is calculated\n       * by running a method and arguments parsed from the given string. For\n       * example 'compute(foo)' will compute a given property when the\n       * 'foo' property changes by executing the 'compute' method. This method\n       * must return the computed value.\n       *\n       * * reflectToAttriute: {boolean} If true, the property value is reflected\n       * to an attribute of the same name. Note, the attribute is dash-cased\n       * so a property named 'fooBar' is reflected as 'foo-bar'.\n       *\n       * * notify: {boolean} sends a non-bubbling notification event when\n       * the property changes. For example, a property named 'foo' sends an\n       * event named 'foo-changed' with `event.detail` set to the value of\n       * the property.\n       *\n       * * observer: {string} name of a method that runs when the property\n       * changes. The arguments of the method are (value, previousValue).\n       *\n      */\n      /* TODO(sorvell): Users may want control over modifying property\n       effects via subclassing. For example, a user might want to make a\n       reflectToAttribute property not do so in a subclass. We've chosen to\n       disable this because it leads to additional complication.\n       For example, a readOnly effect generates a special setter. If a subclass\n       disables the effect, the setter would fail unexpectedly.\n       Based on feedback, we may want to try to make effects more malleable\n       and/or provide an advanced api for manipulating them.\n       Also consider adding warnings when an effect cannot be changed.\n      */\n      _createPropertyFromConfig(name, info) {\n        // computed forces readOnly...\n        if (info.computed) {\n          info.readOnly = true;\n        }\n        // Note, since all computed properties are readOnly, this prevents\n        // adding additional computed property effects (which leads to a confusing\n        // setup where multiple triggers for setting a property)\n        // While we do have `hasComputedEffect` this is set on the property's\n        // dependencies rather than itself.\n        if (info.computed  && !this._hasReadOnlyEffect(name)) {\n          this._createComputedProperty(name, info.computed);\n        }\n        if (info.readOnly && !this._hasReadOnlyEffect(name)) {\n          this._createReadOnlyProperty(name, !info.computed);\n        }\n        if (info.reflectToAttribute && !this._hasReflectEffect(name)) {\n          this._createReflectedProperty(name);\n        }\n        if (info.notify && !this._hasNotifyEffect(name)) {\n          this._createNotifyingProperty(name);\n        }\n        // always add observer\n        if (info.observer) {\n          this._createObservedProperty(name, info.observer);\n        }\n      }\n\n      // reserved for canonical behavior\n      connectedCallback() {\n        this.updateStyles();\n        if (hostStack.isEmpty()) {\n          // note, this should never recurse to root elements; this will\n          // need new ShadyCSS api\n          // (see https://github.com/webcomponents/shadycss/issues/42)\n          this._flushProperties();\n        }\n      }\n\n      disconnectedCallback() {}\n\n      ready() {\n        super.ready();\n        if (this._template) {\n          hostStack.beginHosting(this);\n          this.root = this._stampTemplate(this._template);\n          this._flushProperties();\n          this.root = this._attachDom(this.root);\n          hostStack.endHosting(this);\n        } else {\n          this.root = this;\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Attach an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @method _attachDom\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {NodeList} dom to attach to the element.\n       * @return {Node} node to which the dom has been attached.\n       */\n      _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({mode: 'open'});\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n        } else {\n          throw new Error(`ShadowDOM not available. ` +\n            // BREAKME(sorvell): move to developer conditional when supported.\n           `Polymer.Element can\n              create dom as children instead of in ShadowDOM by setting\n              \\`this.root = this;\\` before \\`ready\\`.`);\n\n        }\n      }\n\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          let property = caseMap.dashToCamelCase(name);\n          let type = this.constructor._flattenedProperties[property].type;\n          if (!this._hasReadOnlyEffect(property)) {\n            this._attributeToProperty(name, value, type);\n          }\n        }\n      }\n\n      /**\n       * Update styling for this element\n       *\n       * @param {Object=} properties\n       *  Override styling with an object of properties where the keys are css properties, and the values are strings\n       *  Example: `this.updateStyles({'color': 'blue'})`\n       *  These properties are retained unless a value of `null` is set.\n       */\n      updateStyles(properties) {\n        if (window.ShadyCSS) {\n          ShadyCSS.applyStyle(this, properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to the original location of the document\n       * containing the `dom-module` for this element.  This method will return\n       * the same URL before and after vulcanization.\n       *\n       * @method resolveUrl\n       * @param {string} url URL to resolve.\n       * @return {string} Rewritten URL relative to the import\n       */\n      resolveUrl(url) {\n        var module = Polymer.DomModule.import(this.constructor.is);\n        var root = '';\n        if (module) {\n          root = Polymer.ResolveUrl.resolveUrl(\n            module.assetpath, module.ownerDocument.baseURI);\n        }\n        return Polymer.ResolveUrl.resolveUrl(url, root);\n      }\n\n    }\n\n    return PolymerElement;\n  });\n\n  let hostStack = {\n\n    stack: [],\n\n    isEmpty() {\n      return !this.stack.length;\n    },\n\n    registerHost(inst) {\n      if (this.stack.length) {\n        let host = this.stack[this.stack.length-1];\n        host._enqueueClient(inst);\n      }\n    },\n\n    beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n    endHosting(inst) {\n      let stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen-1] == inst) {\n        this.stack.pop();\n      }\n    }\n\n  }\n\n  // telemetry\n  Polymer.telemetry = {\n    instanceCount: 0,\n    registrations: [],\n    _regLog: function(prototype) {\n      console.log('[' + prototype.is + ']: registered')\n    },\n    register: function(prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    dumpRegistrations: function() {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  Polymer.Element = Polymer.ElementMixin(HTMLElement);\n\n  Polymer.updateStyles = function(props) {\n    if (window.ShadyCSS) {\n      ShadyCSS.updateStyles(props);\n    }\n  };\n\n})();\n\n\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n\n\n(function() {\n\n  var modules = {};\n  var lcModules = {};\n  var findModule = function(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  };\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via any dom-module element. Use the `import(id, selector)`\n   * method to locate dom within this database. For example,\n   *\n   * <dom-module id=\"foo\">\n   *   <img src=\"stuff.png\">\n   * </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   * var img = document.createElement('dom-module').import('foo', 'img');\n   *\n   */\n  class DomModule extends HTMLElement {\n\n    static get observedAttributes() { return ['id'] }\n\n    attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    _styleOutsideTemplateCheck() {\n      if (this.querySelector('style')) {\n        console.warn('dom-module %s has style outside template', this.id);\n      }\n    }\n\n    get assetpath() {\n      let assetpath = this.__assetpath || this.getAttribute('assetpath');\n      // Don't override existing assetpath.\n      if (assetpath) {}\n      // Polyfilled import.\n      else if (window.HTMLImports && !HTMLImports.useNative &&\n        HTMLImports.importForElement) {\n        const imp = HTMLImports.importForElement(this);\n        assetpath = imp ? imp.href : '';\n      }\n      // Native import.\n      else if (this.ownerDocument !== document && this.baseURI) {\n        assetpath = this.baseURI;\n      }\n      // Memoize.\n      this.__assetpath = assetpath;\n      return assetpath;\n    }\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @method register\n     * @param {string=} id The id at which to register the dom-module.\n     */\n    register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        this._styleOutsideTemplateCheck();\n      }\n    }\n\n    /**\n     * Retrieves the dom specified by `selector` in the module specified by\n     * `id`. For example, this.import('foo', 'img');\n     * @method register\n     * @param {string} id\n     * @param {string=} selector\n     * @return {Element} Returns the dom which matches `selector` in the module\n     * at the specified `id`.\n     */\n    import(id, selector) {\n      if (id) {\n        var m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n\n  }\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = new DomModule();\n\n})();\n\n\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n\n(function() {\n\n  'use strict';\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = HTMLElement.prototype;\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i=0; i<props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(goog.reflect.objectProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  Polymer.PropertyAccessors = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class PropertyAccessors extends superClass {\n\n      constructor() {\n        super();\n        this._initializeProperties();\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Override to initialize with e.g. default values by setting values into\n       * accessors.\n       *\n       * @protected\n       */\n      _initializeProperties() {\n        this.__data = {};\n        this.__dataCounter = 0;\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this.__dataInvalid = false;\n      }\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.  When calling on\n       * a prototype, any overwritten values are saved in `__dataProto`,\n       * and it is up to the subclasser to decide how/when to set those\n       * properties back into the accessor.  When calling on an instance,\n       * the overwritten value is set via `_setPendingProperty`, and the\n       * user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        Object.defineProperty(this, property, {\n          get: function() {\n            return this.__data && this.__data[property];\n          },\n          set: readOnly ? function() { } : function(value) {\n            this._setProperty(property, value);\n          }\n        });\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setPendingProperty(property, value) {\n        let old = this.__data[property];\n        if (this._shouldPropertyChange(property, value, old)) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n      _isPropertyPending(prop) {\n        return this.__dataPending && (prop in this.__dataPending);\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid) {\n          this.__dataInvalid = true;\n          Promise.resolve().then(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes.\n       *\n       * @protected\n       */\n      _flushProperties() {\n        let oldProps = this.__dataOld;\n        let changedProps = this.__dataPending;\n        this.__dataPending = null;\n        this.__dataCounter++;\n        this._propertiesChanged(this.__data, changedProps, oldProps);\n        this.__dataCounter--;\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {Object} currentProps Bag of all current accessor values\n       * @param {Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` for primitive types if a\n       * strict equality check fails, and returns `true` for all Object/Arrays.\n       * The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property\n       * @param {*} value\n       * @param {*} old\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check for primitives\n          (old !== value &&\n           // This ensures (old==NaN, value==NaN) always returns false\n           (old === old || value === value))\n        );\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(32);\n\n__webpack_require__(27);\n\n__webpack_require__(24);\n\n__webpack_require__(2);\n\n__webpack_require__(12);\n\n\n(function() {\n\n  'use strict';\n\n  const CaseMap = Polymer.CaseMap;\n  const mixin = Polymer.Utils.mixin;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  let dedupeId = 0;\n\n  // Property effect types; effects are stored on the prototype using these keys\n  const TYPES = {\n    ANY: '__propertyEffects',\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n  }\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    let effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (let p in effects) {\n        // TODO(kschaaf): replace with fast array copy #!%&$!\n        effects[p] = effects[p].slice();\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {string} type Type of effect to run\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, fromAbove, hasPaths) {\n    if (effects) {\n      let ran;\n      let id = dedupeId++;\n      for (let prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, fromAbove, hasPaths)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Array} effects Array of effects\n   * @param {number} id Effect run id used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} value Value of changed property\n   * @param {*} old Previous value of changed property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, fromAbove, hasPaths) {\n    let ran;\n    // TODO(kschaaf) ideally a system exists to parse path information once\n    // and send structured information through the system for better perf\n    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    let fxs = effects[rootProperty];\n    if (fxs) {\n      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n            (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          fx.fn(inst, prop, props, oldProps, fx.info, fromAbove, hasPaths);\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {Object} trigger Descriptor \n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      let triggerPath = trigger.name;\n      return (triggerPath == path) ||\n        (trigger.structured && Polymer.Path.isAncestor(triggerPath, path)) ||\n        (trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path));\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    let fn = inst[info.methodName];\n    if (fn) {\n      fn.call(inst, inst.__data[property], oldProps[property]);\n    } else {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {Element} inst The instance with effects to run\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @private\n   */\n  function runNotifyEffects(inst, props, oldProps, fromAbove, hasPaths) {\n    // Notify\n    let fxs = inst.__notifyEffects;\n    if (fxs || hasPaths) {\n      let notified;\n      let id = dedupeId++;\n      // Try normal notify effects; if none, fall back to try path notification\n      for (let prop in props) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, fromAbove, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n      // Flush host if we actually notified and host was batching\n      let host;\n      if (notified && (host = inst.__dataHost) && host._flushProperties) {\n        host._flushProperties();\n      }\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {*} value\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    let rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    let detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    inst.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, fromAbove, hasPaths) {\n    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    let path = rootProperty != property ? property : null;\n    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property];  // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {Object} inst Host element instance to handle notification event\n   * @param {Object} info Listener metadata stored via addAnnotatedListener\n   * @private\n   */\n  function addNotifyListener(node, inst, info) {\n    node.addEventListener(info.event, function(e) {\n      handleNotification(e, inst, info.property, info.path, info.negate);\n    });\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `_bindListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {Event} e Notification event (e.g. '<property>-changed')\n   * @param {Object} inst Host element instance handling the notification event\n   * @param {string} property Child element property that was bound\n   * @param {string} path Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(e, inst, property, path, negate) {\n    let value;\n    let targetPath = e.detail && e.detail.path;\n    if (targetPath) {\n      path = Polymer.Path.translate(property, path, targetPath);\n      value = e.detail && e.detail.value;\n    } else {\n      value = e.target[property];\n    }\n    value = negate ? !value : value;\n    setPropertyFromNotification(inst, path, value, e);\n  }\n\n  /**\n   * Called by 2-way binding notification event listeners to set a property\n   * or path to the host based on a notification from a bound child.\n   *\n   * @param {string} path Path on this instance to set\n   * @param {*} value Value to set to given path\n   * @protected\n   */\n  function setPropertyFromNotification(inst, path, value, event) {\n    let detail = event.detail;\n    if (detail && detail.queueProperty) {\n      if (!inst.__readOnly || !inst.__readOnly[path]) {\n        inst._setPendingPropertyOrPath(path, value, Boolean(detail.path));\n      }\n    } else {\n      inst.set(path, value);\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    let value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @return {Object | null | undefined} Bag of newly computed properties from \"computed\" effects\n   */\n  function runComputedEffects(inst, changedProps, oldProps, fromAbove, hasPaths) {\n    let computeEffects = inst.__computeEffects;\n    if (computeEffects) {\n      let inputProps = changedProps;\n      let computedProps;\n      while (runEffects(inst, computeEffects, inputProps, fromAbove, hasPaths)) {\n        mixin(oldProps, inst.__dataOld);\n        mixin(changedProps, inst.__dataPending);\n        computedProps = mixin(computedProps || {}, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n      return computedProps;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    var result = runMethodEffect(inst, property, props, oldProps, info);\n    var computedProp = info.methodInfo;\n    if (inst.__propertyEffects && inst.__propertyEffects[computedProp]) {\n      inst._setPendingProperty(computedProp, result);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {Element} inst The instance whose props are changing\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object | undefined} computedProps Bag of properties newly computed this turn\n   *   via \"computed\" effects; any linked paths generated via this method\n   *   will be added both to the set of `changedProps` as well as to the\n   *   set of `computedProps`; this is because the `fromAbove: true` case will\n   *   notify only from the `computedProps` bag.\n   * @return {Object | undefined}\n   * @private\n   */\n  function computeLinkedPaths(inst, changedProps, computedProps, hasPaths) {\n    let links;\n    if (hasPaths && (links = inst.__dataLinkedPaths)) {\n      const cache = inst.__dataTemp;\n      computedProps = computedProps || {};\n      let link;\n      for (let a in links) {\n        let b = links[a];\n        for (let path in changedProps) {\n          if (Polymer.Path.isDescendant(a, path)) {\n            link = Polymer.Path.translate(a, b, path);\n            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];\n          } else if (Polymer.Path.isDescendant(b, path)) {\n            link = Polymer.Path.translate(b, a, path);\n            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];\n          }\n        }\n      }\n    }\n    return computedProps;\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds \"binding\" property effects for the template annotation\n   * (\"note\" for short) and node index specified.  These may either be normal\n   * \"binding\" effects (property/path bindings) or \"method binding\"\n   * effects, aka inline computing functions, depending on the type of binding\n   * detailed in the note.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {Object} note Annotation note returned from Annotator\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   note applies to\n   * @private\n   */\n  function addBindingEffect(model, note, index) {\n    for (let i=0; i<note.parts.length; i++) {\n      let part = note.parts[i];\n      if (part.signature) {\n        addMethodBindingEffect(model, note, part, index);\n      } else if (!part.literal) {\n        if (note.kind === 'attribute' && note.name[0] === '-') {\n          console.warn('Cannot set attribute ' + note.name +\n            ' because \"-\" is not a valid attribute starting character');\n        } else {\n          model._addPropertyEffect(Polymer.Path.root(part.value), TYPES.PROPAGATE, {\n            fn: runBindingEffect,\n            info:  {\n              kind: note.kind,\n              index: index,\n              name: note.name,\n              propertyName: note.propertyName,\n              value: part.value,\n              isCompound: note.isCompound,\n              compoundIndex: part.compoundIndex,\n              event: part.event,\n              customEvent: part.customEvent,\n              negate: part.negate\n            }\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, fromAbove, hasPaths) {\n    let value;\n    let node = inst.__dataNodes[info.index];\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && (path.length > info.value.length) &&\n        (info.kind == 'property') && !info.isCompound &&\n        node.__propertyEffects && node.__propertyEffects[info.name]) {\n      let value = props[path];\n      path = Polymer.Path.translate(info.value, info.name, path);\n      if (node._setPendingPropertyOrPath(path, value, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      // Root or deeper path was set; extract bound path value\n      // e.g.: foo=\"{{obj.sub}}\", path: 'obj', set 'foo'=obj.sub\n      //   or: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo'=obj.sub\n      if (path != info.value) {\n        value = Polymer.Path.get(inst, info.value);\n      } else {\n        if (hasPaths && Polymer.Path.isPath(path)) {\n          value = Polymer.Path.get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      // Propagate value to child\n      applyBindingValue(inst, info, value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {Object} inst The instance owning the binding effect\n   * @param {Object} info Effect metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, info, value) {\n    let node = inst.__dataNodes[info.index];\n    value = computeBindingValue(node, value, info);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.name, info.kind, node);\n    }\n    if (info.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute(node, value, info.name);\n    } else {\n      // Property binding\n      let prop = info.name;\n      if (node.__propertyEffects && node.__propertyEffects[prop]) {\n        if (!node.__readOnly || !node.__readOnly[prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else  {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {Object} info Effect metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, info) {\n    if (info.negate) {\n      value = !value;\n    }\n    if (info.isCompound) {\n      let storage = node.__dataCompoundStorage[info.name];\n      storage[info.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (info.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (info.name === 'textContent' ||\n          (node.localName == 'input' && info.name == 'value')) {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Adds \"binding method\" property effects for the template binding\n   * (\"note\" for short), part metadata, and node index specified.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {Object} note Binding note returned from Annotator\n   * @param {Object} part The compound part metadata\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   note applies to\n   * @private\n   */\n  function addMethodBindingEffect(model, note, part, index) {\n    createMethodEffect(model, part.signature, TYPES.PROPAGATE,\n      runMethodBindingEffect, {\n        index: index,\n        isCompound: note.isCompound,\n        compoundIndex: part.compoundIndex,\n        kind: note.kind,\n        name: note.name,\n        negate: part.negate,\n        part: part\n      }, true\n    );\n  }\n\n  /**\n   * Implements the \"binding method\" (inline computed function) effect.\n   *\n   * Runs the method with the values of the arguments specified in the `info`\n   * object and setting the return value to the node property/attribute.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runMethodBindingEffect(inst, property, props, oldProps, info) {\n    let val = runMethodEffect(inst, property, props, oldProps, info);\n    applyBindingValue(inst, info.methodInfo, val);\n  }\n\n  /**\n   * Post-processes template bindings (notes for short) provided by the\n   * Bindings library for use by the effects system:\n   * - Parses bindings for methods into method `signature` objects\n   * - Memoizes the root property for path bindings\n   * - Recurses into nested templates and processes those templates and\n   *   extracts any host properties, which are set to the template's\n   *   `_content._hostProps`\n   * - Adds bindings from the host to <template> elements for any nested\n   *   template's lexically bound \"host properties\"; template handling\n   *   elements can then add accessors to the template for these properties\n   *   to forward host properties into template instances accordingly.\n   *\n   * @param {Array<Object>} notes List of notes to process; the notes are\n   *   modified in place.\n   * @private\n   */\n  function processAnnotations(notes) {\n    if (!notes._processed) {\n      for (let i=0; i<notes.length; i++) {\n        let note = notes[i];\n        // Parse bindings for methods & path roots (models)\n        for (let j=0; j<note.bindings.length; j++) {\n          let b = note.bindings[j];\n          for (let k=0; k<b.parts.length; k++) {\n            let p = b.parts[k];\n            if (!p.literal) {\n              p.signature = parseMethod(p.value);\n              if (!p.signature) {\n                p.rootProperty = Polymer.Path.root(p.value);\n              }\n            }\n          }\n        }\n        // Recurse into nested templates & bind host props\n        if (note.templateContent) {\n          processAnnotations(note.templateContent._notes);\n          let hostProps = note.templateContent._hostProps =\n            discoverTemplateHostProps(note.templateContent._notes);\n          let bindings = [];\n          for (let prop in hostProps) {\n            bindings.push({\n              index: note.index,\n              kind: 'property',\n              name: '_host_' + prop,\n              parts: [{\n                mode: '{',\n                value: prop\n              }]\n            });\n          }\n          note.bindings = note.bindings.concat(bindings);\n        }\n      }\n      notes._processed = true;\n    }\n  }\n\n  /**\n   * Finds all property usage in templates (property/path bindings and function\n   * arguments) and returns the path roots as keys in a map. Each outer template\n   * merges inner _hostProps to propagate inner host property needs to outer\n   * templates.\n   *\n   * @param {Array<Object>} notes List of notes to process for a given template\n   * @return {Object<string,boolean>} Map of host properties that the template\n   *   (or any nested templates) uses\n   * @private\n   */\n  function discoverTemplateHostProps(notes) {\n    let hostProps = {};\n    for (let i=0, n; (i<notes.length) && (n=notes[i]); i++) {\n      // Find all bindings to parent.* and spread them into _parentPropChain\n      for (let j=0, b$=n.bindings, b; (j<b$.length) && (b=b$[j]); j++) {\n        for (let k=0, p$=b.parts, p; (k<p$.length) && (p=p$[k]); k++) {\n          if (p.signature) {\n            let args = p.signature.args;\n            for (let kk=0; kk<args.length; kk++) {\n              let rootProperty = args[kk].rootProperty;\n              if (rootProperty) {\n                hostProps[rootProperty] = true;\n              }\n            }\n            hostProps[p.signature.methodName] = true;\n          } else {\n            if (p.rootProperty) {\n              hostProps[p.rootProperty] = true;\n            }\n          }\n        }\n      }\n      // Merge child _hostProps into this _hostProps\n      if (n.templateContent) {\n        let templateHostProps = n.templateContent._hostProps;\n        Polymer.Base.mixin(hostProps, templateHostProps);\n      }\n    }\n    return hostProps;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a <property>-changed event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {Object} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return binding.name &&\n           binding.kind != 'attribute' &&\n           binding.kind != 'text' &&\n           !binding.isCompound &&\n           binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Sets up a prototypical `_bindListeners` metadata array to be used at\n   * instance time to add event listeners for 2-way bindings.\n   *\n   * @param {Object} model Prototype (instances not currently supported)\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   event should be added to\n   * @param {string} property Property of target node to listen for changes\n   * @param {string} path Host path that the change should be propagated to\n   * @param {string=} event A custom event name to listen for (e.g. via the\n   *   `{{prop::eventName}}` syntax)\n   * @param {boolean=} negate Whether the notified value should be negated before\n   *   setting to host path\n   * @private\n   */\n  function addAnnotatedListener(model, index, property, path, event, negate) {\n    if (!model._bindListeners) {\n      model._bindListeners = [];\n    }\n    let eventName = event ||\n      (CaseMap.camelToDashCase(property) + '-changed');\n    model._bindListeners.push({\n      index: index,\n      property: property,\n      path: path,\n      event: eventName,\n      negate: negate\n    });\n  }\n\n  /**\n   * Adds all 2-way binding notification listeners to a host based on\n   * `_bindListeners` metadata recorded by prior calls to`addAnnotatedListener`\n   *\n   * @param {Object} inst Host element instance\n   * @private\n   */\n  function setupBindListeners(inst) {\n    let b$ = inst._bindListeners;\n    for (let i=0, l=b$.length, info; (i<l) && (info=b$[i]); i++) {\n      let node = inst.__dataNodes[info.index];\n      addNotifyListener(node, inst, info);\n    }\n  }\n\n  /**\n   * Finds all bound nodes in the given `dom` fragment that were recorded in the\n   * provided Annotator `notes` array and stores them in `__dataNodes` for this\n   * instance.  The index of nodes in `__dataNodes` corresponds to the index\n   * of a note in the `notes` array, and binding effect metadata uses this\n   * index to identify bound nodes when propagating data.\n   *\n   * Compound binding storage structures are also initialized onto the bound\n   * nodes, and 2-way binding event listeners are also added.\n   *\n   * @param {Object} inst Instance that bas been previously bound\n   * @param {DocumentFragment} dom Document fragment containing stamped nodes\n   * @param {Array<Object>} notes Array of annotation notes provided by\n   *   Polymer.Annotator\n   * @private\n   */\n  function setupBindings(inst, dom, notes) {\n    if (notes.length) {\n      let nodes = new Array(notes.length);\n      for (let i=0; i < notes.length; i++) {\n        let note = notes[i];\n        let node = nodes[i] = inst._findTemplateAnnotatedNode(dom, note);\n        node.__dataHost = inst;\n        if (note.bindings) {\n          setupCompoundBinding(note, node);\n        }\n      }\n      inst.__dataNodes = nodes;\n    }\n    if (inst._bindListeners) {\n      setupBindListeners(inst);\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {Object} sig Method signature metadata\n   * @param {string} type\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo\n   * @param {boolean=} dynamic Whether the method name should be included as\n   *   a dependency to the effect.\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamic) {\n    let info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo: methodInfo,\n      dynamicFn: dynamic\n    };\n    // TODO(sorvell): why still here?\n    if (sig.static) {\n      model._addPropertyEffect('__static__', type, {\n        fn: effectFn, info: info\n      });\n    } else {\n      for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n        if (!arg.literal) {\n          model._addPropertyEffect(arg.rootProperty, type, {\n            fn: effectFn, info: info, trigger: arg\n          });\n        }\n      }\n    }\n    if (dynamic) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    let context = inst._methodHost || inst;\n    let fn = context[info.methodName];\n    if (fn) {\n      let args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  const emptyArray = [];\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?Object} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      let sig = { methodName: m[1], static: true };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        sig.args = emptyArray;\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {Array<string>} argList Array of argument names\n   * @param {Object} sig Method signature metadata object\n   * @return {Object} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function(rawArg) {\n      let arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {Object} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    let arg = rawArg.trim()\n      // replace comma entity with comma\n      .replace(/&comma;/g, ',')\n      // repair extra escape sequences; note only commas strictly need\n      // escaping, but we allow any other char to be escaped since its\n      // likely users will do this\n      .replace(/\\\\(.)/g, '\\$1')\n      ;\n    // basic argument descriptor\n    let a = {\n      name: arg\n    };\n    // detect literal value (must be String or Number)\n    let fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch(fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isDeep(arg);\n      if (a.structured) {\n        a.wildcard = (arg.slice(-2) == '.*');\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {Array<Object>} args Array of argument metadata\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    let values = [];\n    for (let i=0, l=args.length; i<l; i++) {\n      let arg = args[i];\n      let name = arg.name;\n      let v;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        let baseChanged = (name.indexOf(path + '.') === 0);\n        let matches = (path.indexOf(name) === 0 && !baseChanged);\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Object} note Annotation metadata\n   * @param {Node} node Bound node to initialize\n   * @private\n   */\n  function setupCompoundBinding(note, node) {\n    let bindings = note.bindings;\n    for (let i=0; i<bindings.length; i++) {\n      let binding = bindings[i];\n      if (binding.isCompound) {\n        // Create compound storage map\n        let storage = node.__dataCompoundStorage ||\n          (node.__dataCompoundStorage = {});\n        let parts = binding.parts;\n        // Copy literals from parts into storage for this binding\n        let literals = new Array(parts.length);\n        for (let j=0; j<parts.length; j++) {\n          literals[j] = parts[j].literal;\n        }\n        let name = binding.name;\n        storage[name] = literals;\n        // Configure properties with their literal parts\n        if (binding.literal && binding.kind == 'property') {\n          // TODO(kschaaf) config integration\n          // if (node._configValue) {\n          //   node._configValue(name, binding.literal);\n          // } else {\n            node[name] = binding.literal;\n          // }\n        }\n      }\n    }\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function notifySplices(inst, array, path, splices) {\n    let splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = {indexSplices: null};\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  Polymer.PropertyEffects = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    const mixin = Polymer.TemplateStamp(\n      Polymer.Attributes(Polymer.PropertyAccessors(superClass)));\n\n    /**\n     * @unrestricted\n     */\n    class PropertyEffects extends mixin {\n\n      get PROPERTY_EFFECT_TYPES() {\n        return TYPES;\n      }\n\n      constructor() {\n        super();\n        this._asyncEffects = false;\n        this.__dataInitialized = false;\n        this.__dataPendingClients = null;\n        this.__dataFromAbove = false;\n        this.__dataLinkedPaths = null;\n        this.__dataNodes = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n      }\n\n      /**\n       * Adds to default initialization in `PropertyAccessors` by initializing\n       * local property & pending data storage with any accessor values saved\n       * in `__dataProto`.  If instance properties had been set before the\n       * element upgraded and gained accessors on its prototype, these values\n       * are set into the prototype's accessors after being deleted from the\n       * instance.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        super._initializeProperties();\n        this.__dataTemp = {};\n        // initialize data with prototype values saved when creating accessors\n        if (this.__dataProto) {\n          this.__data = Object.create(this.__dataProto);\n          this.__dataPending = Object.create(this.__dataProto);\n          this.__dataOld = {};\n        } else {\n          this.__dataPending = null;\n        }\n        // update instance properties\n        for (let p in this.__propertyEffects) {\n          if (this.hasOwnProperty(p)) {\n            let value = this[p];\n            delete this[p];\n            this[p] = value;\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *   {\n       *     fn: effectFunction, // Reference to function to call to perform effect\n       *     info: { ... }       // Effect metadata passed to function\n       *     // path: '...'      // Will be set by this method based on path arg\n       *   }\n       *\n       * Effect functions are called with the following signature:\n       *\n       *   effectFunction(inst, property, currentValue, oldValue, info)\n       *\n       * This method may be called either on the prototype of a class\n       * using the PropertyEffects mixin (for best performance), or on\n       * an instance to add dynamic effects.  When called on an instance or\n       * subclass of a class that has already had property effects added to\n       * its prototype, the property effect lists will be cloned and added as\n       * own properties of the caller.\n       *\n       * @param {string} path Property (or path) that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      _addPropertyEffect(property, type, effect) {\n        let effects = ensureOwnEffectMap(this, TYPES.ANY)[property];\n        if (!effects) {\n          effects = this.__propertyEffects[property] = [];\n          this._createPropertyAccessor(property,\n            type == TYPES.READ_ONLY);\n        }\n        // effects are accumulated into arrays per property based on type\n        if (effect) {\n          effects.push(effect);\n        }\n        effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasPropertyEffect(property, type) {\n        let effects = this[type || TYPES.ANY];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, isPathNotification) {\n        let rootProperty = Polymer.Path.root(Array.isArray(path) ? path[0] : path);\n        let hasEffect = this.__propertyEffects && this.__propertyEffects[rootProperty];\n        let isPath = (rootProperty !== path);\n        if (hasEffect) {\n          if (isPath) {\n            if (!isPathNotification) {\n              // Dirty check changes being set to a path against the actual object,\n              // since this is the entry point for paths into the system; from here\n              // the only dirty checks are against the `__dataTemp` cache to prevent\n              // duplicate work in the same turn only. Note, if this was a notification\n              // of a change already set to a path (isPathNotification: true),\n              // we always let the change through and skip the `set` since it was\n              // already dirty checked at the point of entry and the underlying\n              // object has already been updated\n              let old = Polymer.Path.get(this, path);\n              path = /** @type {string} */ Polymer.Path.set(this, path, value);\n              // Use property-accessor's simpler dirty check\n              if (!path || !super._shouldPropertyChange(path, value, old)) {\n                return false;\n              }\n            }\n            this.__dataHasPaths = true;\n          }\n          return this._setPendingProperty(path, value);\n        } else {\n          if (isPath) {\n            Polymer.Path.set(this, path, value);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       * \n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting <input>.value resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information. \n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertyAccessors` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChaged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       */\n      _setPendingProperty(property, value) {\n        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n        let prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths and objects are stored in temporary cache (cleared at end of\n          // turn), which is used for dirty-checking\n          if (isPath || typeof value == 'object') {\n            this.__dataTemp[property] = value;\n          }\n          // Properties (but not sub-paths) get stored __data cache, used to\n          // return accessor values from getters\n          if (!isPath) {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Overrides default PropertyAccessors implementation to pull the value\n       * to dirty check against from the `__dataTemp` cache (rather than the\n       * normal `__data` cache) for Objects.  Since the temp cache is cleared\n       * at the end of a turn, this implementation allows side-effects of deep\n       * object changes to be processed by re-setting the same object (using\n       * the temp cache as a backstop to prevent cycles due to 2-way\n       * notification).\n       *\n       * Override this to provide more strict dirty checking, i.e. immutable\n       * (`value === old`) or based on type.\n       *\n       * TODO(kschaaf): Can this go away (and just use @override) once we start using mixin interfaces?\n       * @override\n       * @param {string} property\n       * @param {*} value\n       * @param {*} old\n       * @return {boolean}\n       */\n      _shouldPropertyChange(property, value, old) {\n        if (typeof value == 'object') {\n          old = this.__dataTemp[property];\n        }\n        return super._shouldPropertyChange(property, value, old);\n      }\n\n      /**\n       * Overrides PropertyAccessor's default async queuing of\n       * `_propertiesChanged`: if `__dataInitialized` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       */\n      _invalidateProperties() {\n        if (this.__dataInitialized) {\n          //TODO(kschaaf): consider option to flush async\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @protected\n       */\n      _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @protected\n       */\n      _flushClients() {\n        // Flush all clients\n        let clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (let i=0; i < clients.length; i++) {\n            let client = clients[i];\n            // TODO(kschaaf): more explicit check?\n            if (!client.__dataInitialized || client.__dataPending) {\n              client._flushProperties(true);\n            }\n          }\n        }\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       */\n      setProperties(props) {\n        for (let path in props) {\n          if (!this.__readOnly || !this.__readOnly[path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path]);\n          }\n        }\n        this._invalidateProperties();\n      }\n      /**\n       * Overrides PropertyAccessor's default async queuing of\n       * `_propertiesChanged`, to instead synchronously flush\n       * `_propertiesChanged` unless the `this._asyncEffects` property is true.\n       *\n       * If this is the first time properties are being flushed, the `ready`\n       * callback will be called.\n       *\n       * Also adds an optional `fromAbove` argument to indicate when properties\n       * are being flushed by a host during data propagation. This information\n       * is used to avoid sending upwards notification events in response to\n       * downward data flow.  This is a performance optimization, but also\n       * critical to avoid infinite looping when an object is notified, since\n       * the default implementation of `_shouldPropertyChange` always returns\n       * true for Objects, and without would result in a notify-propagate-notify\n       * loop.\n       *\n       * @param {boolean=} fromAbove When true, sets `this.__dataFromAbove` to\n       *   `true` for the duration of the call to `_propertiesChanged`.\n       * @override\n       */\n      _flushProperties(fromAbove) {\n        if (!this.__dataInitialized) {\n          this.ready();\n        }\n        if (this.__dataPending || this.__dataPendingClients) {\n          this.__dataFromAbove = fromAbove;\n          super._flushProperties();\n          if (!this.__dataCounter) {\n            // Clear temporary cache at end of turn\n            this.__dataTemp = {};\n          }\n        }\n      }\n\n      /**\n       * Polymer-specific lifecycle callback called the first time properties\n       * are being flushed.  Prior to `ready`, all property sets through\n       * accessors are queued and their effects are flushed after this method\n       * returns.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its properties initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or binding values propagated from host\n       * \"binding effects\".  `super.ready()` must be called to ensure the\n       * data system becomes enabled.\n       *\n       * @public\n       */\n      ready() {\n        this.__dataInitialized = true;\n      }\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * Note that for host data to be bound into the stamped DOM, the template\n       * must have been previously bound to the prototype via a call to\n       * `_bindTemplate`, which performs one-time template binding work.\n       *\n       * Note that this method currently only supports being called once per\n       * instance.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       * @protected\n       */\n      _stampTemplate(template) {\n        let dom = super._stampTemplate(template);\n        let notes = (template._content || template.content)._notes;\n        setupBindings(this, dom, notes);\n        return dom;\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        let hasPaths = this.__dataHasPaths;\n        let fromAbove = this.__dataFromAbove;\n        this.__dataHasPaths = this.__dataFromAbove = false;\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        // Compute properties\n        let computedProps = runComputedEffects(this, changedProps, oldProps, fromAbove, hasPaths);\n        // Compute linked paths\n        computedProps = computeLinkedPaths(this, changedProps, computedProps, hasPaths);\n        // Propagate properties to clients\n        runEffects(this, this.__propagateEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this.__reflectEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Observe properties\n        runEffects(this, this.__observeEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Notify properties to host\n        runNotifyEffects(this, fromAbove ? computedProps : changedProps, oldProps, fromAbove, hasPaths);\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @method linkPaths\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @public\n       */\n      linkPaths(to, from) {\n        to = Polymer.Path.normalize(to);\n        from = Polymer.Path.normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @method unlinkPaths\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @public\n       */\n      unlinkPaths(path) {\n        path = Polymer.Path.normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @public\n      */\n      notifySplices(path, splices) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @method get\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root) {\n        return Polymer.Path.get(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @method set\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @public\n      */\n      set(path, value, root) {\n        if (root) {\n          Polymer.Path.set(root, path, value);\n        } else {\n          if (!this.__readOnly || !this.__readOnly[/** @type {string} */(path)]) {\n            if (this._setPendingPropertyOrPath(path, value)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method push\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = {};\n        let array = /** @type {Array}*/(Polymer.Path.get(this, path, info));\n        let len = array.length;\n        let ret = array.push(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method pop\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method splice\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else {\n          start = Math.floor(start);\n        }\n        if (!start) {\n          start = 0;\n        }\n        let ret = array.splice(start, deleteCount, ...items);\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method shift\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method unshift\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let ret = array.unshift(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @public\n      */\n      notifyPath(path, value) {\n        /** @type {string} */\n        let propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          let info = {};\n          value = Polymer.Path.get(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = Polymer.Path.normalize(path);\n        } else {\n          propPath = /** @type{string} */(path);\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = function(value) {\n            this._setProperty(property, value);\n          }\n        }\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @protected\n       */\n      _createObservedProperty(property, methodName) {\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info: {\n            methodName: methodName\n          },\n          trigger: {name: property}\n        });\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal Javascript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @protected\n       */\n      _createMethodObserver(expression) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createReflectedProperty(property) {\n        let attr = CaseMap.camelToDashCase(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n            attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal Javascript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @protected\n       */\n      _createComputedProperty(property, expression) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property);\n      }\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Creates \"binding\" property effects for all binding bindings\n       * in the provided template that forward host properties into DOM stamped\n       * from the template via `_stampTemplate`.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @protected\n       */\n      _bindTemplate(template) {\n        // Clear any existing propagation effects inherited from superClass\n        this.__propagateEffects = {};\n        let notes = this._parseTemplateAnnotations(template);\n        processAnnotations(notes);\n        for (let i=0, note; (i<notes.length) && (note=notes[i]); i++)  {\n          // where to find the node in the concretized list\n          let b$ = note.bindings;\n          for (let j=0, binding; (j<b$.length) && (binding=b$[j]); j++) {\n            if (shouldAddListener(binding)) {\n              addAnnotatedListener(this, i, binding.name,\n                binding.parts[0].value,\n                binding.parts[0].event,\n                binding.parts[0].negate);\n            }\n            addBindingEffect(this, binding, i);\n          }\n        }\n      }\n\n    }\n\n    return PropertyEffects;\n  });\n\n})();\n\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(11);\n\n\n(function() {\n  'use strict';\n\n  var StyleGather = {\n    MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',\n    INCLUDE_ATTR: 'include',\n    _importModule(moduleId) {\n      if (!Polymer.DomModule) {\n        return null;\n      }\n      return Polymer.DomModule.import(moduleId);\n    },\n    /**\n     * @param {string} moduleIds\n     * @param {boolean=} warnIfNotFound\n     * @return {string}\n     */\n    cssFromModules(moduleIds, warnIfNotFound) {\n      var modules = moduleIds.trim().split(' ');\n      var cssText = '';\n      for (var i=0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i], warnIfNotFound);\n      }\n      return cssText;\n    },\n\n    // returns cssText of styles in a given module; also un-applies any\n    // styles that apply to the document.\n    cssFromModule(moduleId, warnIfNotFound) {\n      var m = this._importModule(moduleId);\n      if (m && !m._cssText) {\n        m._cssText = this.cssFromElement(m);\n      }\n      if (!m && warnIfNotFound) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n    // support lots of ways to discover css...\n    cssFromElement(element) {\n      var cssText = '';\n      // if element is a template, get content from its .content\n      var content = element.content || element;\n      var e$ = content.querySelectorAll(this.MODULE_STYLES_SELECTOR);\n      for (var i=0, e; i < e$.length; i++) {\n        e = e$[i];\n        // look inside templates for elements\n        if (e.localName === 'template') {\n          cssText += this.cssFromElement(e);\n        } else {\n          // style elements inside dom-modules will apply to the main document\n          // we don't want this, so we remove them here.\n          if (e.localName === 'style') {\n            var include = e.getAttribute(this.INCLUDE_ATTR);\n            // now support module refs on 'styling' elements\n            if (include) {\n              cssText += this.cssFromModules(include, true);\n            }\n            // get style element applied to main doc via HTMLImports polyfill\n            e = e.__appliedElement || e;\n            e.parentNode.removeChild(e);\n            cssText += Polymer.ResolveUrl.resolveCss(e.textContent, element.ownerDocument);\n            // it's an import, assume this is a text file of css content.\n            // TODO(sorvell): plan is to deprecate this way to get styles;\n            // remember to add deprecation warning when this is done.\n          } else if (e.import && e.import.body) {\n            cssText += Polymer.ResolveUrl.resolveCss(e.import.body.textContent, e.import);\n          }\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n  (function() {\n    'use strict';\n\n    var StyleUtil = {\n\n      isTargetedBuild: function(buildType) {\n        return (!window.ShadyDOM || !ShadyDOM.inUse) ?\n          buildType === 'shadow' : buildType === 'shady';\n      },\n\n      cssBuildTypeForModule: function (module) {\n        var dm = Polymer.DomModule.import(module);\n        if (dm) {\n          return this.getCssBuildType(dm);\n        }\n      },\n\n      getCssBuildType: function(element) {\n        return element.getAttribute('css-build');\n      }\n\n    };\n\n    Polymer.StyleUtil = StyleUtil;\n\n  })();\n\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(2);\n\n__webpack_require__(11);\n\n\n/**\n * Scans a template to produce an annotation list that that associates\n * metadata culled from markup with tree locations\n * metadata and information to associate the metadata with nodes in an instance.\n *\n * Supported expressions include:\n *\n * Double-mustache annotations in text content. The annotation must be the only\n * content in the tag, compound expressions are not supported.\n *\n *     <[tag]>{{annotation}}<[tag]>\n *\n * Double-escaped annotations in an attribute, either {{}} or [[]].\n *\n *     <[tag] someAttribute=\"{{annotation}}\" another=\"[[annotation]]\"><[tag]>\n *\n * `on-` style event declarations.\n *\n *     <[tag] on-<event-name>=\"annotation\"><[tag]>\n *\n * Note that the `annotations` feature does not implement any behaviors\n * associated with these expressions, it only captures the data.\n *\n * Generated data-structure:\n *\n *     [\n *       {\n *         id: '<id>',\n *         events: [\n *           {\n *             name: '<name>'\n *             value: '<annotation>'\n *           }, ...\n *         ],\n *         bindings: [\n *           {\n *             kind: ['text'|'attribute'],\n *             mode: ['{'|'['],\n *             name: '<name>'\n *             value: '<annotation>'\n *           }, ...\n *         ],\n *         // TODO(sjmiles): this is annotation-parent, not node-parent\n *         parent: <reference to parent annotation object>,\n *         index: <integer index in parent's childNodes collection>\n *       },\n *       ...\n *     ]\n *\n * @class Annotations feature\n */\n(function() {\n\n  'use strict';\n\n  // null-array (shared empty array to avoid null-checks)\n  const emptyArray = [];\n\n  let bindingRegex = (function() {\n    let IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n    let NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n    let SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n    let DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n    let STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n    let ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\\\s*' + ')';\n    let ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n    let ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                                  '(?:' + ARGUMENTS + '?' + ')' +\n                                '\\\\)\\\\s*' + ')';\n    let BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n    let OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n    let CLOSE_BRACKET = '(?:]]|}})';\n    let NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n    let EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n    return new RegExp(EXPRESSION, \"g\");\n  })();\n\n  let insertionPointTag = 'slot';\n  let currentTemplate;\n\n  /**\n   * @param {HTMLTemplateElement} template\n   * @param {boolean=} stripWhiteSpace\n   * @return {Array<Object>}\n   */\n  function parseTemplateAnnotations(template, stripWhiteSpace) {\n    // TODO(kschaaf): File issue and/or remove when fixed\n    // hold a reference to content as _content to prevent odd Chrome gc issue\n    // nested templates also may receive their content as _content\n    let content = (template._content = template._content || template.content);\n    // since a template may be re-used, memo-ize notes.\n    if (!content._notes) {\n      content._notes = [];\n      // TODO(sorvell): whitespace and processAnnotations need to be factored\n      // into plugins\n      // TODO(kschaaf): template should be threaded through rather than implied state\n      currentTemplate = currentTemplate || template;\n      parseNodeAnnotations(content, content._notes,\n        stripWhiteSpace || template.hasAttribute('strip-whitespace'));\n    }\n    return content._notes;\n  }\n\n  // add annotations gleaned from subtree at `node` to `list`\n  function parseNodeAnnotations(node, list, stripWhiteSpace) {\n    return node.nodeType === Node.TEXT_NODE ?\n      parseTextNodeAnnotation(node, list) :\n        parseElementAnnotations(node, list, stripWhiteSpace);\n  }\n\n  // TODO(kschaaf): We could modify this to allow an escape mechanism by\n  // looking for the escape sequence in each of the matches and converting\n  // the part back to a literal type, and then bailing if only literals\n  // were found\n  function parseBindings(text) {\n    let parts = [];\n    let lastIndex = 0;\n    let m;\n    // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n    // Regex matches:\n    //        Iteration 1:  Iteration 2:\n    // m[1]: '{{'          '[['\n    // m[2]: ''            '!'\n    // m[3]: 'prop'        'compute(foo,bar)'\n    while ((m = bindingRegex.exec(text)) !== null) {\n      // Add literal part\n      if (m.index > lastIndex) {\n        parts.push({literal: text.slice(lastIndex, m.index)});\n      }\n      // Add binding part\n      // Mode (one-way or two)\n      let mode = m[1][0];\n      let negate = Boolean(m[2]);\n      let value = m[3].trim();\n      let customEvent, notifyEvent, colon;\n      if (mode == '{' && (colon = value.indexOf('::')) > 0) {\n        notifyEvent = value.substring(colon + 2);\n        value = value.substring(0, colon);\n        customEvent = true;\n      }\n      parts.push({\n        compoundIndex: parts.length,\n        value: value,\n        mode: mode,\n        negate: negate,\n        event: notifyEvent,\n        customEvent: customEvent\n      });\n      lastIndex = bindingRegex.lastIndex;\n    }\n    // Add a final literal part\n    if (lastIndex && lastIndex < text.length) {\n      let literal = text.substring(lastIndex);\n      if (literal) {\n        parts.push({\n          literal: literal\n        });\n      }\n    }\n    if (parts.length) {\n      return parts;\n    }\n  }\n\n  function literalFromParts(parts) {\n    let s = '';\n    for (let i=0; i<parts.length; i++) {\n      let literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  // add annotations gleaned from TextNode `node` to `list`\n  function parseTextNodeAnnotation(node, list) {\n    let parts = parseBindings(node.textContent);\n    if (parts) {\n      // Initialize the textContent with any literal parts\n      // NOTE: default to a space here so the textNode remains; some browsers\n      // (IE) evacipate an empty textNode following cloneNode/importNode.\n      node.textContent = literalFromParts(parts) || ' ';\n      let note = {\n        bindings: [{\n          kind: 'text',\n          name: 'textContent',\n          parts: parts,\n          isCompound: parts.length !== 1\n        }]\n      };\n      list.push(note);\n      return note;\n    }\n  }\n\n  // add annotations gleaned from Element `node` to `list`\n  function parseElementAnnotations(element, list, stripWhiteSpace) {\n    let note = {\n      bindings: [],\n      events: []\n    };\n    if (element.localName === insertionPointTag) {\n      list._hasInsertionPoint = true;\n    }\n    parseChildNodesAnnotations(element, note, list, stripWhiteSpace);\n    if (element.attributes) {\n      parseNodeAttributeAnnotations(element, note);\n      prepElement(element);\n    }\n    if (note.bindings.length || note.events.length || note.id) {\n      list.push(note);\n    }\n    return note;\n  }\n\n  // add annotations gleaned from children of `root` to `list`, `root`'s\n  // `note` is supplied as it is the note.parent of added annotations\n  function parseChildNodesAnnotations(root, note, list, stripWhiteSpace) {\n    if (root.firstChild) {\n      let node = root.firstChild;\n      let i = 0;\n      while (node) {\n        // BREAKME(kschaaf): pseudo-bc auto-wrapper for template type extensions\n        if (node.localName === 'template') {\n          let t = node;\n          let is = t.getAttribute('is');\n          // stamp `<dom-*>` elements\n          if (is && is.indexOf('dom-') === 0) {\n            t.removeAttribute('is');\n            node = t.ownerDocument.createElement(is);\n            root.replaceChild(node, t);\n            node.appendChild(t);\n            while(t.attributes.length) {\n              node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n              t.removeAttribute(t.attributes[0].name);\n            }\n          }\n        }\n        if (node.localName === 'template' &&\n          !node.hasAttribute('preserve-content')) {\n          parseTemplate(node, i, list, note, stripWhiteSpace);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        let next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            // decrement index since node is removed\n            i--;\n          }\n        }\n        // if this node didn't get evacipated, parse it.\n        if (node.parentNode) {\n          let childAnnotation = parseNodeAnnotations(node, list,\n            stripWhiteSpace);\n          if (childAnnotation) {\n            childAnnotation.parent = note;\n            childAnnotation.index = i;\n          }\n        }\n        node = next;\n        i++;\n      }\n    }\n  }\n\n  // 1. Parse annotations from the template and memoize them on\n  //    content._notes (recurses into nested templates)\n  // 2. Remove template.content and store it in annotation list, where it\n  //    will be the responsibility of the host to set it back to the template\n  //    (this is both an optimization to avoid re-stamping nested template\n  //    children and avoids a bug in Chrome where nested template children\n  //    upgrade)\n  function parseTemplate(node, index, list, parent, stripWhiteSpace) {\n    let content = node.content.ownerDocument.createDocumentFragment();\n    content._notes = parseTemplateAnnotations(node, stripWhiteSpace);\n    content.appendChild(node.content);\n    list.push({\n      bindings: emptyArray,\n      events: emptyArray,\n      templateContent: content,\n      parent: parent,\n      index: index\n    });\n  }\n\n  // add annotation data from attributes to the `annotation` for node `node`\n  // TODO(sjmiles): the distinction between an `annotation` and\n  // `annotation data` is not as clear as it could be\n  function parseNodeAttributeAnnotations(node, annotation) {\n    // Make copy of original attribute list, since the order may change\n    // as attributes are added and removed\n    let attrs = Array.prototype.slice.call(node.attributes);\n    for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n      let n = a.name;\n      let v = a.value;\n      let b;\n      // events (on-*)\n      if (n.slice(0, 3) === 'on-') {\n        node.removeAttribute(n);\n        annotation.events.push({\n          name: n.slice(3),\n          value: v\n        });\n      }\n      // bindings (other attributes)\n      else if ((b = parseNodeAttributeAnnotation(node, n, v))) {\n        annotation.bindings.push(b);\n      }\n      // static id\n      else if (n === 'id') {\n        annotation.id = v;\n      }\n    }\n  }\n\n  // construct annotation data from a generic attribute, or undefined\n  function parseNodeAttributeAnnotation(node, name, value) {\n    let parts = parseBindings(value);\n    if (parts) {\n      // Attribute or property\n      let origName = name;\n      let kind = 'property';\n      if (name[name.length-1] == '$') {\n        name = name.slice(0, -1);\n        kind = 'attribute';\n      }\n      // Initialize attribute bindings with any literal parts\n      let literal = literalFromParts(parts);\n      if (literal && kind == 'attribute') {\n        node.setAttribute(name, literal);\n      }\n      // Clear attribute before removing, since IE won't allow removing\n      // `value` attribute if it previously had a value (can't\n      // unconditionally set '' before removing since attributes with `$`\n      // can't be set using setAttribute)\n      if (node.localName === 'input' && origName === 'value') {\n        node.setAttribute(origName, '');\n      }\n      // Remove annotation\n      node.removeAttribute(origName);\n      // Case hackery: attributes are lower-case, but bind targets\n      // (properties) are case sensitive. Gambit is to map dash-case to\n      // camel-case: `foo-bar` becomes `fooBar`.\n      // Attribute bindings are excepted.\n      let propertyName = Polymer.CaseMap.dashToCamelCase(name);\n      if (kind === 'property') {\n        name = propertyName;\n      }\n      return {\n        kind: kind,\n        name: name,\n        propertyName: propertyName,\n        parts: parts,\n        literal: literal,\n        isCompound: parts.length !== 1\n      };\n    }\n  }\n\n  // TODO(sorvell): this should be factored into a plugin\n  function prepElement(element) {\n    Polymer.ResolveUrl.resolveAttrs(element, currentTemplate.ownerDocument);\n  }\n\n  Polymer.Annotations = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class Annotations extends superClass {\n\n      // preprocess-time\n\n      // construct and return a list of annotation records\n      // by scanning `template`'s content\n      //\n      // TODO(sorvell): This should just crawl over a template and call\n      // a supplied list of callbacks.\n      _parseTemplateAnnotations(template) {\n        return parseTemplateAnnotations(template);\n      }\n\n      // instance-time\n      // TODO(sorvell): consider trying to use QS instead of this proprietary\n      // search. This would require some unique way to identify a node, a guid.\n      // Is this faster? simpler? Is that worth polluting the node?\n      _findTemplateAnnotatedNode(root, note) {\n        // recursively ascend tree until we hit root\n        let parent = note.parent && this._findTemplateAnnotatedNode(root,\n          note.parent);\n        // unwind the stack, returning the indexed node at each level\n        if (parent) {\n          // note: marginally faster than indexing via childNodes\n          // (http://jsperf.com/childnodes-lookup)\n          for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n            if (note.index === i++) {\n              return n;\n            }\n          }\n        } else {\n          return root;\n        }\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n__webpack_require__(0);\n\n\n(function() {\n\n  const Path = {\n\n    isPath: function(path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    root: function(path) {\n      var dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    // Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n    isAncestor: function(base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    // Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n    isDescendant: function(base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    // can be read as:  from  to       path\n    translate: function(base, newBase, path) {\n      // Defense?\n      return newBase + path.slice(base.length);\n    },\n\n    matches: function(base, path) {\n      return (base === path) ||\n             this.isAncestor(base, path) ||\n             this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path\n     * @param {string | !Array<string|number>} path\n     * @return {string}\n     */\n    normalize: function(path) {\n      if (Array.isArray(path)) {\n        var parts = [];\n        for (var i=0; i<path.length; i++) {\n          var args = path[i].toString().split('.');\n          for (var j=0; j<args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Split a path into an array\n     * @param {string | !Array<string|number>} path\n     * @return {!Array<string>}\n     */\n    split: function(path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * @param {Object} root\n     * @param {string | !Array<string|number>} path\n     * @param {Object=} info\n     * @return {*}\n     */\n    get: function(root, path, info) {\n      var prop = root;\n      var parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (var i=0; i<parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        var part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * @param {Object} root\n     * @param {string | !Array<string|number>} path\n     * @param {*} value\n     * @return {string | undefined}\n     */\n    set: function(root, path, value) {\n      var prop = root;\n      var parts = this.split(path);\n      var last = parts[parts.length-1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (var i=0; i<parts.length-1; i++) {\n          var part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  // BC API\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n  \n})();\n\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n__webpack_require__(13);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// app.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 33);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5f1752b4c883c488cc1b","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n\n  window.Polymer = window.Polymer || {};\n  window.Polymer.version = '2.0-preview';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, goog.reflect.objectProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  var goog = {\n    reflect: {\n      objectProperty(s, o) {\n        return s;\n      }\n    }\n  }\n  /* eslint-enable */\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/utils/boot.html\n// module id = 0\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('./boot.html');\n\n\n\n(function() {\n\n  'use strict';\n\n  let p = Element.prototype;\n  let matchesSelector = p.matches || p.matchesSelector ||\n    p.mozMatchesSelector || p.msMatchesSelector ||\n    p.oMatchesSelector || p.webkitMatchesSelector;\n\n  // unique global id for deduping mixins.\n  let dedupeId = 0;\n\n  // run a callback when HTMLImports are ready or immediately if\n  // this api is not available.\n  function whenImportsReady(cb) {\n    if (window.HTMLImports) {\n      HTMLImports.whenReady(cb);\n    } else {\n      cb();\n    }\n  }\n\n  Polymer.Utils = {\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @method mixin\n     * @param {Object} target Target object to copy properties to.\n     * @param {Object} source Source object to copy properties from.\n     * @return {Object} Target object that was passed as first argument.\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    },\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @method extend\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     */\n    extend(prototype, api) {\n      if (prototype && api) {\n        let n$ = Object.getOwnPropertyNames(api);\n        for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n          this.copyOwnProperty(n, api, prototype);\n        }\n      }\n      return prototype || api;\n    },\n\n    copyOwnProperty(name, source, target) {\n      let pd = Object.getOwnPropertyDescriptor(source, name);\n      if (pd) {\n        Object.defineProperty(target, name, pd);\n      }\n    },\n\n    // only needed for v0 native ShadowDOM support\n    getRootNode(node) {\n      if (node.getRootNode) {\n        return node.getRootNode();\n      }\n      if (!node) {\n        return null;\n      }\n      while(node && node.parentNode) {\n        node = node.parentNode;\n      }\n      return node;\n    },\n\n    matchesSelector(node, selector) {\n      return matchesSelector.call(node, selector);\n    },\n\n    /**\n     * Given a mixin producing function, memoize applications of mixin to base\n     */\n    cachingMixin(mixin) {\n      return function(base) {\n        if (!mixin.__mixinApplications) {\n          mixin.__mixinApplications = new WeakMap();\n        }\n        let map = mixin.__mixinApplications;\n        let application = map.get(base);\n        if (!application) {\n          application = mixin(base);\n          map.set(base, application);\n        }\n        return application;\n      };\n    },\n\n    /**\n     * Given a mixin producing function, only apply mixin if has not already been applied to base\n     * Also memoize mixin applications\n     */\n    dedupingMixin(mixin) {\n      mixin = this.cachingMixin(mixin);\n      // maintain a unique id for each mixin\n      if (!mixin.__id) {\n        mixin.__dedupeId = ++dedupeId;\n      }\n      return function(base) {\n        let baseSet = base.__mixinSet;\n        if (baseSet && baseSet[mixin.__dedupeId]) {\n          return base;\n        }\n        let extended = mixin(base);\n        // copy inherited mixin set from the extended class, or the base class\n        // NOTE: we avoid use of Set here because some browser (IE11)\n        // cannot extend a base Set via the constructor.\n        extended.__mixinSet =\n          Object.create(extended.__mixinSet || baseSet || null);\n        extended.__mixinSet[mixin.__dedupeId] = true;\n        return extended;\n      }\n    },\n\n    /**\n     * Convenience method for importing an HTML document imperatively.\n     *\n     * This method creates a new `<link rel=\"import\">` element with\n     * the provided URL and appends it to the document to start loading.\n     * In the `onload` callback, the `import` property of the `link`\n     * element will contain the imported document contents.\n     *\n     * @method importHref\n     * @param {string} href URL to document to load.\n     * @param {Function=} onload Callback to notify when an import successfully\n     *   loaded.\n     * @param {Function=} onerror Callback to notify when an import\n     *   unsuccessfully loaded.\n     * @param {boolean=} optAsync True if the import should be loaded `async`.\n     *   Defaults to `false`.\n     * @return {HTMLLinkElement} The link element for the URL to be loaded.\n     */\n    importHref(href, onload, onerror, optAsync) {\n      let link =\n        document.head.querySelector('link[href=\"' + href + '\"][import-href]');\n      if (!link) {\n        link = document.createElement('link');\n        link.rel = 'import';\n        link.href = href;\n        link.setAttribute('import-href', '');\n      }\n      // always ensure link has `async` attribute if user specified one,\n      // even if it was previously not async. This is considered less confusing.\n      if (optAsync) {\n        link.setAttribute('async', '');\n      }\n      // NOTE: the link may now be in 3 states: (1) pending insertion,\n      // (2) inflight, (3) already laoded. In each case, we need to add\n      // event listeners to process callbacks.\n      let cleanup = function() {\n        link.removeEventListener('load', loadListener);\n        link.removeEventListener('error', errorListener);\n      }\n      let loadListener = function(event) {\n        cleanup();\n        // In case of a successful load, cache the load event on the link so\n        // that it can be used to short-circuit this method in the future when\n        // it is called with the same href param.\n        link.__dynamicImportLoaded = true;\n        if (onload) {\n          whenImportsReady(() => {\n            onload(event);\n          });\n        }\n      };\n      let errorListener = function(event) {\n        cleanup();\n        // In case of an error, remove the link from the document so that it\n        // will be automatically created again the next time `importHref` is\n        // called.\n        if (link.parentNode) {\n          link.parentNode.removeChild(link);\n        }\n        if (onerror) {\n          whenImportsReady(() => {\n            onerror(event);\n          });\n        }\n      };\n      link.addEventListener('load', loadListener);\n      link.addEventListener('error', errorListener);\n      if (link.parentNode == null) {\n        document.head.appendChild(link);\n      // if the link already loaded, dispatch a fake load event\n      // so that listeners are called and get a proper event argument.\n      } else if (link.__dynamicImportLoaded) {\n        link.dispatchEvent(new Event('load'));\n      }\n      return link;\n    }\n  };\n\n})();\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/utils/utils.html\n// module id = 1\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('./boot.html');\n\n\n(function() {\n\n  const CaseMap = {\n\n    _caseMap: {},\n    _rx: {\n      dashToCamel: /-[a-z]/g,\n      camelToDash: /([A-Z])/g\n    },\n\n    dashToCamelCase: function(dash) {\n      return this._caseMap[dash] || (\n        this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel,\n          function(m) {\n            return m[1].toUpperCase();\n          }\n        )\n      );\n    },\n\n    camelToDashCase: function(camel) {\n      return this._caseMap[camel] || (\n        this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase()\n      );\n    }\n\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/utils/case-map.html\n// module id = 2\n// module chunks = 0","import { TemplateBindingFunction } from './nerdy-bindings';\n\nexport function createTemplateBindingFunction(context = {}): TemplateBindingFunction {\n    return (name, ...literals) => typeof name[0] === 'string' && name[0].length ? context && context[name[0]] || `{{${name[0]}}}` : '';\n}\n\nexport function NerdyTemplateBindingFunction(name) {\n    return `{{${typeof name === 'string' ? name : name[0]}}}`;\n}\n\nfunction isString(argument: any): argument is string {\n    return typeof argument === 'string';\n}\n\nfunction firstItemIsString(argument: any): argument is [string] {\n    return argument && argument.length === 1 && isString(argument[0]);\n}\n\nfunction flattenResults(results: any) {\n    if (Array.isArray(results)) switch (results.length) {\n        case 0: return undefined;\n        case 1: return results[1];\n        default: return results;\n    }\n}\n\nconst convertFromDashToCamel = (dash: string) => dash.replace(/-[a-z]/g, String.prototype.toUpperCase);\nconst convertFromCamelToDash = (dash: string) => dash.replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\nexport function dashToCamel(dashCaseString: string, ...more: string[]) {\n    return flattenResults(([...arguments] as string[]).map(argument => typeof argument === 'string' ? convertFromDashToCamel(argument) : Array.isArray(argument) ? dashToCamel(argument) : argument));\n}\n\nexport function camelToDash(dashCaseString: string, ...more: string[]) {\n    return flattenResults(([...arguments] as string[]).map(argument => typeof argument === 'string' ? convertFromCamelToDash(argument) : Array.isArray(argument) ? camelToDash(argument) : argument));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/bindings/nerdy-binding.ts","import { TemplateBindingFunction } from './nerdy-bindings';\n\nexport const PolymerTemplateBindingFunction: TemplateBindingFunction = (name) => `{{${typeof name === 'string' ? name : name[0]}}}`;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/bindings/polymer-binding.ts","export * from './decorators/enumerable';\nexport * from './decorators/custom-element';\n\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/decorators.ts","export * from './dom/nerdy-dom';\n\nimport NerdyDOM from './dom/nerdy-dom';\n\nexport const createElementFromTagName = NerdyDOM.createElementFromTagName;\nexport const createElementFromClass = NerdyDOM.createElementFromClass;\nexport const createErrorElement = NerdyDOM.createErrorElement;\nexport const createWrappedElement = NerdyDOM.createWrappedElement;\nexport const convertToElement = NerdyDOM.convertToElement;\nexport const createElement = NerdyDOM.createElement;\nexport const applyAttributes = NerdyDOM.applyAttributes;\nexport const insertChild = NerdyDOM.insertChild;\nexport const insertChildren = NerdyDOM.insertChildren;\n\nexport default NerdyDOM;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/dom.ts","import { NerdyElementConstructor } from '../elements'; // import { pretty } from \"js-object-pretty-print\";\n\nexport class NerdyDOM {\n\n    public static activeDocument; // = typeof window !== 'undefined' && 'document' in window && window.document;\n    public static activeDOM; // = new NerdyDOM();\n\n    public static get createElementFromTagName() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.createElementFromTagName;\n    }\n\n    public static get createElementFromClass() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.createElementFromClass;\n    }\n\n    public static get createErrorElement() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.createErrorElement;\n    }\n\n    public static get createWrappedElement() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.createWrappedElement;\n    }\n\n    public static get convertToElement() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.convertToElement;\n    }\n\n    public static get createElement() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.createElement;\n    }\n\n    public static get applyAttributes() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.applyAttributes;\n    }\n\n    public static get insertChild() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.insertChild;\n    }\n\n    public static get insertChildren() {\n        if (NerdyDOM.activeDOM) return NerdyDOM.activeDOM.insertChildren;\n    }\n\n    // public stackTracks: any[][] = [];\n    // public stackTrack: any[] = [];\n\n    public document: Document;\n\n    constructor(targetDocument: Document = NerdyDOM.activeDocument) {\n        this.document = targetDocument;\n        for (const method of ['createElementFromTagName', 'createElementFromClass', 'createErrorElement', 'createWrappedElement', 'convertToElement', 'convertToElement', 'convertToElement', 'createElement', 'applyAttributes', 'insertChild', 'insertChildren']) this[method] = this[method].bind(this);\n        console.log('NerdyDOM', { this: this, targetDocument, arguments });\n    }\n\n    createElementFromTagName(tag: string): HTMLElement | undefined {\n        try {\n            return this.document.createElement(tag);\n        } catch (exception) {\n            exception.message = `Error executing createElementFromTagName(${typeof tag === 'string' ? tag : typeof (tag)}): ${exception.message}`;\n            return exception; // this.stackTrack.push(exception);\n        }\n    }\n\n    createElementFromClass(tag: NerdyElementConstructor): HTMLElement | undefined {\n        try {\n            return new tag();\n        } catch (exception) {\n            exception.message = `Error executing createElementFromClass(${tag.name || (tag.prototype && tag.prototype.name) || tag.is || tag}): ${exception.message}`;\n            return exception; // this.stackTrack.push(exception);\n        }\n    }\n\n    createErrorElement(exception: Error | string, ...contents: any[]) {\n        const message = (typeof exception === 'string' ? exception : typeof exception.message === 'string' ? exception.message : '').trim();\n        const header = `Error: ${message.length ? message : 'Unknown Exception'}`;\n        // const body = contents.reduce((item, body) => body + (typeof item !== 'undefined' ? ('\\n' + pretty(item) + '\\n') : ''), '').trim();\n        const body = contents.reduce((item, body) => body + (typeof item !== 'undefined' ? ('\\n' + item + '\\n') : ''), '').trim();\n        const element = this.document.createComment(`Error: ${message.length ? message : 'Unknown Exception' + contents}`);\n        return element;\n    }\n\n    convertToElement(value: any) {\n        if (value === undefined) return this.document.createTextNode('UNDEFINED');\n        else if (value === null) return this.document.createTextNode('NULL');\n        else if (typeof value === 'object' && value instanceof HTMLElement) return value;\n        else switch (typeof value) {\n            case 'string': return this.document.createTextNode(`\"${value}\"`);\n            case 'number': return this.document.createTextNode(`${value}`);\n            case 'boolean': return this.document.createTextNode(value === true ? 'TRUE' : 'FALSE');\n            default: return this.document.createTextNode(value); //pretty(\n        }\n    }\n\n    createWrappedElement(...contents: any[]) {\n        const wrapper = this.document.createElement('template');\n        if (contents[0] instanceof Error) wrapper.appendChild(this.createErrorElement(contents.shift(), contents));\n        else for (const child of contents) wrapper.appendChild(this.convertToElement(child));\n    }\n\n    applyAttributes(element: HTMLElement, attributes: { [name: string]: any } = {}) {\n        try {\n            if (typeof attributes === 'object' && 'setAttribute' in element) for (const name in attributes) element.setAttribute(name, attributes[name]); // tslint:disable-line\n        } catch (exception) {\n            exception.message = `Error executing applyAttributes(): ${exception.message}`;\n            console.error(exception); // this.stackTrack.push(exception);\n        }\n    }\n\n    insertChild(element: HTMLElement | DocumentFragment, child: any) {\n        if (typeof child === 'string') element.appendChild(this.document.createTextNode(child));\n        else if (child instanceof HTMLElement) element.appendChild(child);\n    }\n\n    insertChildren(element: HTMLTemplateElement | HTMLElement | DocumentFragment, ...children: any[]) {\n        const parent = typeof element !== 'object' || !(element instanceof HTMLElement) ? null : element instanceof HTMLTemplateElement ? element.content : element;\n        if (!parent) throw new TypeError(`Elements can only be inserted into elements that inherit from HTMLElement or HTMLTemplateElement`);\n        typeof children === 'string' ? this.insertChild(parent, children) : children.forEach(child => this.insertChild(parent, child)); // console.log('CHILDREN', children);\n    }\n\n    createElement(tag: string | NerdyElementConstructor, attributes: { [name: string]: any } = {}, ...children: HTMLElement[]) {\n\n        try { // this.stackTracks.push(this.stackTrack = [{ tag, attributes, children }]);\n\n            // Create new instance of element\n            const element = typeof tag === 'string' ? this.createElementFromTagName(tag) : this.createElementFromClass(tag);\n\n            // If create fails, create a wrapped element from the error for debugging\n            if (element instanceof Error) return this.createErrorElement(element, { tag, attributes, children }); // , ...this.stackTrack);\n\n            // Apply attributes to element\n            if (attributes && Object.keys(attributes).length) this.applyAttributes(element, attributes);\n\n            // Insert children into element\n            if (children.length) this.insertChildren(element, ...children);\n\n            // Return element // console.log('createElement', { tag, attributes, children, arguments, this: this, element });\n            return element;\n        } catch (exception) {\n            console.error(exception); // this.stackTrack.push(exception);\n        }\n    }\n\n}\n\nif (!NerdyDOM.activeDocument) NerdyDOM.activeDocument = document; // window typeof window !== 'undefined' && 'document' in window && window.document;\nif (!NerdyDOM.activeDOM) NerdyDOM.activeDOM = new NerdyDOM();\n\nexport default NerdyDOM;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/dom/nerdy-dom.ts","import './polymer-element';\nimport Template, { BindingFunction, PolymerBindingFunction as $ } from '../templates';\nimport { enumerable } from '../decorators';\nimport { NerdyElementConstructor, NerdyElementPrototype } from './nerdy-elements';\nimport { getAttributesObject } from './nerdy-elements-helpers';\n\nexport class NerdyElement extends Polymer.Element {\n\n    public static elements = {};\n    public static nerdyTemplate?: Template<any>;\n\n    public static define(constructor: NerdyElementConstructor) {\n\n        const constructorName = constructor && ((constructor as any).name || (constructor as any).displayName) || typeof constructor;\n\n        if (!NerdyElement.isConstructor(constructor)) throw new Error(`Expected a constructor of a NerdyElement in order to define an element, but got ${constructorName} instead.`);\n\n        const tagName = constructor.is;\n        const tagNameAvailable = !(tagName in NerdyElement.elements);\n        const customElementNameAvailable = window.customElements.get(tagName) === undefined;\n        const alreadyDefined = !tagNameAvailable && NerdyElement.elements[tagName] === constructor;\n\n        // Check tagName\n        if (tagNameAvailable && customElementNameAvailable) {\n            let element;\n            try {\n                element = document.createElement(tagName);\n            } catch (exception) {\n                throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is not valid in the current runtime environment. ${exception.message}`);\n            }\n        } else if (!tagNameAvailable) {\n            throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is already used to define another NerdyElement.`);\n        } else if (!customElementNameAvailable) {\n            throw new Error(`Cannot define this NerdyElement since the tag name ${tagName} is already used to define another custom element in the document.`);\n        }\n\n        if (alreadyDefined) return;\n\n        if (tagName in NerdyElement.elements) throw new Error(`Cannot define NerdyElement since the tag name '${tagName}' returned by ${constructorName}.is has already been used to define another element. In order to resolve this, you might want to rename the class of one of the elements, or if you prefer to not rename the actual classes, simply set the static is property on either class to use a different tag name.`);\n\n        if (customElementNameAvailable) {\n            try {\n                window.customElements.define(constructor.is, constructor);\n            } catch (exception) {\n                throw new Error(`Cannot register this NerdyElement as a custom element in the current runtime environment. ${exception.message}`);\n            }\n        }\n\n        NerdyElement.elements[tagName] = constructor;\n\n        window.customElements.whenDefined(tagName).then(() => {\n            if (window.customElements.get(tagName) !== NerdyElement.elements[tagName]) {\n                throw new Error(`NerdyElement: Unexpected mismatch between the NerdyElement registry and the custom element registry for the tag ${tagName}, which can be caused by another custom element racing to be registered using the same tag name and that might result in serious conflicts, or it could be due to some \"Web Components\" framework or polyfills applying mixins to the original element and that is also can cause unexpected behaviour. Please notify the adiministrators that they should verify that there are no resulting security vulnerabilities.`);\n            }\n        });\n\n    }\n\n    public static set observedAttributes(attributes) {\n        if (this === NerdyElement) return;\n        Object.defineProperty(this, 'observedAttributes', {\n            value: attributes,\n        });\n    }\n\n    public static set is(name) {\n        if (this === NerdyElement) return;\n        Object.defineProperty(this, 'is', {\n            value: name,\n        });\n    }\n\n    public static get is(): string {\n        if (this === NerdyElement) return;\n        return Object.defineProperty(this, 'is', { value: this.name.replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() }) && this.is;\n    }\n\n    public static get template(): HTMLTemplateElement {\n        if (this === NerdyElement) return;\n        return this.nerdyTemplate && this.nerdyTemplate.template;\n    }\n\n    /**\n     *\n     *\n     * @protected\n     * @type {{[name:string]: string}}\n     * @memberOf NerdyElement\n     */\n    // @enumerable.off\n    public propertyLookup: { [name: string]: string };\n\n    constructor() {\n        super() && typeof this.created === 'function' && this.created();\n        this.propertyLookup = {};\n    }\n\n    ready() {\n        super.ready();\n        if (this.attributes.length) this.setProperties(getAttributesObject(this));\n    }\n\n    public created?(): void;\n    public attached?(): void;\n    public detatched?(): void;\n    public adopted?(): void;\n    public attributeChanged?(attribute: string, oldValue: any, newValue: any): void;\n\n    @enumerable.off\n    public connectedCallback() {\n        super.connectedCallback(), typeof this.attached === 'function' && this.attached();\n    }\n\n    @enumerable.off\n    public disconnectedCallback() {\n        super.disconnectedCallback(), typeof this.detatched === 'function' && this.detatched();\n    }\n\n    @enumerable.off\n    public adoptedCallback() {\n        super.adoptedCallback(), typeof this.adopted === 'function' && this.adopted();\n    }\n\n    @enumerable.off\n    public attributeChangedCallback(attribute: string, oldValue: any, newValue: any) {\n        super.attributeChangedCallback(attribute, oldValue, newValue), typeof this.attributeChanged === 'function' && this.attributeChanged(attribute, oldValue, newValue);\n    }\n\n    @enumerable.off\n    assign(...values: Array<{ [name: string]: any }>) {\n        return Object.assign(this, ...values);\n    }\n\n    /**\n     * Goes through each key of the properties parameter and\n     * tries to find the best named property match using the\n     * findPropertyName method.\n     *\n     * @param {{ [name: string]: any }} properties\n     *\n     * @memberOf NerdyElement\n     */\n    @enumerable.off\n    setProperties(properties: { [name: string]: any }) {\n        for (const name of Object.keys(properties)) {\n            const property = this.findPropertyName(name);\n            if (property) this[property] = properties[name];\n        }\n    }\n\n    @enumerable.off\n    getPropertyNames() {\n        // TODO: we need a better strategy to populate property names\n        return Object.getOwnPropertyNames(this); // Object.keys(this);\n    }\n\n    @enumerable.off\n    findPropertyName(name: string) {\n        // Abort if passed an invalid name\n        if (typeof name !== 'string' || (name = name.trim()).length === 0) return;\n\n        // Return property if name exactly matches\n        if (name in this) return name;\n\n        // Convert name to stripped-lowercased format\n        const simpleName = name.replace(/[\\-\\s]/g, '').toLowerCase();\n\n        // Return previously matched name using the cached lowercase map\n        if (simpleName in this.propertyLookup) return this.propertyLookup[simpleName];\n\n        // Prepare to do some introspection\n        const properties = Object.keys(this);\n\n        // If name is dash cased then do a lowercase match against the dedashed name\n        if (/\\w\\-\\w/.test(name)) {\n            const property = Object.keys(this).find((name, index) => name.toLowerCase() === simpleName);\n            if (property) return (this.propertyLookup[simpleName] = property);\n        }\n\n        // All basis are covered so we must return undefined because we have no more candidates\n        return (this.propertyLookup[simpleName] = undefined);\n    }\n\n}\n\nexport namespace NerdyElement {\n    export function isConstructor(object: any): object is NerdyElementConstructor {\n        return typeof object === 'function' && object.is && typeof object.is === 'string';\n    }\n}\n\nexport default NerdyElement;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/elements/nerdy-element.ts","import * as DOM from '../dom';\nimport { TemplateBindingFunction, PolymerTemplateBindingFunction, createTemplateBindingFunction } from '../bindings';\n\nexport class NerdyTemplate<Prototype> {\n    public static define(component: (typeof HTMLElement | any) & { template?: NerdyTemplate<any> | any, _template?: HTMLTemplateElement }, template: HTMLTemplateElement | (($?: TemplateBindingFunction) => HTMLTemplateElement)) {\n        return new NerdyTemplate(component, template);\n    }\n\n    public static get createElement() { return DOM.createElement; }\n    public static get applyAttributes() { return DOM.applyAttributes; }\n    public static get insertChildren() { return DOM.insertChildren; }\n\n    public viewModel: Prototype;\n    public template: HTMLTemplateElement;\n\n    constructor(component: Prototype, template: HTMLTemplateElement | (($?: TemplateBindingFunction) => HTMLTemplateElement)) {\n        this.template = typeof template === 'function' ? template() : template;\n    }\n\n}\n\nexport namespace NerdyTemplate {\n    export declare type BindingFunction = TemplateBindingFunction;\n    export const PolymerBindingFunction = PolymerTemplateBindingFunction;\n\n    export namespace BindingFunction {\n        export const Polymer = NerdyTemplate.PolymerBindingFunction;\n        export const create = createTemplateBindingFunction;\n    }\n}\n\nexport default NerdyTemplate;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/templates/nerdy-template.ts","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\n\n(function() {\n\n  'use strict';\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    var handler = function(e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  Polymer.EventListeners = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class EventListeners extends superClass {\n\n      _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        var handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/events/event-listeners.html\n// module id = 10\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n\n  (function() {\n\n    // path fixup for urls in cssText that's expected to\n    // come from a given ownerDocument\n    function resolveCss(cssText, ownerDocument) {\n      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {\n        return pre + '\\'' +\n          resolve(url.replace(/[\"']/g, ''), ownerDocument) +\n          '\\'' + post;\n      });\n    }\n\n    // url fixup for urls in an element's attributes made relative to\n    // ownerDoc's base url\n    function resolveAttrs(element, ownerDocument) {\n      for (var name in URL_ATTRS) {\n        var a$ = URL_ATTRS[name];\n        for (var i=0, l=a$.length, a, at, v; (i<l) && (a=a$[i]); i++) {\n          if (name === '*' || element.localName === name) {\n            at = element.attributes[a];\n            v = at && at.value;\n            if (v && (v.search(BINDING_RX) < 0)) {\n              at.value = (a === 'style') ?\n                resolveCss(v, ownerDocument) :\n                resolve(v, ownerDocument);\n            }\n          }\n        }\n      }\n    }\n\n    function resolve(url, ownerDocument) {\n      // do not resolve '#' links, they are used for routing\n      if (url && ABS_URL.test(url)) {\n        return url;\n      }\n      var resolver = getUrlResolver(ownerDocument);\n      resolver.href = url;\n      return resolver.href || url;\n    }\n\n    var tempDoc;\n    var tempDocBase;\n    function resolveUrl(url, baseUri) {\n      if (!tempDoc) {\n        tempDoc = document.implementation.createHTMLDocument('temp');\n        tempDocBase = tempDoc.createElement('base');\n        tempDoc.head.appendChild(tempDocBase);\n      }\n      tempDocBase.href = baseUri;\n      return resolve(url, tempDoc);\n    }\n\n    function getUrlResolver(ownerDocument) {\n      return ownerDocument.__urlResolver ||\n        (ownerDocument.__urlResolver = ownerDocument.createElement('a'));\n    }\n\n    var CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n    var URL_ATTRS = {\n      '*': ['href', 'src', 'style', 'url'],\n      form: ['action']\n    };\n    var ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n    var BINDING_RX = /\\{\\{|\\[\\[/;\n\n    // exports\n    Polymer.ResolveUrl = {\n      resolveCss: resolveCss,\n      resolveAttrs: resolveAttrs,\n      resolveUrl: resolveUrl\n    };\n\n  })();\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/template/resolve-url.html\n// module id = 11\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\nrequire('../events/event-listeners.html');\n\nrequire('./annotations.html');\n\n\n(function() {\n\n  'use strict';\n\n  /**\n   * Scans a template to produce an annotation object that stores expression\n   * metadata along with information to associate the metadata with nodes in an\n   * instance.\n   *\n   * Elements with `id` in the template are noted and marshaled into an\n   * the `$` hash in an instance.\n   *\n   * Example\n   *\n   *     &lt;template>\n   *       &lt;div id=\"foo\">&lt;/div>\n   *     &lt;/template>\n   *     &lt;script>\n   *      Polymer({\n   *        task: function() {\n   *          this.$.foo.style.color = 'red';\n   *        }\n   *      });\n   *     &lt;/script>\n   *\n   * Other expressions that are noted include:\n   *\n   * Double-mustache annotations in text content. The annotation must be the only\n   * content in the tag, compound expressions are not (currently) supported.\n   *\n   *     <[tag]>{{path.to.host.property}}<[tag]>\n   *\n   * Double-mustache annotations in an attribute.\n   *\n   *     <[tag] someAttribute=\"{{path.to.host.property}}\"><[tag]>\n   *\n   * Only immediate host properties can automatically trigger side-effects.\n   * Setting `host.path` in the example above triggers the binding, setting\n   * `host.path.to.host.property` does not.\n   *\n   * `on-` style event declarations.\n   *\n   *     <[tag] on-<event-name>=\"{{hostMethodName}}\"><[tag]>\n   *\n   * Note: **the `annotations` feature does not actually implement the behaviors\n   * associated with these expressions, it only captures the data**.\n   *\n   * Other optional features contain actual data implementations.\n   *\n   * @class standard feature: annotations\n   */\n\n  /*\n\n  Scans a template to produce an annotation map that stores expression metadata\n  and information that associates the metadata to nodes in a template instance.\n\n  Supported annotations are:\n\n    * id attributes\n    * binding annotations in text nodes\n      * double-mustache expressions: {{expression}}\n      * double-bracket expressions: [[expression]]\n    * binding annotations in attributes\n      * attribute-bind expressions: name=\"{{expression}} || [[expression]]\"\n      * property-bind expressions: name*=\"{{expression}} || [[expression]]\"\n      * property-bind expressions: name:=\"expression\"\n    * event annotations\n      * event delegation directives: on-<eventName>=\"expression\"\n\n  Generated data-structure:\n\n    [\n      {\n        id: '<id>',\n        events: [\n          {\n            mode: ['auto'|''],\n            name: '<name>'\n            value: '<expression>'\n          }, ...\n        ],\n        bindings: [\n          {\n            kind: ['text'|'attribute'|'property'],\n            mode: ['auto'|''],\n            name: '<name>'\n            value: '<expression>'\n          }, ...\n        ],\n        // TODO(sjmiles): confusingly, this is annotation-parent, not node-parent\n        parent: <reference to parent annotation>,\n        index: <integer index in parent's childNodes collection>\n      },\n      ...\n    ]\n\n  TODO(sjmiles): this module should produce either syntactic metadata\n  (e.g. double-mustache, double-bracket, star-attr), or semantic metadata\n  (e.g. manual-bind, auto-bind, property-bind). Right now it's half and half.\n\n  */\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, dom, note) {\n    if (note.id) {\n      map[note.id] = inst._findTemplateAnnotatedNode(dom, note);\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, dom, note, host) {\n    if (note.events && note.events.length) {\n      var node = inst._findTemplateAnnotatedNode(dom, note);\n      for (var j=0, e$=note.events, e; (j<e$.length) && (e=e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, host);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, dom, note) {\n    if (note.templateContent) {\n      var node = inst._findTemplateAnnotatedNode(dom, note);\n      node._content = note.templateContent;\n    }\n  }\n\n  Polymer.TemplateStamp = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    const mixin = Polymer.Annotations(Polymer.EventListeners(superClass));\n    return class TemplateStamp extends mixin {\n\n      constructor() {\n        super();\n        this.$ = null;\n      }\n\n      _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content &&\n            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        var notes = this._parseTemplateAnnotations(template);\n        var dom = document.importNode(template._content || template.content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !notes._hasInsertionPoint;\n        this.$ = {};\n        for (var i=0, l=notes.length, note; (i<l) && (note=notes[i]); i++) {\n          applyIdToMap(this, this.$, dom, note);\n          applyTemplateContent(this, dom, note);\n          applyEventListener(this, dom, note, this);\n        }\n        return dom;\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/template/template-stamp.html\n// module id = 12\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    require('./hello-world.tsx');\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/hello-world.html\n// module id = 13\n// module chunks = 0","import { NerdyElement, NerdyTemplate, BindingFunction, createElement, customElement } from './nerdy-components';\n\n@customElement\nexport default class HelloWorld extends NerdyElement {\n\n    public static counter = 0;\n\n    public static get nerdyTemplate() {\n        return NerdyTemplate.define(HelloWorld, ($: BindingFunction = BindingFunction.Polymer) => (\n            <template class=\"class\" id='hello-world-component-nerdy-template'>\n                <h1 id={$`id`} onclick={$`clickHandler`}>{(this as any).name} {$`counter`}</h1>\n                <pre><b>> </b>{$`message`}</pre>\n            </template>\n        ));\n    }\n\n    public static test() {\n        const className = this.name, tagName = this.is, container = document.createElement('div');\n        container.appendChild(<pre style=\"background: rgb(255, 192, 0); display: block; padding: 1em; border-radius: 0.25em;\">This has only been reliably tested in Chrome (56.0.2924.87)</pre>);\n        container.innerHTML = container.innerHTML + `<${tagName} message=\"this element was created by appending <${tagName} ...></${tagName}> to a <div></div>\"></${tagName}>`;\n        const elements = {\n            declared: container.getElementsByTagName(tagName)[0],\n            transpiled: <this message={`this element was transpiled from tsx using <${className} ...></${className}>`}></this>,\n            created: Object.assign(document.createElement(tagName), { message: `this element was created by calling document.createElement('${tagName}')` }),\n            constructed: (new this()).assign({ message: `this element was created by calling new ${className}()` }),\n        };\n\n        console.info(`${className}::test()`, {\n            '[class.constructor]': this, '[class.prototype]': this.prototype,\n            '[element.prototype]': window.customElements.get(tagName),\n            '[elements]': elements,\n        });\n\n        for (const key of Object.keys(elements)) if (elements[key] instanceof HTMLElement) container.appendChild(elements[key]); // if (elements[key])\n\n        document.body.appendChild(container);\n    }\n\n    public message: string;\n    public counter: number = ((this.constructor as any).counter = ((this.constructor as any).counter || 0) + 1);\n\n    public attached() {\n        console.log(`${this.constructor.name}#attached()!`, this);\n    }\n\n    public clickHandler() {\n        console.log(`${this.constructor.name}#clickHandler`, { arguments, this: this }, this);\n    }\n\n}\n\nHelloWorld.test();\n\n\n\n// WEBPACK FOOTER //\n// ./components/hello-world.tsx","export * from './bindings/nerdy-binding';\nexport * from './bindings/nerdy-bindings';\nexport * from './bindings/polymer-binding';\n\nimport * as NerdyBinding from './bindings/nerdy-binding';\nimport * as PolymerBinding from './bindings/polymer-binding';\nexport { NerdyBinding, PolymerBinding };\n\nexport default NerdyBinding;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/bindings.ts","\nexport function customElement(constructor: Function & { is: string });\nexport function customElement(tagName?: string);\nexport function customElement(argument: string | (Function & { is: string })) {\n    let tagName = typeof argument === 'string' ? argument : undefined;\n    if (typeof argument === 'function') customElement.registerElement(tagName = customElement.getTagName(argument), argument);\n    else return (constructor: Function) => customElement.registerElement(tagName, constructor);\n}\n\nexport namespace customElement {\n    export function getTagName(constructor: Function) {\n        if (typeof constructor['is'] === 'string' && constructor['is'].trim().length) constructor['is'].trim();\n        if (typeof constructor.name === 'string' && constructor.name.trim().length) return constructor.name.trim().replace(/([^a-z]+)([A-Z][a-z])/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n        throw new Error(`Cannot getTagName from the '${constructor.name}' constructor since it does not have the 'is' property defined`);\n    }\n    export function registerElement(tagName, constructor) {\n        if (window.customElements.get(tagName)) throw new Error(`Cannot auto-register custome element since the name ${tagName} is already defined`);\n        window.customElements.define(tagName, constructor);\n        console.info('@customElement::registerElement', { tagName, constructor });\n    }\n\n\n}\n\nexport default customElement;\n\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/decorators/custom-element.ts","/**\n * @enumerable decorator that sets the enumerable property of a class field to false.\n * @param value true|false\n */\nexport function enumerable(value: boolean) {\n    return (target: any, property: string) => {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property) || {};\n        // tslint:disable-next-line:triple-equals\n        if (descriptor.enumerable != value) Object.defineProperty(target, property, { ...descriptor, enumerable: (value = !!value) });\n        // console.info('@enumerable', { target, property, enumerable: value });\n    };\n}\n\nexport namespace enumerable {\n    export const off = enumerable(false);\n    export const on = enumerable(true);\n}\n\nexport default enumerable;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/decorators/enumerable.ts","export * from './elements/nerdy-element';\nexport * from './elements/nerdy-elements';\n\nimport NerdyElement from './elements/nerdy-element';\n\nexport const { isConstructor } = NerdyElement;\n\nexport default NerdyElement;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/elements.ts","export function getAttributesObject(source: HTMLElement | NamedNodeMap): { [name: string]: any } {\n    const attributes = source && ((source instanceof NamedNodeMap && source) || (source instanceof HTMLElement && source.attributes));\n    return attributes ? Array.from(attributes).reduce((object, attribute) => (object[attribute.name] = attribute.value, object), {}) : undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/elements/nerdy-elements-helpers.ts","/// <reference path= '../@types/polymer.d.ts' />\n\nif (window) {\n    let goog = (window as any).goog = (window as any).goog || {};\n    let reflect = goog.reflect = goog.reflect || {};\n    reflect.objectProperty = (s, o) => s;\n\n    // TODO: Figure out how to link import polymer before loading component\n    // tslint:disable-next-line:no-var-requires\n    require('../../../bower_components/polymer/polymer-element.html');\n};\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/elements/polymer-element.ts","export * from './decorators';\nexport * from './dom';\nexport * from './templates';\nexport * from './elements';\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/index.ts","export * from './templates/nerdy-template';\n\nimport NerdyTemplate from './templates/nerdy-template';\n\nexport type BindingFunction = NerdyTemplate.BindingFunction;\nexport const BindingFunction = NerdyTemplate.BindingFunction;\n\nexport const { PolymerBindingFunction } = NerdyTemplate;\n\nexport default NerdyTemplate;\n\n\n\n// WEBPACK FOOTER //\n// ./components/nerdy-components/templates.ts","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('./src/elements/element.html');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/polymer-element.html\n// module id = 23\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\nrequire('../utils/case-map.html');\n\n\n(function() {\n\n  'use strict';\n\n  var caseMap = Polymer.CaseMap;\n\n  Polymer.Attributes = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    /**\n     * @unrestricted\n     */\n    class Attributes extends superClass {\n\n      constructor() {\n        super();\n        this.__serializing = false;\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       *\n       * @method _ensureAttribute\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       */\n      _ensureAttribute(attribute, value) {\n        if (!this.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(this, value, attribute);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeAttribute` method to convert the string to\n       * a typed value.\n       *\n       * @method _attributeToProperty\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {string} value of the attribute.\n       * @param {*} type type to deserialize to.\n       */\n      _attributeToProperty(attribute, value, type) {\n        // Don't deserialize back to property if currently reflecting\n        if (!this.__serializing) {\n          var property = caseMap.dashToCamelCase(attribute);\n          this[property] = this._deserializeAttribute(value, type);\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @method _propertyToAttribute\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to refect.\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = (arguments.length < 3) ? this[property] : value;\n        this._valueToNodeAttribute(this, value,\n          attribute || caseMap.camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeAttribute` method to convert the typed\n       * value to a string.  If the `_serializeAttribute` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @method _valueToNodeAttribute\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        var str = this._serializeAttribute(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed value to a string.\n       *\n       * This method is called by Polymer when setting JS property values to\n       * HTML attributes.  Users may override this method on Polymer element\n       * prototypes to provide serialization for custom types.\n       *\n       * @method _serializeAttribute\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n      _serializeAttribute(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch(x) {\n                return '';\n              }\n            }\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       * Note: The return value of `undefined` is used as a sentinel value to\n       * indicate the attribute should be removed.\n       *\n       * @method _deserializeAttribute\n       * @param {string} value Attribute value to deserialize.\n       * @param {*} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeAttribute(value, type) {\n        /**\n         * @type {*}\n         */\n        let outValue;\n        switch (type) {\n          case Number:\n            outValue = Number(value);\n            break;\n\n          case Boolean:\n            outValue = (value !== null);\n            break;\n\n          case Object:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              // allow non-JSON literals like Strings and Numbers\n            }\n            break;\n\n          case Array:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              outValue = null;\n              console.warn('Polymer::Attributes: couldn`t decode Array as JSON');\n            }\n            break;\n\n          case Date:\n            outValue = new Date(value);\n            break;\n\n          case String:\n          default:\n            outValue = value;\n            break;\n        }\n\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n    }\n\n    return Attributes;\n  });\n\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/attributes/attributes.html\n// module id = 24\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../legacy/dom-module.html');\n\nrequire('../utils/case-map.html');\n\nrequire('../events/event-listeners.html');\n\nrequire('../template/template-stamp.html');\n\nrequire('../properties/property-effects.html');\n\nrequire('../styling/style-gather.html');\n\nrequire('../styling/style-util.html');\n\n\n(function() {\n\n  'use strict';\n\n  let caseMap = Polymer.CaseMap;\n\n  // Same as Polymer.Utils.mixin, but upgrades shorthand type\n  // syntax to { type: Type }\n  function flattenProperties(flattenedProps, props) {\n    for (let p in props) {\n      let o = props[p];\n      if (typeof o == 'function') {\n        o = { type: o };\n      }\n      flattenedProps[p] = o;\n    }\n    return flattenedProps;\n  }\n\n  Polymer.ElementMixin = Polymer.Utils.dedupingMixin(function(base) {\n\n    const mixin = Polymer.PropertyEffects(base);\n\n    /**\n     * @unrestricted\n     */\n    class PolymerElement extends mixin {\n\n      // returns the config object on specifically on `this` class (not super)\n      // config is used for:\n      // (1) super chain mixes togther to make `flattenedProperties` which is\n      // then used to make observedAttributes and set property defaults\n      // (2) properties effects and observers are created from it at `finalize` time.\n      static get _ownConfig() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('__ownConfig', this))) {\n          this.__ownConfig = this.hasOwnProperty(goog.reflect.objectProperty('config', this)) ? this.config : {};\n        }\n        return this.__ownConfig;\n      }\n\n      // a flattened list of properties mixed together from the chain of all\n      // constructor's `config.properties`\n      // This list is used to create\n      // (1) observedAttributes,\n      // (2) element default values\n      static get _flattenedProperties() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('__flattenedProperties', this))) {\n          // TODO(sorvell): consider optimizing; shorthand type support requires\n          // an extra loop to upgrade shorthand property info to longhand\n          this.__flattenedProperties = flattenProperties({}, this._ownConfig.properties);\n          let superCtor = Object.getPrototypeOf(this.prototype).constructor;\n          if (superCtor.prototype instanceof PolymerElement) {\n            this.__flattenedProperties = flattenProperties(\n              Object.create(superCtor._flattenedProperties),\n              this.__flattenedProperties);\n          }\n        }\n        return this.__flattenedProperties;\n      }\n\n      static get _flattenedPropertyDefaults() {\n        if (!this.hasOwnProperty('__flattenedPropertyDefaults')) {\n          this.__flattenedPropertyDefaults = null;\n          for (let p in this._flattenedProperties) {\n            let info = this._flattenedProperties[p];\n            if ('value' in info) {\n              this.__flattenedPropertyDefaults =\n                this.__flattenedPropertyDefaults || {};\n              this.__flattenedPropertyDefaults[p] = info;\n            }\n          }\n        }\n        return this.__flattenedPropertyDefaults;\n      }\n\n\n\n      static get observedAttributes() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('_observedAttributes', this))) {\n          // observedAttributes must be finalized at registration time\n          this._observedAttributes = this._addPropertiesToAttributes(\n            this._flattenedProperties, []);\n        }\n        return this._observedAttributes;\n      }\n\n      static _addPropertiesToAttributes(properties, list) {\n        for (let prop in properties) {\n          list.push(Polymer.CaseMap.camelToDashCase(prop));\n        }\n        return list;\n      }\n\n      static get finalized() {\n        return this.hasOwnProperty(goog.reflect.objectProperty('_finalized', this));\n      }\n\n      static set finalized(value) {\n        this._finalized = value;\n      }\n\n      // TODO(sorvell): need to work on public api surrouding `finalize`.\n      // Due to meta-programming, it's awkward to make a subclass impl of this.\n      // However, a user might want to call `finalize` prior to define to do\n      // this work eagerly. Need to also decide on `finalizeConfig(config)` and\n      // `finalizeTemplate(template)`. Both are public but have simiarly\n      // awkward subclassing characteristics.\n      static finalize() {\n        let proto = this.prototype;\n        if (!this.finalized) {\n\n          let superProto = Object.getPrototypeOf(proto);\n          let superCtor = superProto && superProto.constructor;\n          if (superCtor.prototype instanceof PolymerElement) {\n            superCtor.finalize();\n          }\n          this.finalized = true;\n          if (this.hasOwnProperty(goog.reflect.objectProperty('is', this)) && this.is) {\n            Polymer.telemetry.register(proto);\n          }\n          let config = this._ownConfig;\n          if (config) {\n            this._finalizeConfig(config);\n          }\n          if (this.template) {\n            this._finalizeTemplate(this.template.cloneNode(true));\n          }\n        }\n      }\n\n      static _finalizeConfig(config) {\n        if (config.properties) {\n          // process properties\n          for (let p in config.properties) {\n            this.prototype._createPropertyFromConfig(p, config.properties[p]);\n          }\n        }\n        if (config.observers) {\n          for (let i=0; i < config.observers.length; i++) {\n            this.prototype._createMethodObserver(config.observers[i]);\n          }\n        }\n      }\n\n      static _getTemplate() {\n        return Polymer.DomModule.import(this.is, 'template');\n      }\n\n      static get template() {\n        if (!this.hasOwnProperty(goog.reflect.objectProperty('_template', this))) {\n          this._template = this._getTemplate() ||\n            // note: implemented so a subclass can retrieve the super\n            // template; call the super impl this way so that `this` points\n            // to the superclass.\n            Object.getPrototypeOf(this.prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      static _finalizeTemplate(template) {\n        // support `include=\"module-name\"`\n        let cssText = Polymer.StyleGather.cssFromElement(template);\n        if (cssText) {\n          let style = document.createElement('style');\n          style.textContent = cssText;\n          template.content.insertBefore(style, template.content.firstChild);\n        }\n        if (window.ShadyCSS) {\n          window.ShadyCSS.prepareTemplate(template, this.is, this.extends);\n        }\n        var proto = this.prototype;\n        this.prototype._bindTemplate(template);\n        proto._template = template;\n      }\n\n      constructor() {\n        super();\n        // note: `this.constructor.prototype` is wrong in Safari so make sure to\n        // use `__proto__`\n        Polymer.telemetry.instanceCount++;\n        // add self to host's pending client list\n        hostStack.registerHost(this);\n      }\n\n      _initializeProperties() {\n        if (!this.constructor.finalized) {\n          this.constructor.finalize();\n        }\n        super._initializeProperties();\n        // apply property defaults...\n        let p$ = this.constructor._flattenedPropertyDefaults;\n        if (!p$) {\n          return;\n        }\n        for (let p in p$) {\n          let info = p$[p];\n          if (!this._isPropertyPending(p)) {\n            var value = typeof info.value == 'function' ?\n              info.value.call(this) :\n              info.value;\n            if (this._hasReadOnlyEffect(p)) {\n              this._setProperty(p, value)\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Creates effects for a property.\n       *\n       * Example:\n       *\n       *     this._createPropertyFromConfig('foo', {\n       *       type: String, value: 'foo', reflectToAttribute: true\n       *     });\n       *\n       * Note, once a property has been set to\n       * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n       * these values may not be changed. For example, a subclass cannot\n       * alter these settings. However, additional `observers` may be added\n       * by subclasses.\n       *\n       * @param {string} name Name of the property.\n       * @param {*=} info Info object from which to create property effects.\n       * Supported keys:\n       *\n       * * type: {function} type to which an attribute matching the property\n       * is deserialized. Note the property is camel-cased from a dash-cased\n       * attribute. For example, 'foo-bar' attribute is dersialized to a\n       * property named 'fooBar'.\n       *\n       * * readOnly: {boolean} creates a readOnly property and\n       * makes a private setter for the private of the form '_setFoo' for a\n       * property 'foo',\n       *\n       * * computed: {string} creates a computed property. A computed property\n       * also automatically is set to `readOnly: true`. The value is calculated\n       * by running a method and arguments parsed from the given string. For\n       * example 'compute(foo)' will compute a given property when the\n       * 'foo' property changes by executing the 'compute' method. This method\n       * must return the computed value.\n       *\n       * * reflectToAttriute: {boolean} If true, the property value is reflected\n       * to an attribute of the same name. Note, the attribute is dash-cased\n       * so a property named 'fooBar' is reflected as 'foo-bar'.\n       *\n       * * notify: {boolean} sends a non-bubbling notification event when\n       * the property changes. For example, a property named 'foo' sends an\n       * event named 'foo-changed' with `event.detail` set to the value of\n       * the property.\n       *\n       * * observer: {string} name of a method that runs when the property\n       * changes. The arguments of the method are (value, previousValue).\n       *\n      */\n      /* TODO(sorvell): Users may want control over modifying property\n       effects via subclassing. For example, a user might want to make a\n       reflectToAttribute property not do so in a subclass. We've chosen to\n       disable this because it leads to additional complication.\n       For example, a readOnly effect generates a special setter. If a subclass\n       disables the effect, the setter would fail unexpectedly.\n       Based on feedback, we may want to try to make effects more malleable\n       and/or provide an advanced api for manipulating them.\n       Also consider adding warnings when an effect cannot be changed.\n      */\n      _createPropertyFromConfig(name, info) {\n        // computed forces readOnly...\n        if (info.computed) {\n          info.readOnly = true;\n        }\n        // Note, since all computed properties are readOnly, this prevents\n        // adding additional computed property effects (which leads to a confusing\n        // setup where multiple triggers for setting a property)\n        // While we do have `hasComputedEffect` this is set on the property's\n        // dependencies rather than itself.\n        if (info.computed  && !this._hasReadOnlyEffect(name)) {\n          this._createComputedProperty(name, info.computed);\n        }\n        if (info.readOnly && !this._hasReadOnlyEffect(name)) {\n          this._createReadOnlyProperty(name, !info.computed);\n        }\n        if (info.reflectToAttribute && !this._hasReflectEffect(name)) {\n          this._createReflectedProperty(name);\n        }\n        if (info.notify && !this._hasNotifyEffect(name)) {\n          this._createNotifyingProperty(name);\n        }\n        // always add observer\n        if (info.observer) {\n          this._createObservedProperty(name, info.observer);\n        }\n      }\n\n      // reserved for canonical behavior\n      connectedCallback() {\n        this.updateStyles();\n        if (hostStack.isEmpty()) {\n          // note, this should never recurse to root elements; this will\n          // need new ShadyCSS api\n          // (see https://github.com/webcomponents/shadycss/issues/42)\n          this._flushProperties();\n        }\n      }\n\n      disconnectedCallback() {}\n\n      ready() {\n        super.ready();\n        if (this._template) {\n          hostStack.beginHosting(this);\n          this.root = this._stampTemplate(this._template);\n          this._flushProperties();\n          this.root = this._attachDom(this.root);\n          hostStack.endHosting(this);\n        } else {\n          this.root = this;\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Attach an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @method _attachDom\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {NodeList} dom to attach to the element.\n       * @return {Node} node to which the dom has been attached.\n       */\n      _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({mode: 'open'});\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n        } else {\n          throw new Error(`ShadowDOM not available. ` +\n            // BREAKME(sorvell): move to developer conditional when supported.\n           `Polymer.Element can\n              create dom as children instead of in ShadowDOM by setting\n              \\`this.root = this;\\` before \\`ready\\`.`);\n\n        }\n      }\n\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          let property = caseMap.dashToCamelCase(name);\n          let type = this.constructor._flattenedProperties[property].type;\n          if (!this._hasReadOnlyEffect(property)) {\n            this._attributeToProperty(name, value, type);\n          }\n        }\n      }\n\n      /**\n       * Update styling for this element\n       *\n       * @param {Object=} properties\n       *  Override styling with an object of properties where the keys are css properties, and the values are strings\n       *  Example: `this.updateStyles({'color': 'blue'})`\n       *  These properties are retained unless a value of `null` is set.\n       */\n      updateStyles(properties) {\n        if (window.ShadyCSS) {\n          ShadyCSS.applyStyle(this, properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to the original location of the document\n       * containing the `dom-module` for this element.  This method will return\n       * the same URL before and after vulcanization.\n       *\n       * @method resolveUrl\n       * @param {string} url URL to resolve.\n       * @return {string} Rewritten URL relative to the import\n       */\n      resolveUrl(url) {\n        var module = Polymer.DomModule.import(this.constructor.is);\n        var root = '';\n        if (module) {\n          root = Polymer.ResolveUrl.resolveUrl(\n            module.assetpath, module.ownerDocument.baseURI);\n        }\n        return Polymer.ResolveUrl.resolveUrl(url, root);\n      }\n\n    }\n\n    return PolymerElement;\n  });\n\n  let hostStack = {\n\n    stack: [],\n\n    isEmpty() {\n      return !this.stack.length;\n    },\n\n    registerHost(inst) {\n      if (this.stack.length) {\n        let host = this.stack[this.stack.length-1];\n        host._enqueueClient(inst);\n      }\n    },\n\n    beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n    endHosting(inst) {\n      let stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen-1] == inst) {\n        this.stack.pop();\n      }\n    }\n\n  }\n\n  // telemetry\n  Polymer.telemetry = {\n    instanceCount: 0,\n    registrations: [],\n    _regLog: function(prototype) {\n      console.log('[' + prototype.is + ']: registered')\n    },\n    register: function(prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    dumpRegistrations: function() {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  Polymer.Element = Polymer.ElementMixin(HTMLElement);\n\n  Polymer.updateStyles = function(props) {\n    if (window.ShadyCSS) {\n      ShadyCSS.updateStyles(props);\n    }\n  };\n\n})();\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/elements/element.html\n// module id = 25\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\n\n\n(function() {\n\n  var modules = {};\n  var lcModules = {};\n  var findModule = function(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  };\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via any dom-module element. Use the `import(id, selector)`\n   * method to locate dom within this database. For example,\n   *\n   * <dom-module id=\"foo\">\n   *   <img src=\"stuff.png\">\n   * </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   * var img = document.createElement('dom-module').import('foo', 'img');\n   *\n   */\n  class DomModule extends HTMLElement {\n\n    static get observedAttributes() { return ['id'] }\n\n    attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    _styleOutsideTemplateCheck() {\n      if (this.querySelector('style')) {\n        console.warn('dom-module %s has style outside template', this.id);\n      }\n    }\n\n    get assetpath() {\n      let assetpath = this.__assetpath || this.getAttribute('assetpath');\n      // Don't override existing assetpath.\n      if (assetpath) {}\n      // Polyfilled import.\n      else if (window.HTMLImports && !HTMLImports.useNative &&\n        HTMLImports.importForElement) {\n        const imp = HTMLImports.importForElement(this);\n        assetpath = imp ? imp.href : '';\n      }\n      // Native import.\n      else if (this.ownerDocument !== document && this.baseURI) {\n        assetpath = this.baseURI;\n      }\n      // Memoize.\n      this.__assetpath = assetpath;\n      return assetpath;\n    }\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @method register\n     * @param {string=} id The id at which to register the dom-module.\n     */\n    register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        this._styleOutsideTemplateCheck();\n      }\n    }\n\n    /**\n     * Retrieves the dom specified by `selector` in the module specified by\n     * `id`. For example, this.import('foo', 'img');\n     * @method register\n     * @param {string} id\n     * @param {string=} selector\n     * @return {Element} Returns the dom which matches `selector` in the module\n     * at the specified `id`.\n     */\n    import(id, selector) {\n      if (id) {\n        var m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n\n  }\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = new DomModule();\n\n})();\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/legacy/dom-module.html\n// module id = 26\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\n\n(function() {\n\n  'use strict';\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = HTMLElement.prototype;\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i=0; i<props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(goog.reflect.objectProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  Polymer.PropertyAccessors = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class PropertyAccessors extends superClass {\n\n      constructor() {\n        super();\n        this._initializeProperties();\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Override to initialize with e.g. default values by setting values into\n       * accessors.\n       *\n       * @protected\n       */\n      _initializeProperties() {\n        this.__data = {};\n        this.__dataCounter = 0;\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this.__dataInvalid = false;\n      }\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.  When calling on\n       * a prototype, any overwritten values are saved in `__dataProto`,\n       * and it is up to the subclasser to decide how/when to set those\n       * properties back into the accessor.  When calling on an instance,\n       * the overwritten value is set via `_setPendingProperty`, and the\n       * user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        Object.defineProperty(this, property, {\n          get: function() {\n            return this.__data && this.__data[property];\n          },\n          set: readOnly ? function() { } : function(value) {\n            this._setProperty(property, value);\n          }\n        });\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setPendingProperty(property, value) {\n        let old = this.__data[property];\n        if (this._shouldPropertyChange(property, value, old)) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n      _isPropertyPending(prop) {\n        return this.__dataPending && (prop in this.__dataPending);\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid) {\n          this.__dataInvalid = true;\n          Promise.resolve().then(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes.\n       *\n       * @protected\n       */\n      _flushProperties() {\n        let oldProps = this.__dataOld;\n        let changedProps = this.__dataPending;\n        this.__dataPending = null;\n        this.__dataCounter++;\n        this._propertiesChanged(this.__data, changedProps, oldProps);\n        this.__dataCounter--;\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {Object} currentProps Bag of all current accessor values\n       * @param {Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` for primitive types if a\n       * strict equality check fails, and returns `true` for all Object/Arrays.\n       * The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property\n       * @param {*} value\n       * @param {*} old\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check for primitives\n          (old !== value &&\n           // This ensures (old==NaN, value==NaN) always returns false\n           (old === old || value === value))\n        );\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/properties/property-accessors.html\n// module id = 27\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\nrequire('../utils/path.html');\n\nrequire('./property-accessors.html');\n\nrequire('../attributes/attributes.html');\n\nrequire('../utils/case-map.html');\n\nrequire('../template/template-stamp.html');\n\n\n(function() {\n\n  'use strict';\n\n  const CaseMap = Polymer.CaseMap;\n  const mixin = Polymer.Utils.mixin;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  let dedupeId = 0;\n\n  // Property effect types; effects are stored on the prototype using these keys\n  const TYPES = {\n    ANY: '__propertyEffects',\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n  }\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    let effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (let p in effects) {\n        // TODO(kschaaf): replace with fast array copy #!%&$!\n        effects[p] = effects[p].slice();\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {string} type Type of effect to run\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, fromAbove, hasPaths) {\n    if (effects) {\n      let ran;\n      let id = dedupeId++;\n      for (let prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, fromAbove, hasPaths)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Array} effects Array of effects\n   * @param {number} id Effect run id used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} value Value of changed property\n   * @param {*} old Previous value of changed property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, fromAbove, hasPaths) {\n    let ran;\n    // TODO(kschaaf) ideally a system exists to parse path information once\n    // and send structured information through the system for better perf\n    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    let fxs = effects[rootProperty];\n    if (fxs) {\n      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n            (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          fx.fn(inst, prop, props, oldProps, fx.info, fromAbove, hasPaths);\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {Object} trigger Descriptor \n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      let triggerPath = trigger.name;\n      return (triggerPath == path) ||\n        (trigger.structured && Polymer.Path.isAncestor(triggerPath, path)) ||\n        (trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path));\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    let fn = inst[info.methodName];\n    if (fn) {\n      fn.call(inst, inst.__data[property], oldProps[property]);\n    } else {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {Element} inst The instance with effects to run\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @private\n   */\n  function runNotifyEffects(inst, props, oldProps, fromAbove, hasPaths) {\n    // Notify\n    let fxs = inst.__notifyEffects;\n    if (fxs || hasPaths) {\n      let notified;\n      let id = dedupeId++;\n      // Try normal notify effects; if none, fall back to try path notification\n      for (let prop in props) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, fromAbove, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n      // Flush host if we actually notified and host was batching\n      let host;\n      if (notified && (host = inst.__dataHost) && host._flushProperties) {\n        host._flushProperties();\n      }\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {*} value\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    let rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    let detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    inst.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, fromAbove, hasPaths) {\n    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    let path = rootProperty != property ? property : null;\n    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property];  // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {Object} inst Host element instance to handle notification event\n   * @param {Object} info Listener metadata stored via addAnnotatedListener\n   * @private\n   */\n  function addNotifyListener(node, inst, info) {\n    node.addEventListener(info.event, function(e) {\n      handleNotification(e, inst, info.property, info.path, info.negate);\n    });\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `_bindListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {Event} e Notification event (e.g. '<property>-changed')\n   * @param {Object} inst Host element instance handling the notification event\n   * @param {string} property Child element property that was bound\n   * @param {string} path Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(e, inst, property, path, negate) {\n    let value;\n    let targetPath = e.detail && e.detail.path;\n    if (targetPath) {\n      path = Polymer.Path.translate(property, path, targetPath);\n      value = e.detail && e.detail.value;\n    } else {\n      value = e.target[property];\n    }\n    value = negate ? !value : value;\n    setPropertyFromNotification(inst, path, value, e);\n  }\n\n  /**\n   * Called by 2-way binding notification event listeners to set a property\n   * or path to the host based on a notification from a bound child.\n   *\n   * @param {string} path Path on this instance to set\n   * @param {*} value Value to set to given path\n   * @protected\n   */\n  function setPropertyFromNotification(inst, path, value, event) {\n    let detail = event.detail;\n    if (detail && detail.queueProperty) {\n      if (!inst.__readOnly || !inst.__readOnly[path]) {\n        inst._setPendingPropertyOrPath(path, value, Boolean(detail.path));\n      }\n    } else {\n      inst.set(path, value);\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    let value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @return {Object | null | undefined} Bag of newly computed properties from \"computed\" effects\n   */\n  function runComputedEffects(inst, changedProps, oldProps, fromAbove, hasPaths) {\n    let computeEffects = inst.__computeEffects;\n    if (computeEffects) {\n      let inputProps = changedProps;\n      let computedProps;\n      while (runEffects(inst, computeEffects, inputProps, fromAbove, hasPaths)) {\n        mixin(oldProps, inst.__dataOld);\n        mixin(changedProps, inst.__dataPending);\n        computedProps = mixin(computedProps || {}, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n      return computedProps;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    var result = runMethodEffect(inst, property, props, oldProps, info);\n    var computedProp = info.methodInfo;\n    if (inst.__propertyEffects && inst.__propertyEffects[computedProp]) {\n      inst._setPendingProperty(computedProp, result);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {Element} inst The instance whose props are changing\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object | undefined} computedProps Bag of properties newly computed this turn\n   *   via \"computed\" effects; any linked paths generated via this method\n   *   will be added both to the set of `changedProps` as well as to the\n   *   set of `computedProps`; this is because the `fromAbove: true` case will\n   *   notify only from the `computedProps` bag.\n   * @return {Object | undefined}\n   * @private\n   */\n  function computeLinkedPaths(inst, changedProps, computedProps, hasPaths) {\n    let links;\n    if (hasPaths && (links = inst.__dataLinkedPaths)) {\n      const cache = inst.__dataTemp;\n      computedProps = computedProps || {};\n      let link;\n      for (let a in links) {\n        let b = links[a];\n        for (let path in changedProps) {\n          if (Polymer.Path.isDescendant(a, path)) {\n            link = Polymer.Path.translate(a, b, path);\n            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];\n          } else if (Polymer.Path.isDescendant(b, path)) {\n            link = Polymer.Path.translate(b, a, path);\n            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];\n          }\n        }\n      }\n    }\n    return computedProps;\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds \"binding\" property effects for the template annotation\n   * (\"note\" for short) and node index specified.  These may either be normal\n   * \"binding\" effects (property/path bindings) or \"method binding\"\n   * effects, aka inline computing functions, depending on the type of binding\n   * detailed in the note.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {Object} note Annotation note returned from Annotator\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   note applies to\n   * @private\n   */\n  function addBindingEffect(model, note, index) {\n    for (let i=0; i<note.parts.length; i++) {\n      let part = note.parts[i];\n      if (part.signature) {\n        addMethodBindingEffect(model, note, part, index);\n      } else if (!part.literal) {\n        if (note.kind === 'attribute' && note.name[0] === '-') {\n          console.warn('Cannot set attribute ' + note.name +\n            ' because \"-\" is not a valid attribute starting character');\n        } else {\n          model._addPropertyEffect(Polymer.Path.root(part.value), TYPES.PROPAGATE, {\n            fn: runBindingEffect,\n            info:  {\n              kind: note.kind,\n              index: index,\n              name: note.name,\n              propertyName: note.propertyName,\n              value: part.value,\n              isCompound: note.isCompound,\n              compoundIndex: part.compoundIndex,\n              event: part.event,\n              customEvent: part.customEvent,\n              negate: part.negate\n            }\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, fromAbove, hasPaths) {\n    let value;\n    let node = inst.__dataNodes[info.index];\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && (path.length > info.value.length) &&\n        (info.kind == 'property') && !info.isCompound &&\n        node.__propertyEffects && node.__propertyEffects[info.name]) {\n      let value = props[path];\n      path = Polymer.Path.translate(info.value, info.name, path);\n      if (node._setPendingPropertyOrPath(path, value, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      // Root or deeper path was set; extract bound path value\n      // e.g.: foo=\"{{obj.sub}}\", path: 'obj', set 'foo'=obj.sub\n      //   or: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo'=obj.sub\n      if (path != info.value) {\n        value = Polymer.Path.get(inst, info.value);\n      } else {\n        if (hasPaths && Polymer.Path.isPath(path)) {\n          value = Polymer.Path.get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      // Propagate value to child\n      applyBindingValue(inst, info, value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {Object} inst The instance owning the binding effect\n   * @param {Object} info Effect metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, info, value) {\n    let node = inst.__dataNodes[info.index];\n    value = computeBindingValue(node, value, info);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.name, info.kind, node);\n    }\n    if (info.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute(node, value, info.name);\n    } else {\n      // Property binding\n      let prop = info.name;\n      if (node.__propertyEffects && node.__propertyEffects[prop]) {\n        if (!node.__readOnly || !node.__readOnly[prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else  {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {Object} info Effect metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, info) {\n    if (info.negate) {\n      value = !value;\n    }\n    if (info.isCompound) {\n      let storage = node.__dataCompoundStorage[info.name];\n      storage[info.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (info.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (info.name === 'textContent' ||\n          (node.localName == 'input' && info.name == 'value')) {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Adds \"binding method\" property effects for the template binding\n   * (\"note\" for short), part metadata, and node index specified.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {Object} note Binding note returned from Annotator\n   * @param {Object} part The compound part metadata\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   note applies to\n   * @private\n   */\n  function addMethodBindingEffect(model, note, part, index) {\n    createMethodEffect(model, part.signature, TYPES.PROPAGATE,\n      runMethodBindingEffect, {\n        index: index,\n        isCompound: note.isCompound,\n        compoundIndex: part.compoundIndex,\n        kind: note.kind,\n        name: note.name,\n        negate: part.negate,\n        part: part\n      }, true\n    );\n  }\n\n  /**\n   * Implements the \"binding method\" (inline computed function) effect.\n   *\n   * Runs the method with the values of the arguments specified in the `info`\n   * object and setting the return value to the node property/attribute.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runMethodBindingEffect(inst, property, props, oldProps, info) {\n    let val = runMethodEffect(inst, property, props, oldProps, info);\n    applyBindingValue(inst, info.methodInfo, val);\n  }\n\n  /**\n   * Post-processes template bindings (notes for short) provided by the\n   * Bindings library for use by the effects system:\n   * - Parses bindings for methods into method `signature` objects\n   * - Memoizes the root property for path bindings\n   * - Recurses into nested templates and processes those templates and\n   *   extracts any host properties, which are set to the template's\n   *   `_content._hostProps`\n   * - Adds bindings from the host to <template> elements for any nested\n   *   template's lexically bound \"host properties\"; template handling\n   *   elements can then add accessors to the template for these properties\n   *   to forward host properties into template instances accordingly.\n   *\n   * @param {Array<Object>} notes List of notes to process; the notes are\n   *   modified in place.\n   * @private\n   */\n  function processAnnotations(notes) {\n    if (!notes._processed) {\n      for (let i=0; i<notes.length; i++) {\n        let note = notes[i];\n        // Parse bindings for methods & path roots (models)\n        for (let j=0; j<note.bindings.length; j++) {\n          let b = note.bindings[j];\n          for (let k=0; k<b.parts.length; k++) {\n            let p = b.parts[k];\n            if (!p.literal) {\n              p.signature = parseMethod(p.value);\n              if (!p.signature) {\n                p.rootProperty = Polymer.Path.root(p.value);\n              }\n            }\n          }\n        }\n        // Recurse into nested templates & bind host props\n        if (note.templateContent) {\n          processAnnotations(note.templateContent._notes);\n          let hostProps = note.templateContent._hostProps =\n            discoverTemplateHostProps(note.templateContent._notes);\n          let bindings = [];\n          for (let prop in hostProps) {\n            bindings.push({\n              index: note.index,\n              kind: 'property',\n              name: '_host_' + prop,\n              parts: [{\n                mode: '{',\n                value: prop\n              }]\n            });\n          }\n          note.bindings = note.bindings.concat(bindings);\n        }\n      }\n      notes._processed = true;\n    }\n  }\n\n  /**\n   * Finds all property usage in templates (property/path bindings and function\n   * arguments) and returns the path roots as keys in a map. Each outer template\n   * merges inner _hostProps to propagate inner host property needs to outer\n   * templates.\n   *\n   * @param {Array<Object>} notes List of notes to process for a given template\n   * @return {Object<string,boolean>} Map of host properties that the template\n   *   (or any nested templates) uses\n   * @private\n   */\n  function discoverTemplateHostProps(notes) {\n    let hostProps = {};\n    for (let i=0, n; (i<notes.length) && (n=notes[i]); i++) {\n      // Find all bindings to parent.* and spread them into _parentPropChain\n      for (let j=0, b$=n.bindings, b; (j<b$.length) && (b=b$[j]); j++) {\n        for (let k=0, p$=b.parts, p; (k<p$.length) && (p=p$[k]); k++) {\n          if (p.signature) {\n            let args = p.signature.args;\n            for (let kk=0; kk<args.length; kk++) {\n              let rootProperty = args[kk].rootProperty;\n              if (rootProperty) {\n                hostProps[rootProperty] = true;\n              }\n            }\n            hostProps[p.signature.methodName] = true;\n          } else {\n            if (p.rootProperty) {\n              hostProps[p.rootProperty] = true;\n            }\n          }\n        }\n      }\n      // Merge child _hostProps into this _hostProps\n      if (n.templateContent) {\n        let templateHostProps = n.templateContent._hostProps;\n        Polymer.Base.mixin(hostProps, templateHostProps);\n      }\n    }\n    return hostProps;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a <property>-changed event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {Object} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return binding.name &&\n           binding.kind != 'attribute' &&\n           binding.kind != 'text' &&\n           !binding.isCompound &&\n           binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Sets up a prototypical `_bindListeners` metadata array to be used at\n   * instance time to add event listeners for 2-way bindings.\n   *\n   * @param {Object} model Prototype (instances not currently supported)\n   * @param {number} index Index into `__dataNodes` list of annotated nodes that the\n   *   event should be added to\n   * @param {string} property Property of target node to listen for changes\n   * @param {string} path Host path that the change should be propagated to\n   * @param {string=} event A custom event name to listen for (e.g. via the\n   *   `{{prop::eventName}}` syntax)\n   * @param {boolean=} negate Whether the notified value should be negated before\n   *   setting to host path\n   * @private\n   */\n  function addAnnotatedListener(model, index, property, path, event, negate) {\n    if (!model._bindListeners) {\n      model._bindListeners = [];\n    }\n    let eventName = event ||\n      (CaseMap.camelToDashCase(property) + '-changed');\n    model._bindListeners.push({\n      index: index,\n      property: property,\n      path: path,\n      event: eventName,\n      negate: negate\n    });\n  }\n\n  /**\n   * Adds all 2-way binding notification listeners to a host based on\n   * `_bindListeners` metadata recorded by prior calls to`addAnnotatedListener`\n   *\n   * @param {Object} inst Host element instance\n   * @private\n   */\n  function setupBindListeners(inst) {\n    let b$ = inst._bindListeners;\n    for (let i=0, l=b$.length, info; (i<l) && (info=b$[i]); i++) {\n      let node = inst.__dataNodes[info.index];\n      addNotifyListener(node, inst, info);\n    }\n  }\n\n  /**\n   * Finds all bound nodes in the given `dom` fragment that were recorded in the\n   * provided Annotator `notes` array and stores them in `__dataNodes` for this\n   * instance.  The index of nodes in `__dataNodes` corresponds to the index\n   * of a note in the `notes` array, and binding effect metadata uses this\n   * index to identify bound nodes when propagating data.\n   *\n   * Compound binding storage structures are also initialized onto the bound\n   * nodes, and 2-way binding event listeners are also added.\n   *\n   * @param {Object} inst Instance that bas been previously bound\n   * @param {DocumentFragment} dom Document fragment containing stamped nodes\n   * @param {Array<Object>} notes Array of annotation notes provided by\n   *   Polymer.Annotator\n   * @private\n   */\n  function setupBindings(inst, dom, notes) {\n    if (notes.length) {\n      let nodes = new Array(notes.length);\n      for (let i=0; i < notes.length; i++) {\n        let note = notes[i];\n        let node = nodes[i] = inst._findTemplateAnnotatedNode(dom, note);\n        node.__dataHost = inst;\n        if (note.bindings) {\n          setupCompoundBinding(note, node);\n        }\n      }\n      inst.__dataNodes = nodes;\n    }\n    if (inst._bindListeners) {\n      setupBindListeners(inst);\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {Object} sig Method signature metadata\n   * @param {string} type\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo\n   * @param {boolean=} dynamic Whether the method name should be included as\n   *   a dependency to the effect.\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamic) {\n    let info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo: methodInfo,\n      dynamicFn: dynamic\n    };\n    // TODO(sorvell): why still here?\n    if (sig.static) {\n      model._addPropertyEffect('__static__', type, {\n        fn: effectFn, info: info\n      });\n    } else {\n      for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n        if (!arg.literal) {\n          model._addPropertyEffect(arg.rootProperty, type, {\n            fn: effectFn, info: info, trigger: arg\n          });\n        }\n      }\n    }\n    if (dynamic) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {*} value Current value of property\n   * @param {*} old Previous value of property\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    let context = inst._methodHost || inst;\n    let fn = context[info.methodName];\n    if (fn) {\n      let args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  const emptyArray = [];\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?Object} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      let sig = { methodName: m[1], static: true };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        sig.args = emptyArray;\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {Array<string>} argList Array of argument names\n   * @param {Object} sig Method signature metadata object\n   * @return {Object} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function(rawArg) {\n      let arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {Object} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    let arg = rawArg.trim()\n      // replace comma entity with comma\n      .replace(/&comma;/g, ',')\n      // repair extra escape sequences; note only commas strictly need\n      // escaping, but we allow any other char to be escaped since its\n      // likely users will do this\n      .replace(/\\\\(.)/g, '\\$1')\n      ;\n    // basic argument descriptor\n    let a = {\n      name: arg\n    };\n    // detect literal value (must be String or Number)\n    let fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch(fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isDeep(arg);\n      if (a.structured) {\n        a.wildcard = (arg.slice(-2) == '.*');\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {Array<Object>} args Array of argument metadata\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    let values = [];\n    for (let i=0, l=args.length; i<l; i++) {\n      let arg = args[i];\n      let name = arg.name;\n      let v;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        let baseChanged = (name.indexOf(path + '.') === 0);\n        let matches = (path.indexOf(name) === 0 && !baseChanged);\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Object} note Annotation metadata\n   * @param {Node} node Bound node to initialize\n   * @private\n   */\n  function setupCompoundBinding(note, node) {\n    let bindings = note.bindings;\n    for (let i=0; i<bindings.length; i++) {\n      let binding = bindings[i];\n      if (binding.isCompound) {\n        // Create compound storage map\n        let storage = node.__dataCompoundStorage ||\n          (node.__dataCompoundStorage = {});\n        let parts = binding.parts;\n        // Copy literals from parts into storage for this binding\n        let literals = new Array(parts.length);\n        for (let j=0; j<parts.length; j++) {\n          literals[j] = parts[j].literal;\n        }\n        let name = binding.name;\n        storage[name] = literals;\n        // Configure properties with their literal parts\n        if (binding.literal && binding.kind == 'property') {\n          // TODO(kschaaf) config integration\n          // if (node._configValue) {\n          //   node._configValue(name, binding.literal);\n          // } else {\n            node[name] = binding.literal;\n          // }\n        }\n      }\n    }\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function notifySplices(inst, array, path, splices) {\n    let splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = {indexSplices: null};\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  Polymer.PropertyEffects = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    const mixin = Polymer.TemplateStamp(\n      Polymer.Attributes(Polymer.PropertyAccessors(superClass)));\n\n    /**\n     * @unrestricted\n     */\n    class PropertyEffects extends mixin {\n\n      get PROPERTY_EFFECT_TYPES() {\n        return TYPES;\n      }\n\n      constructor() {\n        super();\n        this._asyncEffects = false;\n        this.__dataInitialized = false;\n        this.__dataPendingClients = null;\n        this.__dataFromAbove = false;\n        this.__dataLinkedPaths = null;\n        this.__dataNodes = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n      }\n\n      /**\n       * Adds to default initialization in `PropertyAccessors` by initializing\n       * local property & pending data storage with any accessor values saved\n       * in `__dataProto`.  If instance properties had been set before the\n       * element upgraded and gained accessors on its prototype, these values\n       * are set into the prototype's accessors after being deleted from the\n       * instance.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        super._initializeProperties();\n        this.__dataTemp = {};\n        // initialize data with prototype values saved when creating accessors\n        if (this.__dataProto) {\n          this.__data = Object.create(this.__dataProto);\n          this.__dataPending = Object.create(this.__dataProto);\n          this.__dataOld = {};\n        } else {\n          this.__dataPending = null;\n        }\n        // update instance properties\n        for (let p in this.__propertyEffects) {\n          if (this.hasOwnProperty(p)) {\n            let value = this[p];\n            delete this[p];\n            this[p] = value;\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *   {\n       *     fn: effectFunction, // Reference to function to call to perform effect\n       *     info: { ... }       // Effect metadata passed to function\n       *     // path: '...'      // Will be set by this method based on path arg\n       *   }\n       *\n       * Effect functions are called with the following signature:\n       *\n       *   effectFunction(inst, property, currentValue, oldValue, info)\n       *\n       * This method may be called either on the prototype of a class\n       * using the PropertyEffects mixin (for best performance), or on\n       * an instance to add dynamic effects.  When called on an instance or\n       * subclass of a class that has already had property effects added to\n       * its prototype, the property effect lists will be cloned and added as\n       * own properties of the caller.\n       *\n       * @param {string} path Property (or path) that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      _addPropertyEffect(property, type, effect) {\n        let effects = ensureOwnEffectMap(this, TYPES.ANY)[property];\n        if (!effects) {\n          effects = this.__propertyEffects[property] = [];\n          this._createPropertyAccessor(property,\n            type == TYPES.READ_ONLY);\n        }\n        // effects are accumulated into arrays per property based on type\n        if (effect) {\n          effects.push(effect);\n        }\n        effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasPropertyEffect(property, type) {\n        let effects = this[type || TYPES.ANY];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, isPathNotification) {\n        let rootProperty = Polymer.Path.root(Array.isArray(path) ? path[0] : path);\n        let hasEffect = this.__propertyEffects && this.__propertyEffects[rootProperty];\n        let isPath = (rootProperty !== path);\n        if (hasEffect) {\n          if (isPath) {\n            if (!isPathNotification) {\n              // Dirty check changes being set to a path against the actual object,\n              // since this is the entry point for paths into the system; from here\n              // the only dirty checks are against the `__dataTemp` cache to prevent\n              // duplicate work in the same turn only. Note, if this was a notification\n              // of a change already set to a path (isPathNotification: true),\n              // we always let the change through and skip the `set` since it was\n              // already dirty checked at the point of entry and the underlying\n              // object has already been updated\n              let old = Polymer.Path.get(this, path);\n              path = /** @type {string} */ Polymer.Path.set(this, path, value);\n              // Use property-accessor's simpler dirty check\n              if (!path || !super._shouldPropertyChange(path, value, old)) {\n                return false;\n              }\n            }\n            this.__dataHasPaths = true;\n          }\n          return this._setPendingProperty(path, value);\n        } else {\n          if (isPath) {\n            Polymer.Path.set(this, path, value);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       * \n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting <input>.value resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information. \n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertyAccessors` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChaged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       */\n      _setPendingProperty(property, value) {\n        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n        let prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths and objects are stored in temporary cache (cleared at end of\n          // turn), which is used for dirty-checking\n          if (isPath || typeof value == 'object') {\n            this.__dataTemp[property] = value;\n          }\n          // Properties (but not sub-paths) get stored __data cache, used to\n          // return accessor values from getters\n          if (!isPath) {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Overrides default PropertyAccessors implementation to pull the value\n       * to dirty check against from the `__dataTemp` cache (rather than the\n       * normal `__data` cache) for Objects.  Since the temp cache is cleared\n       * at the end of a turn, this implementation allows side-effects of deep\n       * object changes to be processed by re-setting the same object (using\n       * the temp cache as a backstop to prevent cycles due to 2-way\n       * notification).\n       *\n       * Override this to provide more strict dirty checking, i.e. immutable\n       * (`value === old`) or based on type.\n       *\n       * TODO(kschaaf): Can this go away (and just use @override) once we start using mixin interfaces?\n       * @override\n       * @param {string} property\n       * @param {*} value\n       * @param {*} old\n       * @return {boolean}\n       */\n      _shouldPropertyChange(property, value, old) {\n        if (typeof value == 'object') {\n          old = this.__dataTemp[property];\n        }\n        return super._shouldPropertyChange(property, value, old);\n      }\n\n      /**\n       * Overrides PropertyAccessor's default async queuing of\n       * `_propertiesChanged`: if `__dataInitialized` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       */\n      _invalidateProperties() {\n        if (this.__dataInitialized) {\n          //TODO(kschaaf): consider option to flush async\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @protected\n       */\n      _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @protected\n       */\n      _flushClients() {\n        // Flush all clients\n        let clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (let i=0; i < clients.length; i++) {\n            let client = clients[i];\n            // TODO(kschaaf): more explicit check?\n            if (!client.__dataInitialized || client.__dataPending) {\n              client._flushProperties(true);\n            }\n          }\n        }\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       */\n      setProperties(props) {\n        for (let path in props) {\n          if (!this.__readOnly || !this.__readOnly[path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path]);\n          }\n        }\n        this._invalidateProperties();\n      }\n      /**\n       * Overrides PropertyAccessor's default async queuing of\n       * `_propertiesChanged`, to instead synchronously flush\n       * `_propertiesChanged` unless the `this._asyncEffects` property is true.\n       *\n       * If this is the first time properties are being flushed, the `ready`\n       * callback will be called.\n       *\n       * Also adds an optional `fromAbove` argument to indicate when properties\n       * are being flushed by a host during data propagation. This information\n       * is used to avoid sending upwards notification events in response to\n       * downward data flow.  This is a performance optimization, but also\n       * critical to avoid infinite looping when an object is notified, since\n       * the default implementation of `_shouldPropertyChange` always returns\n       * true for Objects, and without would result in a notify-propagate-notify\n       * loop.\n       *\n       * @param {boolean=} fromAbove When true, sets `this.__dataFromAbove` to\n       *   `true` for the duration of the call to `_propertiesChanged`.\n       * @override\n       */\n      _flushProperties(fromAbove) {\n        if (!this.__dataInitialized) {\n          this.ready();\n        }\n        if (this.__dataPending || this.__dataPendingClients) {\n          this.__dataFromAbove = fromAbove;\n          super._flushProperties();\n          if (!this.__dataCounter) {\n            // Clear temporary cache at end of turn\n            this.__dataTemp = {};\n          }\n        }\n      }\n\n      /**\n       * Polymer-specific lifecycle callback called the first time properties\n       * are being flushed.  Prior to `ready`, all property sets through\n       * accessors are queued and their effects are flushed after this method\n       * returns.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its properties initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or binding values propagated from host\n       * \"binding effects\".  `super.ready()` must be called to ensure the\n       * data system becomes enabled.\n       *\n       * @public\n       */\n      ready() {\n        this.__dataInitialized = true;\n      }\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * Note that for host data to be bound into the stamped DOM, the template\n       * must have been previously bound to the prototype via a call to\n       * `_bindTemplate`, which performs one-time template binding work.\n       *\n       * Note that this method currently only supports being called once per\n       * instance.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       * @protected\n       */\n      _stampTemplate(template) {\n        let dom = super._stampTemplate(template);\n        let notes = (template._content || template.content)._notes;\n        setupBindings(this, dom, notes);\n        return dom;\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        let hasPaths = this.__dataHasPaths;\n        let fromAbove = this.__dataFromAbove;\n        this.__dataHasPaths = this.__dataFromAbove = false;\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        // Compute properties\n        let computedProps = runComputedEffects(this, changedProps, oldProps, fromAbove, hasPaths);\n        // Compute linked paths\n        computedProps = computeLinkedPaths(this, changedProps, computedProps, hasPaths);\n        // Propagate properties to clients\n        runEffects(this, this.__propagateEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this.__reflectEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Observe properties\n        runEffects(this, this.__observeEffects, changedProps, oldProps, fromAbove, hasPaths);\n        // Notify properties to host\n        runNotifyEffects(this, fromAbove ? computedProps : changedProps, oldProps, fromAbove, hasPaths);\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @method linkPaths\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @public\n       */\n      linkPaths(to, from) {\n        to = Polymer.Path.normalize(to);\n        from = Polymer.Path.normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @method unlinkPaths\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @public\n       */\n      unlinkPaths(path) {\n        path = Polymer.Path.normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @public\n      */\n      notifySplices(path, splices) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @method get\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root) {\n        return Polymer.Path.get(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @method set\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @public\n      */\n      set(path, value, root) {\n        if (root) {\n          Polymer.Path.set(root, path, value);\n        } else {\n          if (!this.__readOnly || !this.__readOnly[/** @type {string} */(path)]) {\n            if (this._setPendingPropertyOrPath(path, value)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method push\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = {};\n        let array = /** @type {Array}*/(Polymer.Path.get(this, path, info));\n        let len = array.length;\n        let ret = array.push(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method pop\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method splice\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else {\n          start = Math.floor(start);\n        }\n        if (!start) {\n          start = 0;\n        }\n        let ret = array.splice(start, deleteCount, ...items);\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method shift\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @method unshift\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let ret = array.unshift(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @public\n      */\n      notifyPath(path, value) {\n        /** @type {string} */\n        let propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          let info = {};\n          value = Polymer.Path.get(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = Polymer.Path.normalize(path);\n        } else {\n          propPath = /** @type{string} */(path);\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = function(value) {\n            this._setProperty(property, value);\n          }\n        }\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @protected\n       */\n      _createObservedProperty(property, methodName) {\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info: {\n            methodName: methodName\n          },\n          trigger: {name: property}\n        });\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal Javascript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @protected\n       */\n      _createMethodObserver(expression) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createReflectedProperty(property) {\n        let attr = CaseMap.camelToDashCase(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n            attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal Javascript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @protected\n       */\n      _createComputedProperty(property, expression) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property);\n      }\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Creates \"binding\" property effects for all binding bindings\n       * in the provided template that forward host properties into DOM stamped\n       * from the template via `_stampTemplate`.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @protected\n       */\n      _bindTemplate(template) {\n        // Clear any existing propagation effects inherited from superClass\n        this.__propagateEffects = {};\n        let notes = this._parseTemplateAnnotations(template);\n        processAnnotations(notes);\n        for (let i=0, note; (i<notes.length) && (note=notes[i]); i++)  {\n          // where to find the node in the concretized list\n          let b$ = note.bindings;\n          for (let j=0, binding; (j<b$.length) && (binding=b$[j]); j++) {\n            if (shouldAddListener(binding)) {\n              addAnnotatedListener(this, i, binding.name,\n                binding.parts[0].value,\n                binding.parts[0].event,\n                binding.parts[0].negate);\n            }\n            addBindingEffect(this, binding, i);\n          }\n        }\n      }\n\n    }\n\n    return PropertyEffects;\n  });\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/properties/property-effects.html\n// module id = 28\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../template/resolve-url.html');\n\n\n(function() {\n  'use strict';\n\n  var StyleGather = {\n    MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',\n    INCLUDE_ATTR: 'include',\n    _importModule(moduleId) {\n      if (!Polymer.DomModule) {\n        return null;\n      }\n      return Polymer.DomModule.import(moduleId);\n    },\n    /**\n     * @param {string} moduleIds\n     * @param {boolean=} warnIfNotFound\n     * @return {string}\n     */\n    cssFromModules(moduleIds, warnIfNotFound) {\n      var modules = moduleIds.trim().split(' ');\n      var cssText = '';\n      for (var i=0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i], warnIfNotFound);\n      }\n      return cssText;\n    },\n\n    // returns cssText of styles in a given module; also un-applies any\n    // styles that apply to the document.\n    cssFromModule(moduleId, warnIfNotFound) {\n      var m = this._importModule(moduleId);\n      if (m && !m._cssText) {\n        m._cssText = this.cssFromElement(m);\n      }\n      if (!m && warnIfNotFound) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n    // support lots of ways to discover css...\n    cssFromElement(element) {\n      var cssText = '';\n      // if element is a template, get content from its .content\n      var content = element.content || element;\n      var e$ = content.querySelectorAll(this.MODULE_STYLES_SELECTOR);\n      for (var i=0, e; i < e$.length; i++) {\n        e = e$[i];\n        // look inside templates for elements\n        if (e.localName === 'template') {\n          cssText += this.cssFromElement(e);\n        } else {\n          // style elements inside dom-modules will apply to the main document\n          // we don't want this, so we remove them here.\n          if (e.localName === 'style') {\n            var include = e.getAttribute(this.INCLUDE_ATTR);\n            // now support module refs on 'styling' elements\n            if (include) {\n              cssText += this.cssFromModules(include, true);\n            }\n            // get style element applied to main doc via HTMLImports polyfill\n            e = e.__appliedElement || e;\n            e.parentNode.removeChild(e);\n            cssText += Polymer.ResolveUrl.resolveCss(e.textContent, element.ownerDocument);\n            // it's an import, assume this is a text file of css content.\n            // TODO(sorvell): plan is to deprecate this way to get styles;\n            // remember to add deprecation warning when this is done.\n          } else if (e.import && e.import.body) {\n            cssText += Polymer.ResolveUrl.resolveCss(e.import.body.textContent, e.import);\n          }\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/styling/style-gather.html\n// module id = 29\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n  (function() {\n    'use strict';\n\n    var StyleUtil = {\n\n      isTargetedBuild: function(buildType) {\n        return (!window.ShadyDOM || !ShadyDOM.inUse) ?\n          buildType === 'shadow' : buildType === 'shady';\n      },\n\n      cssBuildTypeForModule: function (module) {\n        var dm = Polymer.DomModule.import(module);\n        if (dm) {\n          return this.getCssBuildType(dm);\n        }\n      },\n\n      getCssBuildType: function(element) {\n        return element.getAttribute('css-build');\n      }\n\n    };\n\n    Polymer.StyleUtil = StyleUtil;\n\n  })();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/styling/style-util.html\n// module id = 30\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('../utils/boot.html');\n\nrequire('../utils/utils.html');\n\nrequire('../utils/case-map.html');\n\nrequire('./resolve-url.html');\n\n\n/**\n * Scans a template to produce an annotation list that that associates\n * metadata culled from markup with tree locations\n * metadata and information to associate the metadata with nodes in an instance.\n *\n * Supported expressions include:\n *\n * Double-mustache annotations in text content. The annotation must be the only\n * content in the tag, compound expressions are not supported.\n *\n *     <[tag]>{{annotation}}<[tag]>\n *\n * Double-escaped annotations in an attribute, either {{}} or [[]].\n *\n *     <[tag] someAttribute=\"{{annotation}}\" another=\"[[annotation]]\"><[tag]>\n *\n * `on-` style event declarations.\n *\n *     <[tag] on-<event-name>=\"annotation\"><[tag]>\n *\n * Note that the `annotations` feature does not implement any behaviors\n * associated with these expressions, it only captures the data.\n *\n * Generated data-structure:\n *\n *     [\n *       {\n *         id: '<id>',\n *         events: [\n *           {\n *             name: '<name>'\n *             value: '<annotation>'\n *           }, ...\n *         ],\n *         bindings: [\n *           {\n *             kind: ['text'|'attribute'],\n *             mode: ['{'|'['],\n *             name: '<name>'\n *             value: '<annotation>'\n *           }, ...\n *         ],\n *         // TODO(sjmiles): this is annotation-parent, not node-parent\n *         parent: <reference to parent annotation object>,\n *         index: <integer index in parent's childNodes collection>\n *       },\n *       ...\n *     ]\n *\n * @class Annotations feature\n */\n(function() {\n\n  'use strict';\n\n  // null-array (shared empty array to avoid null-checks)\n  const emptyArray = [];\n\n  let bindingRegex = (function() {\n    let IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n    let NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n    let SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n    let DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n    let STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n    let ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\\\s*' + ')';\n    let ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n    let ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                                  '(?:' + ARGUMENTS + '?' + ')' +\n                                '\\\\)\\\\s*' + ')';\n    let BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n    let OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n    let CLOSE_BRACKET = '(?:]]|}})';\n    let NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n    let EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n    return new RegExp(EXPRESSION, \"g\");\n  })();\n\n  let insertionPointTag = 'slot';\n  let currentTemplate;\n\n  /**\n   * @param {HTMLTemplateElement} template\n   * @param {boolean=} stripWhiteSpace\n   * @return {Array<Object>}\n   */\n  function parseTemplateAnnotations(template, stripWhiteSpace) {\n    // TODO(kschaaf): File issue and/or remove when fixed\n    // hold a reference to content as _content to prevent odd Chrome gc issue\n    // nested templates also may receive their content as _content\n    let content = (template._content = template._content || template.content);\n    // since a template may be re-used, memo-ize notes.\n    if (!content._notes) {\n      content._notes = [];\n      // TODO(sorvell): whitespace and processAnnotations need to be factored\n      // into plugins\n      // TODO(kschaaf): template should be threaded through rather than implied state\n      currentTemplate = currentTemplate || template;\n      parseNodeAnnotations(content, content._notes,\n        stripWhiteSpace || template.hasAttribute('strip-whitespace'));\n    }\n    return content._notes;\n  }\n\n  // add annotations gleaned from subtree at `node` to `list`\n  function parseNodeAnnotations(node, list, stripWhiteSpace) {\n    return node.nodeType === Node.TEXT_NODE ?\n      parseTextNodeAnnotation(node, list) :\n        parseElementAnnotations(node, list, stripWhiteSpace);\n  }\n\n  // TODO(kschaaf): We could modify this to allow an escape mechanism by\n  // looking for the escape sequence in each of the matches and converting\n  // the part back to a literal type, and then bailing if only literals\n  // were found\n  function parseBindings(text) {\n    let parts = [];\n    let lastIndex = 0;\n    let m;\n    // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n    // Regex matches:\n    //        Iteration 1:  Iteration 2:\n    // m[1]: '{{'          '[['\n    // m[2]: ''            '!'\n    // m[3]: 'prop'        'compute(foo,bar)'\n    while ((m = bindingRegex.exec(text)) !== null) {\n      // Add literal part\n      if (m.index > lastIndex) {\n        parts.push({literal: text.slice(lastIndex, m.index)});\n      }\n      // Add binding part\n      // Mode (one-way or two)\n      let mode = m[1][0];\n      let negate = Boolean(m[2]);\n      let value = m[3].trim();\n      let customEvent, notifyEvent, colon;\n      if (mode == '{' && (colon = value.indexOf('::')) > 0) {\n        notifyEvent = value.substring(colon + 2);\n        value = value.substring(0, colon);\n        customEvent = true;\n      }\n      parts.push({\n        compoundIndex: parts.length,\n        value: value,\n        mode: mode,\n        negate: negate,\n        event: notifyEvent,\n        customEvent: customEvent\n      });\n      lastIndex = bindingRegex.lastIndex;\n    }\n    // Add a final literal part\n    if (lastIndex && lastIndex < text.length) {\n      let literal = text.substring(lastIndex);\n      if (literal) {\n        parts.push({\n          literal: literal\n        });\n      }\n    }\n    if (parts.length) {\n      return parts;\n    }\n  }\n\n  function literalFromParts(parts) {\n    let s = '';\n    for (let i=0; i<parts.length; i++) {\n      let literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  // add annotations gleaned from TextNode `node` to `list`\n  function parseTextNodeAnnotation(node, list) {\n    let parts = parseBindings(node.textContent);\n    if (parts) {\n      // Initialize the textContent with any literal parts\n      // NOTE: default to a space here so the textNode remains; some browsers\n      // (IE) evacipate an empty textNode following cloneNode/importNode.\n      node.textContent = literalFromParts(parts) || ' ';\n      let note = {\n        bindings: [{\n          kind: 'text',\n          name: 'textContent',\n          parts: parts,\n          isCompound: parts.length !== 1\n        }]\n      };\n      list.push(note);\n      return note;\n    }\n  }\n\n  // add annotations gleaned from Element `node` to `list`\n  function parseElementAnnotations(element, list, stripWhiteSpace) {\n    let note = {\n      bindings: [],\n      events: []\n    };\n    if (element.localName === insertionPointTag) {\n      list._hasInsertionPoint = true;\n    }\n    parseChildNodesAnnotations(element, note, list, stripWhiteSpace);\n    if (element.attributes) {\n      parseNodeAttributeAnnotations(element, note);\n      prepElement(element);\n    }\n    if (note.bindings.length || note.events.length || note.id) {\n      list.push(note);\n    }\n    return note;\n  }\n\n  // add annotations gleaned from children of `root` to `list`, `root`'s\n  // `note` is supplied as it is the note.parent of added annotations\n  function parseChildNodesAnnotations(root, note, list, stripWhiteSpace) {\n    if (root.firstChild) {\n      let node = root.firstChild;\n      let i = 0;\n      while (node) {\n        // BREAKME(kschaaf): pseudo-bc auto-wrapper for template type extensions\n        if (node.localName === 'template') {\n          let t = node;\n          let is = t.getAttribute('is');\n          // stamp `<dom-*>` elements\n          if (is && is.indexOf('dom-') === 0) {\n            t.removeAttribute('is');\n            node = t.ownerDocument.createElement(is);\n            root.replaceChild(node, t);\n            node.appendChild(t);\n            while(t.attributes.length) {\n              node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n              t.removeAttribute(t.attributes[0].name);\n            }\n          }\n        }\n        if (node.localName === 'template' &&\n          !node.hasAttribute('preserve-content')) {\n          parseTemplate(node, i, list, note, stripWhiteSpace);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        let next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            // decrement index since node is removed\n            i--;\n          }\n        }\n        // if this node didn't get evacipated, parse it.\n        if (node.parentNode) {\n          let childAnnotation = parseNodeAnnotations(node, list,\n            stripWhiteSpace);\n          if (childAnnotation) {\n            childAnnotation.parent = note;\n            childAnnotation.index = i;\n          }\n        }\n        node = next;\n        i++;\n      }\n    }\n  }\n\n  // 1. Parse annotations from the template and memoize them on\n  //    content._notes (recurses into nested templates)\n  // 2. Remove template.content and store it in annotation list, where it\n  //    will be the responsibility of the host to set it back to the template\n  //    (this is both an optimization to avoid re-stamping nested template\n  //    children and avoids a bug in Chrome where nested template children\n  //    upgrade)\n  function parseTemplate(node, index, list, parent, stripWhiteSpace) {\n    let content = node.content.ownerDocument.createDocumentFragment();\n    content._notes = parseTemplateAnnotations(node, stripWhiteSpace);\n    content.appendChild(node.content);\n    list.push({\n      bindings: emptyArray,\n      events: emptyArray,\n      templateContent: content,\n      parent: parent,\n      index: index\n    });\n  }\n\n  // add annotation data from attributes to the `annotation` for node `node`\n  // TODO(sjmiles): the distinction between an `annotation` and\n  // `annotation data` is not as clear as it could be\n  function parseNodeAttributeAnnotations(node, annotation) {\n    // Make copy of original attribute list, since the order may change\n    // as attributes are added and removed\n    let attrs = Array.prototype.slice.call(node.attributes);\n    for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n      let n = a.name;\n      let v = a.value;\n      let b;\n      // events (on-*)\n      if (n.slice(0, 3) === 'on-') {\n        node.removeAttribute(n);\n        annotation.events.push({\n          name: n.slice(3),\n          value: v\n        });\n      }\n      // bindings (other attributes)\n      else if ((b = parseNodeAttributeAnnotation(node, n, v))) {\n        annotation.bindings.push(b);\n      }\n      // static id\n      else if (n === 'id') {\n        annotation.id = v;\n      }\n    }\n  }\n\n  // construct annotation data from a generic attribute, or undefined\n  function parseNodeAttributeAnnotation(node, name, value) {\n    let parts = parseBindings(value);\n    if (parts) {\n      // Attribute or property\n      let origName = name;\n      let kind = 'property';\n      if (name[name.length-1] == '$') {\n        name = name.slice(0, -1);\n        kind = 'attribute';\n      }\n      // Initialize attribute bindings with any literal parts\n      let literal = literalFromParts(parts);\n      if (literal && kind == 'attribute') {\n        node.setAttribute(name, literal);\n      }\n      // Clear attribute before removing, since IE won't allow removing\n      // `value` attribute if it previously had a value (can't\n      // unconditionally set '' before removing since attributes with `$`\n      // can't be set using setAttribute)\n      if (node.localName === 'input' && origName === 'value') {\n        node.setAttribute(origName, '');\n      }\n      // Remove annotation\n      node.removeAttribute(origName);\n      // Case hackery: attributes are lower-case, but bind targets\n      // (properties) are case sensitive. Gambit is to map dash-case to\n      // camel-case: `foo-bar` becomes `fooBar`.\n      // Attribute bindings are excepted.\n      let propertyName = Polymer.CaseMap.dashToCamelCase(name);\n      if (kind === 'property') {\n        name = propertyName;\n      }\n      return {\n        kind: kind,\n        name: name,\n        propertyName: propertyName,\n        parts: parts,\n        literal: literal,\n        isCompound: parts.length !== 1\n      };\n    }\n  }\n\n  // TODO(sorvell): this should be factored into a plugin\n  function prepElement(element) {\n    Polymer.ResolveUrl.resolveAttrs(element, currentTemplate.ownerDocument);\n  }\n\n  Polymer.Annotations = Polymer.Utils.dedupingMixin(function(superClass) {\n\n    return class Annotations extends superClass {\n\n      // preprocess-time\n\n      // construct and return a list of annotation records\n      // by scanning `template`'s content\n      //\n      // TODO(sorvell): This should just crawl over a template and call\n      // a supplied list of callbacks.\n      _parseTemplateAnnotations(template) {\n        return parseTemplateAnnotations(template);\n      }\n\n      // instance-time\n      // TODO(sorvell): consider trying to use QS instead of this proprietary\n      // search. This would require some unique way to identify a node, a guid.\n      // Is this faster? simpler? Is that worth polluting the node?\n      _findTemplateAnnotatedNode(root, note) {\n        // recursively ascend tree until we hit root\n        let parent = note.parent && this._findTemplateAnnotatedNode(root,\n          note.parent);\n        // unwind the stack, returning the indexed node at each level\n        if (parent) {\n          // note: marginally faster than indexing via childNodes\n          // (http://jsperf.com/childnodes-lookup)\n          for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n            if (note.index === i++) {\n              return n;\n            }\n          }\n        } else {\n          return root;\n        }\n      }\n\n    }\n\n  });\n\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/template/annotations.html\n// module id = 31\n// module chunks = 0","/*__wc__loader*/\n\n\n    (function(document) {\n      var _htmlStr = \"\\n\\n\\n\";\n      if (document.head) {\n        var el = document.head;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\n\n    (function(document) {\n      var _htmlStr = \"\";\n      if (document.body) {\n        var el = document.body;\n        var div = document.createElement('div');\n        div.innerHTML = _htmlStr;\n        while (div.children.length > 0) {\n          el.appendChild(div.children[0]);\n        }\n      } else {\n        document.write(_htmlStr);\n      }\n    })(document);\n    \n\nrequire('./boot.html');\n\n\n(function() {\n\n  const Path = {\n\n    isPath: function(path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    root: function(path) {\n      var dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    // Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n    isAncestor: function(base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    // Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n    isDescendant: function(base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    // can be read as:  from  to       path\n    translate: function(base, newBase, path) {\n      // Defense?\n      return newBase + path.slice(base.length);\n    },\n\n    matches: function(base, path) {\n      return (base === path) ||\n             this.isAncestor(base, path) ||\n             this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path\n     * @param {string | !Array<string|number>} path\n     * @return {string}\n     */\n    normalize: function(path) {\n      if (Array.isArray(path)) {\n        var parts = [];\n        for (var i=0; i<path.length; i++) {\n          var args = path[i].toString().split('.');\n          for (var j=0; j<args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Split a path into an array\n     * @param {string | !Array<string|number>} path\n     * @return {!Array<string>}\n     */\n    split: function(path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * @param {Object} root\n     * @param {string | !Array<string|number>} path\n     * @param {Object=} info\n     * @return {*}\n     */\n    get: function(root, path, info) {\n      var prop = root;\n      var parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (var i=0; i<parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        var part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * @param {Object} root\n     * @param {string | !Array<string|number>} path\n     * @param {*} value\n     * @return {string | undefined}\n     */\n    set: function(root, path, value) {\n      var prop = root;\n      var parts = this.split(path);\n      var last = parts[parts.length-1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (var i=0; i<parts.length-1; i++) {\n          var part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  // BC API\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n  \n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/polymer/src/utils/path.html\n// module id = 32\n// module chunks = 0","import './components/hello-world.html';\n\n\n\n// WEBPACK FOOTER //\n// ./index.ts"],"sourceRoot":""}